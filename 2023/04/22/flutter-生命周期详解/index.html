<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="背景我们在学习某个新技术的时候，首先至关重要的是要去了解他的一个整体流程如生命周期等，这样我们在学习和使用的过程才能对技术细节把控，以下主要讲解生命周期相关细节。 生命周期先看图:  Flutter的生命周期主要包含以下内容： 1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。initState：当 widget 第一次插入到 widget 树时">
<meta property="og:type" content="article">
<meta property="og:title" content="flutter 生命周期详解">
<meta property="og:url" content="http://example.com/2023/04/22/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Next">
<meta property="og:description" content="背景我们在学习某个新技术的时候，首先至关重要的是要去了解他的一个整体流程如生命周期等，这样我们在学习和使用的过程才能对技术细节把控，以下主要讲解生命周期相关细节。 生命周期先看图:  Flutter的生命周期主要包含以下内容： 1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。initState：当 widget 第一次插入到 widget 树时">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee71979562404a89aceeaecbbfa3eaf5~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ebbdfb10924caaa2fd01207a0e4cad~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a97e15eff5244ee39741947dd5b2918a~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600937b6eb75418d8d88dfaf888aa15a~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce14d1a9b7b49c591722d6cefd68c93~tplv-k3u1fbpfcp-watermark.image">
<meta property="article:published_time" content="2023-04-22T03:22:43.209Z">
<meta property="article:modified_time" content="2023-04-22T03:23:01.434Z">
<meta property="article:author" content="kyan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee71979562404a89aceeaecbbfa3eaf5~tplv-k3u1fbpfcp-watermark.image">


<link rel="canonical" href="http://example.com/2023/04/22/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/04/22/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/","path":"2023/04/22/flutter-生命周期详解/","title":"flutter 生命周期详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>flutter 生命周期详解 | Next</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Next</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-initState-%EF%BC%9A%E6%AD%A4%E6%96%B9%E6%B3%95%E4%BB%85%E5%9C%A8%E5%B0%8F%E9%83%A8%E4%BB%B6%E6%8F%92%E5%85%A5%E5%88%B0%E6%A0%91%E4%B8%AD%E6%97%B6%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%A7%E8%A1%8C%E5%B0%8F%E9%83%A8%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E3%80%82"><span class="nav-number">2.1.</span> <span class="nav-text">1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-didChangeDependencies-%EF%BC%9A%E6%AD%A4%E6%96%B9%E6%B3%95%E4%BB%85%E5%9C%A8%E5%B0%8F%E9%83%A8%E4%BB%B6%E9%A6%96%E6%AC%A1%E6%9E%84%E5%BB%BA%E6%97%B6%E8%A2%AB%E8%B0%83%E7%94%A8%E3%80%82%E5%A6%82%E6%9E%9C%E8%AF%A5%E5%B0%8F%E9%83%A8%E4%BB%B6%E4%BE%9D%E8%B5%96%E4%BA%8E%E7%88%B6%E7%BA%A7%E5%B0%8F%E9%83%A8%E4%BB%B6%EF%BC%8C%E5%88%99%E5%BD%93%E7%88%B6%E7%BA%A7%E6%9B%B4%E6%94%B9%E6%97%B6%EF%BC%8C%E5%B0%86%E5%86%8D%E6%AC%A1%E8%B0%83%E7%94%A8%E6%AD%A4%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">2.2.</span> <span class="nav-text">2.  didChangeDependencies()：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-build-%EF%BC%9A%E6%AD%A4%E6%96%B9%E6%B3%95%E6%98%AF%E6%9E%84%E5%BB%BA%E5%B0%8F%E9%83%A8%E4%BB%B6%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%AF%E5%BF%85%E9%9C%80%E7%9A%84%E3%80%82%E6%AF%8F%E5%BD%93%E9%9C%80%E8%A6%81%E6%9B%B4%E6%94%B9UI%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E6%AD%A4%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">2.3.</span> <span class="nav-text">3.  build()：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-didUpdateWidget-%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%90%8C%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%83%A8%E4%BB%B6%E5%A4%9A%E6%AC%A1%E6%8F%92%E5%85%A5%E5%88%B0%E6%A0%91%E4%B8%AD%EF%BC%8C%E5%88%99%E4%BC%9A%E8%B0%83%E7%94%A8%E6%AD%A4%E6%96%B9%E6%B3%95%E3%80%82%E6%82%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%AD%A4%E6%96%B9%E6%B3%95%E4%B8%AD%E6%A3%80%E6%9F%A5%E5%89%8D%E5%90%8E%E5%B0%8F%E9%83%A8%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E5%B9%B6%E7%9B%B8%E5%BA%94%E5%9C%B0%E6%9B%B4%E6%96%B0%E5%B0%8F%E9%83%A8%E4%BB%B6%E7%8A%B6%E6%80%81%E3%80%82"><span class="nav-number">2.4.</span> <span class="nav-text">4.  didUpdateWidget()：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-setState-%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%82%A8%E9%9C%80%E8%A6%81%E6%9B%B4%E6%94%B9%E5%B0%8F%E9%83%A8%E4%BB%B6%E7%8A%B6%E6%80%81%E5%B9%B6%E4%BD%BF%E5%85%B6%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90UI%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%AD%A4%E6%96%B9%E6%B3%95%E3%80%82%E5%AE%83%E4%BC%9A%E9%80%9A%E7%9F%A5%E6%A1%86%E6%9E%B6%E9%87%8D%E5%BB%BA%E5%B0%8F%E9%83%A8%E4%BB%B6%E7%9A%84UI%E3%80%82"><span class="nav-number">2.5.</span> <span class="nav-text">5.  setState()：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-deactivate-%EF%BC%9A%E5%BD%93%E5%B0%8F%E9%83%A8%E4%BB%B6%E4%BB%8E%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E6%97%B6%EF%BC%8C%E5%B0%86%E8%B0%83%E7%94%A8%E6%AD%A4%E6%96%B9%E6%B3%95%E3%80%82%E6%AD%A4%E6%97%B6%EF%BC%8C%E5%B0%8F%E9%83%A8%E4%BB%B6%E8%A2%AB%E8%A7%86%E4%B8%BA%E2%80%9C%E5%81%9C%E7%94%A8%E2%80%9D%E3%80%82"><span class="nav-number">2.6.</span> <span class="nav-text">6.  deactivate()：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-dispose-%EF%BC%9A%E8%AF%A5%E6%96%B9%E6%B3%95%E4%BB%85%E5%9C%A8%E5%B0%8F%E9%83%A8%E4%BB%B6%E6%B0%B8%E4%B9%85%E4%BB%8E%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E6%97%B6%E8%B0%83%E7%94%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%A7%E8%A1%8C%E8%B5%84%E6%BA%90%E6%B8%85%E7%90%86%E6%88%96%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C%E3%80%82"><span class="nav-number">2.7.</span> <span class="nav-text">7.  dispose()：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-reassemble"><span class="nav-number">2.8.</span> <span class="nav-text">其他 reassemble()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">布局过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#flutter-%E5%B8%83%E5%B1%80%E6%9B%B4%E6%96%B0"><span class="nav-number">4.</span> <span class="nav-text">flutter 布局更新</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B8%83%E5%B1%80%E8%BE%B9%E7%95%8C"><span class="nav-number">4.1.</span> <span class="nav-text">1.布局边界</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%8D%E4%BE%9D%E8%B5%96%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%97%B6%EF%BC%9B"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.  当前组件父组件的大小不依赖当前组件大小时；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%AA%E5%8F%96%E5%86%B3%E4%BA%8E%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84%E7%BA%A6%E6%9D%9F%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BC%9A%E4%BE%9D%E8%B5%96%E5%90%8E%E4%BB%A3%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82"><span class="nav-number">4.1.2.</span> <span class="nav-text">2.  组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E7%BB%99%E8%87%AA%E8%BA%AB%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%A5%E6%A0%BC%E7%BA%A6%E6%9D%9F%EF%BC%88%E5%9B%BA%E5%AE%9A%E5%AE%BD%E9%AB%98%EF%BC%89%EF%BC%9B"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.  父组件传递给自身的约束是一个严格约束（固定宽高）；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BB%84%E4%BB%B6%E4%B8%BA%E6%A0%B9%E7%BB%84%E4%BB%B6%EF%BC%9B"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.  组件为根组件；</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-markNeedsLayout"><span class="nav-number">4.2.</span> <span class="nav-text">2. markNeedsLayout</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-flushLayout"><span class="nav-number">4.3.</span> <span class="nav-text">3. flushLayout()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Layout%E6%B5%81%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">4. Layout流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sizedByParent"><span class="nav-number">4.4.1.</span> <span class="nav-text">sizedByParent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AccurateSizedBox"><span class="nav-number">4.4.2.</span> <span class="nav-text">AccurateSizedBox</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AfterLayout"><span class="nav-number">4.4.3.</span> <span class="nav-text">AfterLayout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constraints"><span class="nav-number">4.4.4.</span> <span class="nav-text">Constraints</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">4.5.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">kyan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/22/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="flutter 生命周期详解 | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          flutter 生命周期详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-22 11:22:43 / Modified: 11:23:01" itemprop="dateCreated datePublished" datetime="2023-04-22T11:22:43+08:00">2023-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们在学习某个新技术的时候，首先至关重要的是要去了解他的一个整体流程如生命周期等，这样我们在学习和使用的过程才能对技术细节把控，以下主要讲解生命周期相关细节。</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><strong>先看图</strong>:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee71979562404a89aceeaecbbfa3eaf5~tplv-k3u1fbpfcp-watermark.image" alt="2-5.a59bef97.jpg"></p>
<p>Flutter的生命周期主要包含以下内容：</p>
<h2 id="1-initState-：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。"><a href="#1-initState-：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。" class="headerlink" title="1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。"></a>1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。</h2><p>initState：当 widget 第一次插入到 widget 树时会被调用，对于每一个State对象，Flutter 框架只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用BuildContext.dependOnInheritedWidgetOfExactType（该方法用于在 widget 树上获取离当前 widget 最近的一个父级InheritedWidget，关于InheritedWidget我们将在后面章节介绍），原因是在初始化完成后， widget 树中的InheritFrom widget也可能会发生变化，所以正确的做法应该在在build（）方法或didChangeDependencies()中调用它</p>
<h2 id="2-didChangeDependencies-：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。"><a href="#2-didChangeDependencies-：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。" class="headerlink" title="2.  didChangeDependencies()：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。"></a>2.  didChangeDependencies()：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。</h2><p>当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget ，然后在之后的build() 中Inherited widget发生了变化，那么此时InheritedWidget的子 widget 的didChangeDependencies()回调都会被调用。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter 框架会通知 widget 调用此回调。需要注意，组件第一次被创建后挂载的时候（包括重创建）对应的didChangeDependencies也会被调用</p>
<h2 id="3-build-：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。"><a href="#3-build-：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。" class="headerlink" title="3.  build()：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。"></a>3.  build()：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。</h2><p> build()：此回调读它主要是用于构建 widget 子树的，会在如下场景被调用：</p>
<ul>
<li><ol>
<li>在调用initState()之后。</li>
</ol>
</li>
<li><ol start="2">
<li>在调用didUpdateWidget()之后。</li>
</ol>
</li>
<li><ol start="3">
<li>在调用setState()之后。</li>
</ol>
</li>
<li><ol start="4">
<li>在调用didChangeDependencies()之后。</li>
</ol>
</li>
<li><ol start="5">
<li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其他位置之后。</li>
</ol>
</li>
</ul>
<h2 id="4-didUpdateWidget-：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。"><a href="#4-didUpdateWidget-：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。" class="headerlink" title="4.  didUpdateWidget()：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。"></a>4.  didUpdateWidget()：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。</h2><p>在 widget 重新构建时，Flutter 框架会调用widget.canUpdate来检测 widget 树中同一位置的新旧节点，然后决定是否需要更新，如果widget.canUpdate返回true则会调用此回调。正如之前所述，widget.canUpdate会在新旧 widget 的 key 和 runtimeType 同时相等时会返回true，也就是说在在新旧 widget 的key和runtimeType同时相等时didUpdateWidget()就会被调用。</p>
<h2 id="5-setState-：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。"><a href="#5-setState-：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。" class="headerlink" title="5.  setState()：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。"></a>5.  setState()：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。</h2><p>setState 在使用过程中可能会引起有些不必要的渲染可以使用</p>
<p><strong>ValueListenableBuilder</strong> 做优化</p>
<h2 id="6-deactivate-：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。"><a href="#6-deactivate-：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。" class="headerlink" title="6.  deactivate()：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。"></a>6.  deactivate()：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。</h2><p>当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter 框架会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。</p>
<h2 id="7-dispose-：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。"><a href="#7-dispose-：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。" class="headerlink" title="7.  dispose()：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。"></a>7.  dispose()：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。</h2><p>当 State 对象从树中被永久移除时调用；通常在此回调中释放资源。</p>
<h2 id="其他-reassemble"><a href="#其他-reassemble" class="headerlink" title="其他 reassemble()"></a>其他 reassemble()</h2><p>reassemble()：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</p>
<p>以上主要为整个生命周期的过程方法。</p>
<h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><p>布局过程4步骤</p>
<ol>
<li>父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。</li>
<li>子节点根据约束信息确定自己的大小（size）。</li>
<li>父节点根据特定布局规则（不同布局组件会有不同的布局算法）确定每一个子节点在父节点布局空间中的位置，用偏移 offset 表示。</li>
<li>递归整个过程，确定出每一个节点的大小和位置。</li>
</ol>
<p>可以看到，组件的大小是由自身决定的，而组件的位置是由父组件决定的。</p>
<p>Flutter 中的布局类组件很多，根据孩子数量可以分为单子组件和多子组件，下面我们先通过分别自定义一个单子组件和多子组件来直观理解一下Flutter的布局过程，之后会介绍一下布局更新过程和 Flutter 中的 Constraints（约束）。</p>
<h1 id="flutter-布局更新"><a href="#flutter-布局更新" class="headerlink" title="flutter 布局更新"></a>flutter 布局更新</h1><p><strong>对于更新边界是一个非常重要的知识点，对于我们实现高性能刷新绘制有很大的作用。</strong></p>
<h2 id="1-布局边界"><a href="#1-布局边界" class="headerlink" title="1.布局边界"></a>1.布局边界</h2><p>理论上，某个组件的布局变化后，就可能会影响其他组件的布局，所以当有组件布局发生变化后，最笨的办法是对整棵组件树 relayout（重新布局）！但是对所有组件进行 relayout 的成本还是太大，所以我们需要探索一下降低 relayout 成本的方案。实际上，在一些特定场景下，组件发生变化后我们只需要对部分组件进行重新布局即可（而无需对整棵树 relayout ）。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ebbdfb10924caaa2fd01207a0e4cad~tplv-k3u1fbpfcp-watermark.image" alt="Rondorview.png"></p>
<p><strong>上图</strong> 假如 Text3 的文本长度发生变化，则会导致 Text4 的位置和 Column2 的大小也会变化；又因为 Column2 的父组件 SizedBox 已经限定了大小，所以 SizedBox 的大小和位置都不会变化。所以最终我们需要进行 relayout 的组件是：Text3、Column2，这里需要注意：</p>
<ol>
<li>Text4 是不需要重新布局的，因为 Text4 的大小没有发生变化，只是位置发生变化，而它的位置是在父组件 Column2 布局时确定的。</li>
<li>很容易发现：假如 Text3 和 Column2 之间还有其他组件，则这些组件也都是需要 relayout 的。</li>
</ol>
<p>在本例中，Column2 就是 Text3 的 relayoutBoundary （重新布局的边界节点）。每个组件的 renderObject 中都有一个 _relayoutBoundary 属性指向自身的布局边界节点，如果当前节点布局发生变化后，自身到其布局边界节点路径上的所有的节点都需要 relayout。</p>
<p>那么，一个组件是否是 relayoutBoundary 的条件是什么呢？这里有一个原则和四个场景，原则是“组件自身的大小变化不会影响父组件”，如果一个组件满足以下四种情况之一，则它便是 relayoutBoundary ：</p>
<h3 id="1-当前组件父组件的大小不依赖当前组件大小时；"><a href="#1-当前组件父组件的大小不依赖当前组件大小时；" class="headerlink" title="1.  当前组件父组件的大小不依赖当前组件大小时；"></a>1.  当前组件父组件的大小不依赖当前组件大小时；</h3><p> 这种情况下父组件在布局时会调用子组件布局函数时并会给子组件传递一个 parentUsesSize 参数，该参数为 false 时表示父组件的布局算法不会依赖子组件的大小。</p>
<h3 id="2-组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。"><a href="#2-组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。" class="headerlink" title="2.  组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。"></a>2.  组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。</h3><p> 这样的话后代组件的大小变化就不会影响自身的大小了，这种情况组件的 sizedByParent 属性必须为 true。</p>
<h3 id="3-父组件传递给自身的约束是一个严格约束（固定宽高）；"><a href="#3-父组件传递给自身的约束是一个严格约束（固定宽高）；" class="headerlink" title="3.  父组件传递给自身的约束是一个严格约束（固定宽高）；"></a>3.  父组件传递给自身的约束是一个严格约束（固定宽高）；</h3><p> 这种情况下即使自身的大小依赖后代元素，但也不会影响父组件。</p>
<h3 id="4-组件为根组件；"><a href="#4-组件为根组件；" class="headerlink" title="4.  组件为根组件；"></a>4.  组件为根组件；</h3><p> Flutter 应用的根组件是 RenderView，它的默认大小是当前设备屏幕大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line">  _relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-markNeedsLayout"><a href="#2-markNeedsLayout" class="headerlink" title="2. markNeedsLayout"></a>2. markNeedsLayout</h2><p>当组件布局发生变化时，它需要调用 markNeedsLayout 方法来更新布局，它的功能主要有两个：</p>
<ol>
<li>将自身到其 relayoutBoundary 路径上的所有节点标记为 “需要布局” 。</li>
<li>请求新的 frame；在新的 frame 中会对标记为“需要布局”的节点重新布局。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void markNeedsLayout() &#123;</span><br><span class="line"></span><br><span class="line">   _needsLayout = true;</span><br><span class="line"></span><br><span class="line">  if (_relayoutBoundary != this) &#123; // 如果不是布局边界节点</span><br><span class="line"></span><br><span class="line">    markParentNeedsLayout(); // 递归调用前节点到其布局边界节点路径上所有节点的方法 markNeedsLayout</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;// 如果是布局边界节点 </span><br><span class="line"></span><br><span class="line">    if (owner != null) &#123;</span><br><span class="line"></span><br><span class="line">      // 将布局边界节点加入到 pipelineOwner._nodesNeedingLayout 列表中</span><br><span class="line"></span><br><span class="line">      owner!._nodesNeedingLayout.add(this); </span><br><span class="line"></span><br><span class="line">      owner!.requestVisualUpdate();//该函数最终会请求新的 frame</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="3-flushLayout"><a href="#3-flushLayout" class="headerlink" title="3. flushLayout()"></a>3. flushLayout()</h2><p>markNeedsLayout 执行完毕后，就会将其 relayoutBoundary 节点添加到 pipelineOwner._nodesNeedingLayout 列表中，然后请求新的 frame，新的 frame 到来时就会执行 drawFrame 方法（</p>
<p>flushLayout() 中会对之前添加到 _nodesNeedingLayout 中的节点重新布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void flushLayout() &#123;</span><br><span class="line"></span><br><span class="line">  while (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line"></span><br><span class="line">    final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line"></span><br><span class="line">    _nodesNeedingLayout = &lt;RenderObject&gt;[]; </span><br><span class="line"></span><br><span class="line">    //按照节点在树中的深度从小到大排序后再重新layout</span><br><span class="line"></span><br><span class="line">    for (final RenderObject node in dirtyNodes..sort((a,b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line"></span><br><span class="line">      if (node._needsLayout &amp;&amp; node.owner == this)</span><br><span class="line"></span><br><span class="line">        node._layoutWithoutResize(); //重新布局</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 flushLayout() 中刷新布局时要先对dirtyNodes 根据在树中的深度按照从小到大排序？从大到小不行吗？</p>
<ul>
<li>因为节点更新是从父节点到子节点以此跟新，如果颠倒了顺序会带来不必要的更新操作，大大影响了性能。</li>
</ul>
<h2 id="4-Layout流程"><a href="#4-Layout流程" class="headerlink" title="4. Layout流程"></a>4. Layout流程</h2><p>如果组件有子组件，则在 performLayout 中需要调用子组件的 layout 方法先对子组件进行布局， layout 的核心流程如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123;</span><br><span class="line"></span><br><span class="line">  RenderObject? relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  // 先确定当前组件的布局边界</span><br><span class="line"></span><br><span class="line">  if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line"></span><br><span class="line">    relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // _needsLayout 表示当前组件是否被标记为需要布局</span><br><span class="line"></span><br><span class="line">  // _constraints 是上次布局时父组件传递给当前组件的约束</span><br><span class="line"></span><br><span class="line">  // _relayoutBoundary 为上次布局时当前组件的布局边界</span><br><span class="line"></span><br><span class="line">  // 所以，当当前组件没有被标记为需要重新布局，且父组件传递的约束没有发生变化，</span><br><span class="line"></span><br><span class="line">  // 且布局边界也没有发生变化时则不需要重新布局，直接返回即可。</span><br><span class="line"></span><br><span class="line">  if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果需要布局，缓存约束和布局边界</span><br><span class="line"></span><br><span class="line">  _constraints = constraints;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 后面解释</span><br><span class="line"></span><br><span class="line">  if (sizedByParent) &#123;</span><br><span class="line"></span><br><span class="line">    performResize();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 执行布局</span><br><span class="line"></span><br><span class="line">  performLayout();</span><br><span class="line"></span><br><span class="line">  // 布局结束后将 _needsLayout 置为 false</span><br><span class="line"></span><br><span class="line">  _needsLayout = false;</span><br><span class="line"></span><br><span class="line">  // 将当前组件标记为需要重绘（因为布局发生变化后，需要重新绘制）</span><br><span class="line"></span><br><span class="line">  markNeedsPaint();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>简单来讲布局过程分以下几步：</p>
<ol>
<li>确定当前组件的布局边界。</li>
<li>判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局时需要同时满足三个条件：</li>
</ol>
<ul>
<li>当前组件没有被标记为需要重新布局。</li>
<li>父组件传递的约束没有发生变化。</li>
<li>当前组件的布局边界也没有发生变化时。</li>
</ul>
<ol start="3">
<li>调用 performLayout() 进行布局，因为 performLayout() 中又会调用子组件的 layout 方法，所以这时一个递归的过程，递归结束后整个组件树的布局也就完成了。</li>
<li>请求重绘。</li>
</ol>
<h3 id="sizedByParent"><a href="#sizedByParent" class="headerlink" title="sizedByParent"></a>sizedByParent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (sizedByParent) &#123;</span><br><span class="line"></span><br><span class="line">  performResize(); //重新确定组件大小</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sizedByParent 为 true 时表示：当前组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。前面我们说过，performLayout 中确定当前组件的大小时通常会依赖子组件的大小，如果 sizedByParent 为 true，则当前组件的大小就不依赖子组件大小了，为了逻辑清晰，Flutter 框架中约定，当sizedByParent 为 true 时，确定当前组件大小的逻辑应抽离到 performResize() 中，这种情况下 performLayout 主要的任务便只有两个：对子组件进行布局和确定子组件在当前组件中的布局起始位置偏移</p>
<p>通过一个 AccurateSizedBox 示例来演示一下 sizedByParent 为 true 时我们应该如何布局：</p>
<h3 id="AccurateSizedBox"><a href="#AccurateSizedBox" class="headerlink" title="AccurateSizedBox"></a>AccurateSizedBox</h3><p>Flutter 中的 SizedBox 组件会将其父组件的约束传递给其子组件，这也就意味着，如果父组件限制了最小宽度为100，即使我们通过 SizedBox 指定宽度为50，那也是没用的，<strong>因为 SizedBox的实现中会让 SizedBox 的子组件先满足 SizedBox 父组件的约束</strong>。还记得之前我们想在 AppBar 中限制 loading 组件大小的例子吗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AppBar(</span><br><span class="line"></span><br><span class="line">    title: Text(title),</span><br><span class="line"></span><br><span class="line">    actions: &lt;Widget&gt;[</span><br><span class="line"></span><br><span class="line">      SizedBox( // 尝试使用SizedBox定制loading 宽高</span><br><span class="line"></span><br><span class="line">        width: 20, </span><br><span class="line"></span><br><span class="line">        height: 20,</span><br><span class="line"></span><br><span class="line">        child: CircularProgressIndicator(</span><br><span class="line"></span><br><span class="line">          strokeWidth: 3,</span><br><span class="line"></span><br><span class="line">          valueColor: AlwaysStoppedAnimation(Colors.white70),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a97e15eff5244ee39741947dd5b2918a~tplv-k3u1fbpfcp-watermark.image" alt="尺寸限制类容器.png"></p>
<p>之所以不生效，是因为父组件限制了最小高度，当然我们也可以使用 UnconstrainedBox + SizedBox 来实现我们想要的效果，但是这里我们希望通过一个组件就能搞定，为此我们自定义一个 AccurateSizedBox 组件，它和 SizedBox 的主要区别是 AccurateSizedBox 自身会遵守其父组件传递的约束<strong>而不是让其子组件去满足AccurateSizedBox 父组件的约束</strong>，具体：</p>
<ol>
<li>AccurateSizedBox 自身大小只取决于父组件的约束和用户指定的宽高。</li>
<li>AccurateSizedBox 确定自身大小后，限制其子组件大小。</li>
</ol>
<p>根据上边的几个规则找到解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AccurateSizedBox extends SingleChildRenderObjectWidget &#123;</span><br><span class="line"></span><br><span class="line">  const AccurateSizedBox(&#123;</span><br><span class="line"></span><br><span class="line">    Key? key,</span><br><span class="line"></span><br><span class="line">    this.width = 0,</span><br><span class="line"></span><br><span class="line">    this.height = 0,</span><br><span class="line"></span><br><span class="line">    required Widget child,</span><br><span class="line"></span><br><span class="line">  &#125;) : super(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  final double width;</span><br><span class="line"></span><br><span class="line">  final double height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    return RenderAccurateSizedBox(width, height);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void updateRenderObject(context, RenderAccurateSizedBox renderObject) &#123;</span><br><span class="line"></span><br><span class="line">    renderObject</span><br><span class="line"></span><br><span class="line">      ..width = width</span><br><span class="line"></span><br><span class="line">      ..height = height;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RenderAccurateSizedBox extends RenderProxyBoxWithHitTestBehavior &#123;</span><br><span class="line"></span><br><span class="line">  RenderAccurateSizedBox(this.width, this.height);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  double width;</span><br><span class="line"></span><br><span class="line">  double height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 当前组件的大小只取决于父组件传递的约束</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  bool get sizedByParent =&gt; true;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // performResize 中会调用</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Size computeDryLayout(BoxConstraints constraints) &#123;</span><br><span class="line"></span><br><span class="line">    //设置当前元素宽高，遵守父组件的约束</span><br><span class="line"></span><br><span class="line">    return constraints.constrain(Size(width, height));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // @override</span><br><span class="line"></span><br><span class="line">  // void performResize() &#123;</span><br><span class="line"></span><br><span class="line">  //   // default behavior for subclasses that have sizedByParent = true</span><br><span class="line"></span><br><span class="line">  //   size = computeDryLayout(constraints);</span><br><span class="line"></span><br><span class="line">  //   assert(size.isFinite);</span><br><span class="line"></span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">    child!.layout(</span><br><span class="line"></span><br><span class="line">      BoxConstraints.tight(</span><br><span class="line"></span><br><span class="line">          Size(min(size.width, width), min(size.height, height))),</span><br><span class="line"></span><br><span class="line">      // 父容器是固定大小，子元素大小改变时不影响父元素</span><br><span class="line"></span><br><span class="line">      // parentUseSize为false时，子组件的布局边界会是它自身，子组件布局发生变化后不会影响当前组件</span><br><span class="line"></span><br><span class="line">      parentUsesSize: false,</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>上面代码有三点需要注意：</p>
<ol>
<li>我们的 RenderAccurateSizedBox 不再直接继承自 RenderBox，而是继承自 RenderProxyBoxWithHitTestBehavior，RenderProxyBoxWithHitTestBehavior 是间接继承自 RenderBox的，它里面包含了默认的命中测试和绘制相关逻辑，继承自它后就不用我们再手动实现了。</li>
<li>我们将确定当前组件大小的逻辑挪到了computeDryLayout 方法中，因为RenderBox 的 performResize 方法会调用 computeDryLayout ，并将返回结果作为当前组件的大小。按照Flutter 框架约定，我们应该重写computeDryLayout 方法而不是 performResize 方法，就像在布局时我们应该重写 performLayout 方法而不是 layout 方法；不过，这只是一个约定，并非强制，但我们应该尽可能遵守这个约定，除非你清楚的知道自己在干什么并且能确保之后维护你代码的人也清楚。</li>
<li>RenderAccurateSizedBox 在调用子组件 layout 时，将 parentUsesSize 置为 false，这样的话子组件就会变成一个布局边界。</li>
</ol>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AccurateSizedBoxRoute extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  const AccurateSizedBoxRoute(&#123;Key? key&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    final child = GestureDetector(</span><br><span class="line"></span><br><span class="line">      onTap: () =&gt; print(&quot;tap&quot;),</span><br><span class="line"></span><br><span class="line">      child: Container(width: 300, height: 300, color: Colors.red),</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return Row(</span><br><span class="line"></span><br><span class="line">      children: [</span><br><span class="line"></span><br><span class="line">        ConstrainedBox(</span><br><span class="line"></span><br><span class="line">          constraints: BoxConstraints.tight(Size(100, 100)),</span><br><span class="line"></span><br><span class="line">          child: SizedBox(</span><br><span class="line"></span><br><span class="line">            width: 50,</span><br><span class="line"></span><br><span class="line">            height: 50,</span><br><span class="line"></span><br><span class="line">            child: child,</span><br><span class="line"></span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        Padding(</span><br><span class="line"></span><br><span class="line">          padding: const EdgeInsets.only(left: 8),</span><br><span class="line"></span><br><span class="line">          child: ConstrainedBox(</span><br><span class="line"></span><br><span class="line">            constraints: BoxConstraints.tight(Size(100, 100)),</span><br><span class="line"></span><br><span class="line">            child: AccurateSizedBox(</span><br><span class="line"></span><br><span class="line">              width: 50,</span><br><span class="line"></span><br><span class="line">              height: 50,</span><br><span class="line"></span><br><span class="line">              child: child,</span><br><span class="line"></span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600937b6eb75418d8d88dfaf888aa15a~tplv-k3u1fbpfcp-watermark.image" alt="306.png"></p>
<p>可以发现，当父组件约束子组件大小宽高是100时，我们通过 SizedBox 指定 Container 大小是为 50×50 是不能成功的， 而通过 AccurateSized 时成功了。</p>
<p>这里需要提醒一下读者，如果一个组件的的 sizedByParent 为 true，那它在布局子组件时也是能将 parentUsesSize 置为 true 的，sizedByParent 为 true 表示自己是布局边界，而将 parentUsesSize 置为 true 或 false 决定的是子组件是否是布局边界，两者并不矛盾，这个不要混淆了。顺便提一点 Flutter 自带的 OverflowBox 组件的实现中，它的 sizedByParent 为 true，在调用子组件layout 方法时，parentUsesSize 传的是 true，具体通过OverflowBox 的实现源码可以找到原因。</p>
<h3 id="AfterLayout"><a href="#AfterLayout" class="headerlink" title="AfterLayout"></a>AfterLayout</h3><p>AfterLayout 可以在布局结束后拿到子组件的代理渲染对象 （RenderAfterLayout）， RenderAfterLayout 对象会代理子组件渲染对象 ，因此，通过RenderAfterLayout 对象也就可以获取到子组件渲染对象上的属性，比如件大小、位置等。</p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AfterLayout extends SingleChildRenderObjectWidget &#123;</span><br><span class="line"></span><br><span class="line">  AfterLayout(&#123;</span><br><span class="line"></span><br><span class="line">    Key? key,</span><br><span class="line"></span><br><span class="line">    required this.callback,</span><br><span class="line"></span><br><span class="line">    Widget? child,</span><br><span class="line"></span><br><span class="line">  &#125;) : super(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    return RenderAfterLayout(callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void updateRenderObject(</span><br><span class="line"></span><br><span class="line">      BuildContext context, RenderAfterLayout renderObject) &#123;</span><br><span class="line"></span><br><span class="line">    renderObject..callback = callback;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///组件树布局结束后会被触发，注意，并不是当前组件布局结束后触发</span><br><span class="line"></span><br><span class="line">  final ValueSetter&lt;RenderAfterLayout&gt; callback;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RenderAfterLayout extends RenderProxyBox &#123;</span><br><span class="line"></span><br><span class="line">  RenderAfterLayout(this.callback);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ValueSetter&lt;RenderAfterLayout&gt; callback;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">    super.performLayout();</span><br><span class="line"></span><br><span class="line">    // 不能直接回调callback，原因是当前组件布局完成后可能还有其他组件未完成布局</span><br><span class="line"></span><br><span class="line">    // 如果callback中又触发了UI更新（比如调用了 setState）则会报错。因此，我们</span><br><span class="line"></span><br><span class="line">    // 在 frame 结束的时候再去触发回调。</span><br><span class="line"></span><br><span class="line">    SchedulerBinding.instance</span><br><span class="line"></span><br><span class="line">        .addPostFrameCallback((timeStamp) =&gt; callback(this));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /// 组件在屏幕坐标中的起始点坐标（偏移）</span><br><span class="line"></span><br><span class="line">  Offset get offset =&gt; localToGlobal(Offset.zero);</span><br><span class="line"></span><br><span class="line">  /// 组件在屏幕上占有的矩形空间区域</span><br><span class="line"></span><br><span class="line">  Rect get rect =&gt; offset &amp; size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码有三点需要注意：</p>
<ol>
<li>callback 调用时机不是在子组件完成布局后就立即调用，原因是子组件布局完成后可能还有其他组件未完成布局，如果此时调用callback，一旦 callback 中存在触发更新的代码（比如调用了 setState）则会报错。因此我们在 frame 结束的时候再去触发回调。</li>
<li>RenderAfterLayout 的 performLayout方法中直接调用了父类 RenderProxyBox 的 performLayout方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">  if (child != null) &#123;</span><br><span class="line"></span><br><span class="line">    child!.layout(constraints, parentUsesSize: true);</span><br><span class="line"></span><br><span class="line">    size = child!.size;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    size = computeSizeForNoChild(constraints);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到是直接将父组件传给自身的约束传递给子组件，并将子组件的大小设置为自身大小。也就是说 RenderAfterLayout 的大小和其子组件大小是相同的</p>
<p>我们定义了 offset 和 rect 两个属性，它们是组件相对于屏幕的的位置偏移和占用的矩形空间范围。但是实战中，我们经常需要获取的是子组件相对于某个父级组件的坐标和矩形空间范围，这时候我们可以调用 RenderObject 的localToGlobal 方法，比如下面的的代码展示了Stack中某个子组件获取相对于Stack 的矩形空间范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget build(context)&#123;</span><br><span class="line"></span><br><span class="line">  return Stack(</span><br><span class="line"></span><br><span class="line">    alignment: AlignmentDirectional.topCenter,</span><br><span class="line"></span><br><span class="line">    children: [</span><br><span class="line"></span><br><span class="line">      AfterLayout(</span><br><span class="line"></span><br><span class="line">        callback: (renderAfterLayout)&#123;</span><br><span class="line"></span><br><span class="line">         //我们需要获取的是AfterLayout子组件相对于Stack的Rect</span><br><span class="line"></span><br><span class="line">         _rect = renderAfterLayout.localToGlobal(</span><br><span class="line"></span><br><span class="line">            Offset.zero,</span><br><span class="line"></span><br><span class="line">            //找到 Stack 对应的 RenderObject 对象</span><br><span class="line"></span><br><span class="line">            ancestor: context.findRenderObject(),</span><br><span class="line"></span><br><span class="line">          ) &amp; renderAfterLayout.size;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        child: Text(&#x27;Flutter@wendux&#x27;),</span><br><span class="line"></span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>Constraints（约束）主要描述了最小和最大宽高的限制，理解组件在布局过程中如何根据约束确定自身或子节点的大小对我们理解组件的布局行为有很大帮助，现在我们就通过一个实现 200*200 的红色 Container 的例子来说明。为了排除干扰，我们让根节点（RenderView）作为 Container 的父组件，我们的代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Container(width: 200, height: 200, color: Colors.red)</span><br></pre></td></tr></table></figure>

<p>但实际运行之后，你会发现整个屏幕都变成了红色！为什么呢？我们看看 RenderView 的布局实现：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line"></span><br><span class="line">void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">  //configuration.size 为当前设备屏幕</span><br><span class="line"></span><br><span class="line">  _size = configuration.size; </span><br><span class="line"></span><br><span class="line">  if (child != null)</span><br><span class="line"></span><br><span class="line">    child!.layout(BoxConstraints.tight(_size)); //强制子组件和屏幕一样大</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要介绍一下两种常用的约束：</p>
<ol>
<li>宽松约束：不限制最小宽高（为0），只限制最大宽高，可以通过 BoxConstraints.loose(Size size) 来快速创建。</li>
<li>严格约束：限制为固定大小；即最小宽度等于最大宽度，最小高度等于最大高度，可以通过 BoxConstraints.tight(Size size) 来快速创建。</li>
</ol>
<p>可以发现，RenderView 中给子组件传递的是一个严格约束，即强制子组件大小等于屏幕大小，所以 Container 便撑满了屏幕。那我们怎么才能让指定的大小生效呢？标准答案就是<strong>引入一个中间组件，让这个中间组件遵守父组件的约束，然后对子组件传递新的约束</strong>。对于这个例子来讲，最简单的方式是用一个 Align 组件来包裹 Container：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@override</span><br><span class="line"></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">  var container = Container(width: 200, height: 200, color: Colors.red);</span><br><span class="line"></span><br><span class="line">  return Align(</span><br><span class="line"></span><br><span class="line">    child: container,</span><br><span class="line"></span><br><span class="line">    alignment: Alignment.topLeft,</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Align 会遵守 RenderView 的约束，让自身撑满屏幕，然后会给子组件传递一个宽松约束（最小宽高为0，最大宽高为200），这样 Container 就可以变成 200 * 200 了。</p>
<p>当然我们还可以使用其他组件来代替 Align，比如 UnconstrainedBox，但原理是相同的.</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> flutter 的布局流程</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce14d1a9b7b49c591722d6cefd68c93~tplv-k3u1fbpfcp-watermark.image" alt="saz&#39;s.png"></p>
<p><strong>在进行布局的时候，Flutter 会以 DFS（深度优先遍历）方式遍历渲染树，并 <strong>将限制以自上而下的方式</strong> 从父节点传递给子节点。子节点若要确定自己的大小，则 <strong>必须</strong> 遵循父节点传递的限制。子节点的响应方式是在父节点建立的约束内 <strong>将大小以自下而上的方式</strong> 传递给父节点。</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BCrash%E6%94%B6%E9%9B%86%E4%B8%8E%E9%98%B2%E6%8A%A4/" rel="prev" title="性能优化之Crash收集与防护">
                  <i class="fa fa-chevron-left"></i> 性能优化之Crash收集与防护
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/04/23/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8E%A2%E7%A9%B6/" rel="next" title="iOS 组件化探究">
                  iOS 组件化探究 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kyan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
