<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Next">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Next">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="kyan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Next</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Next</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">代码小记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">kyan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/28/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/28/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">iOS安装包优化笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-28 22:23:42" itemprop="dateCreated datePublished" datetime="2023-07-28T22:23:42+08:00">2023-07-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer" />
# 一.前言

<h2 id="App安装包日益增大原因"><a href="#App安装包日益增大原因" class="headerlink" title="App安装包日益增大原因"></a>App安装包日益增大原因</h2><p>随着技术飞速发展，功能不断迭代，APP不断更新和改版，越来越大、越来越全，因此造成了app安装包的不断膨胀。</p>
<ol>
<li>新功能的增加：新的功能需要更多的代码和资源来实现，导致APP体积增大。</li>
<li>针对不同设备的优化代码：为了在各种不同分辨率和硬件平台的手机上正常使用，APP需要针对每种设备分别编写优化代码。这种“碎片化”代码会包含很多冗余代码，从而增加软件体积。</li>
<li>硬件设备规格的改变：当硬件设备的某些规格改变后，APP也必须做出相应的改变，这通常会导致APP体积增大。例如，当iPhone的屏幕分辨率提高后，APP需要适配新的分辨率，导致界面素材的部分需要占用更大的存储空间。</li>
<li>优先适配旗舰机：大部分APP在测试时优先适配旗舰机，这会导致在低端机上使用时可能出现不流畅或闪退等问题，而高端机则不会出现这些问题。</li>
</ol>
<h3 id="安装包大小首今夕对比"><a href="#安装包大小首今夕对比" class="headerlink" title="安装包大小首今夕对比"></a>安装包大小首今夕对比</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b31d61076041c9ba1f7ede8d601339~tplv-k3u1fbpfcp-watermark.image" alt="50个用户没楼过亿的.webp"></p>
<h2 id="为什么要优化包大小"><a href="#为什么要优化包大小" class="headerlink" title="为什么要优化包大小"></a>为什么要优化包大小</h2><p>在精细化运营的角逐中，用户体验、版本更新、内容品质、安装包大小等因素都影响着移动应用厂商的生存状态。特别是安装包体大小，无论是手游还是移动应用，包体变大不仅关系着用户下载转化，也关系着渠道推广成本和难度，在整体大盘用户规模增长的情况下，应用获量的竞争日益激烈，有40.8%的开发者认为投入产出比相对于去年同期呈现下降趋势，51.5%的开发者认为，与去年同期相比应用产品的获客成本单价有所上升，这是用户获取成本的增加与付费能力的限制。（来自网络）</p>
<h3 id="对比举例"><a href="#对比举例" class="headerlink" title="对比举例"></a>对比举例</h3><p>为什么微信小程序相比app 有更好的转化和推广能力呢，其实有很大原因也是因为用户能快速使用安装</p>
<p>微信小程序与APP相比有以下优势：</p>
<ol>
<li>无需下载和安装：微信小程序可以直接在微信中使用，无需下载和安装，这样可以节省用户的存储空间和下载时间。</li>
<li>快速加载：微信小程序采用轻量级的技术架构，加载速度快，用户可以快速打开使用。</li>
<li>无需更新：微信小程序可以在后台自动更新，用户无需手动更新应用程序。</li>
<li>便于分享：微信小程序可以通过微信分享给好友、群组或朋友圈，方便用户分享应用程序。</li>
<li>轻量级：微信小程序相对于App来说，占用的存储空间更小，对手机性能的消耗也更少。</li>
<li>跨平台：微信小程序可以同时运行在ios和Android平台上，无需为不同平台开发不同版本的应用程序。</li>
</ol>
<p>总之，微信小程序相比APP具有无需下载安装、快速加载、无需更新、便于分享、轻量级、开发成本低、跨平台等优势。</p>
<p>因此相对于小程序 来说，app 如果想更好的发挥转化使用率等因素，就需要在安装包上下功夫了。</p>
<h3 id="官方数据"><a href="#官方数据" class="headerlink" title="官方数据"></a>官方数据</h3><p>此外<strong>包体大小每上升6MB，应用下载转化率就会下降1%</strong></p>
<p>数据来在2019谷歌开发者大会上</p>
<p>谷歌给出了一个很详细的数据，包体大小每上升6MB，应用下载转化率就会下降1%。不同地区转化率略有差异，APK包体大小每减少10MB ，全球平均下载转化率会提升1.75%，新兴国家代表印度和巴西下载转化率提升2.0%以上，高端市场代表美国和德国下载转化率提升1.5%。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0360e7a171374cb7ba008647bee057df~tplv-k3u1fbpfcp-watermark.image" alt="8694a4c27d1ed21b776225488b5c2bce50da3fb4.png@f_auto.webp"></p>
<h3 id="其他因素"><a href="#其他因素" class="headerlink" title="其他因素"></a>其他因素</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/help/app-store-connect/reference/maximum-build-file-sizes">https://developer.apple.com/help/app-store-connect/reference/maximum-build-file-sizes</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0f6b06baf04d8ebe3f499ac407d151~tplv-k3u1fbpfcp-watermark.image" alt="Maximum build file sizes.png"></p>
<h4 id="App-Store-OTA-下载大小限制"><a href="#App-Store-OTA-下载大小限制" class="headerlink" title="App Store OTA 下载大小限制"></a>App Store OTA 下载大小限制</h4><p>苹果公司为了避免用户超出运营商套餐流量，限制了用户通过流量从 AppStore 下载 App 的最大大小， 简称 OTA 下载大小限制。其历史沿革：</p>
<ul>
<li>2017 年 9 月，限制从 100MB 提升到了 150MB；</li>
<li>2019 年 5 月下旬，苹果把 OTA 下载限制放宽到 200MB；</li>
<li>iOS 13 发布之后 iOS13 及以上用户可以使用流量下载超出 200MB 的 App， 但需要用户「设置」选择策略，默认为「超过 200MB 请求许可」，而 iOS13 以下用户仍然无法下载。</li>
</ul>
<p>除了上边的限制之外 Apple 对可执行文件__TEXT 段的限制则更为严苛，如果超出这个限制 APP 将无法通过 AppStore 审核。这个限制简而言之，如果要支持 iOS8 的设备， App 单架构主二进制 __TEXT 段上限为 60MB（以 1000KB 为 1M，而不是 1024），放弃对 iOS8 的支持二进制大小限制则变为安装包内最大二进制所有架构的总和不超过 500MB。</p>
<h4 id="安装包大小增长的影响"><a href="#安装包大小增长的影响" class="headerlink" title="安装包大小增长的影响"></a>安装包大小增长的影响</h4><p>AppStore 下载大小如果在 OTA 下载限制内增长，对用户新增、留存等指标影响不大。而一旦超过 OTA 下载限制，则对整体指标产生明显影响。之前统计的劣化数据指标：当限制在 150MB 并且无法下载的时候，对用户的新增有 10%的影响。由于 iOS13 限制的宽松化，所以在 iOS13 之后设备上这个数据将低于 10%。此数据仅供参考并不能一概而论，对于不同类型的 App 首次安装的场景会呈现差异，比如生活服务、出行类 App 对应蜂窝下载场景会多于影音类、游戏类 App。</p>
<p>其次对仍然需要支持 iOS8 以下的 App， 超出 __TEXT 段大小的限制将会很大程度上影响审核以及发版进度。当然可以通过一些手段进行救急，比如拆分动态库的方式绕过。但是这些手段可能导致安装包整体变得更大。</p>
<p>除了 Apple 的限制外，包大小的劣化一定程度上意味着更加慢的启动速度；更多的的代码逻辑；更低研发效率；过于复杂的代码还会带来对代码修改的风险将对稳定性产生负面影响；让性能等基础体验变差，所以包大小不是一个孤立的指标，它从侧面的反映出 App 的健康状态。</p>
<p><strong>综上，对于用户来说安装包大小是一个非常重要的指标，安装包资源大小优化是非常重要的</strong>。</p>
<h1 id="二-苹果对安装包做的优化"><a href="#二-苹果对安装包做的优化" class="headerlink" title="二.苹果对安装包做的优化"></a>二.苹果对安装包做的优化</h1><p><a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f</a></p>
<p>App Store和操作系统优化了iOS、tvOS和watchOS应用程序的安装，根据用户特定设备和操作系统版本的功能定制应用程序交付，以最小的占用空间。这种优化被称为应用精简，允许你创建使用最多设备功能，占用最小磁盘空间，并适应苹果未来可能应用的更新的应用。更快的下载速度和更多的空间为其他应用程序和内容提供了更好的用户体验。</p>
<h2 id="Slicing-iOS-tvOS"><a href="#Slicing-iOS-tvOS" class="headerlink" title="Slicing (iOS, tvOS)"></a>Slicing (iOS, tvOS)</h2><p>针对不同目标设备和操作系统版本创建和发布应用包变体的过程。变体只包含目标设备和操作系统版本所需的可执行体系结构和资源。你可以继续开发并将应用的完整版本上传到app Store Connect。App Store会根据你的应用支持的设备和操作系统版本，创建并发布不同的版本。使用资产目录，以便App Store可以为每个变体选择图像，GPU资源和其他数据。当用户安装应用程序时，将下载并安装用户设备和操作系统版本的变体。</p>
<p>在运行iOS和tvOS 9.0及更高版本的设备上支持切片应用。否则，App Store会向用户提供通用版本。通用版本也可以通过移动设备管理(MDM)，通过Apple School Manager或Apple Business Manager批量购买的应用程序，或使用iTunes 12.6或更早版本下载的应用程序提供。</p>
<p>对于在 AppStore 发布的包，苹果也为 App 提供了很多优化方式，而这些是通过企业证书签发的包无法做到的。</p>
<p>当 App 构建完安装包之后上传到 AppStore Connect 后, AppStore Connect 会根据设备、系统来创建其变体（variant）以适配不同的设备，用户从 App Store 中下载到的安装包时候，只下载自己设备用到变体。</p>
<p>变体之间的差异取决于设备的处理器架构（arm64, armv7）、屏幕分辨率（2x, 3x）、iOS 系统版本。</p>
<p>当然这也导致很难用线下构建的安装包来量化最终对下载大小的影响。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/896b81a6911e425eb066e2c38de4600f~tplv-k3u1fbpfcp-watermark.image" alt="App record.png"></p>
<h2 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h2><p>位码是已编译程序的中间表示形式。你上传到App Store Connect的包含位码的应用程序将被编译并链接到App Store上。包含位码将允许苹果在未来重新优化你的应用二进制，而无需向app Store提交新版本的应用。</p>
<p>对于iOS应用程序，比特码是默认的，但也是可选的。对于watchOS和tvOS应用程序，需要位码。如果你提供了bitcode，那么app bundle中的所有应用和框架(项目中的所有目标)都需要包含bitcode。</p>
<p>Xcode默认隐藏应用程序的符号，所以苹果无法读取它们。当你将应用上传到app Store Connect时，你可以选择包含符号。当你使用TestFlight或通过app Store发布应用时，包含符号可以让苹果为你的应用提供崩溃报告。如果你想自己收集和标记崩溃报告，你不需要上传符号。相反，您可以在发布应用程序后下载位码编译dSYM文件。</p>
<h2 id="按需资源-iOS、tvOS"><a href="#按需资源-iOS、tvOS" class="headerlink" title="按需资源(iOS、tvOS)"></a>按需资源(iOS、tvOS)</h2><p>按需资源是指可以用关键字标记并按标记分组请求的资源(例如图像和声音)。App Store托管苹果服务器上的资源，并为你管理下载。App Store还按需分割资源，进一步优化应用的变体。</p>
<p>按需资源提供更好的用户体验:</p>
<ul>
<li><p>应用尺寸更小，所以下载速度更快，改善了首次发布的体验。</p>
</li>
<li><p>当用户浏览应用程序时，根据需要在后台下载按需资源。</p>
</li>
<li><p>操作系统在不再使用或磁盘空间不足时清理按需资源。</p>
</li>
</ul>
<p>例如，应用程序可以将资源划分为级别，并仅在应用程序预计用户将移动到下一级别时请求下一级别的资源。同样，只有当用户进行了相应的应用内购买时，应用才能请求应用内购买资源。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2ea85a78cd49ecae3b4aa3cd59f416~tplv-k3u1fbpfcp-watermark.image" alt="Appicon.png"></p>
<p>综上苹果架构优化主要体现在</p>
<p><strong>关于指令集</strong></p>
<p>x86_64 和 i386，是用于模拟器的芯片指令集架构文件；arm64、armv7、armv7s ，是真机的芯片指令集架构文件。</p>
<ul>
<li><p>使用 App Thinning 后，用户下载时就只会下载一个适合自己设备的芯片指令集架构文件。App Thinning 有三种方式，包括：App Slicing、Bitcode、On-Demand Resources。</p>
</li>
<li><p>App Slicing，会在你向 iTunes Connect 上传 App 后，对 App 做切割，创建不同的变体，这样就可以适用到不同的设备。</p>
</li>
<li><p>On-Demand Resources，主要是为游戏多关卡场景服务的。它会根据用户的关卡进度下载随后几个关卡的资源，并且已经过关的资源也会被删掉，这样就可以减少初装 App 的包大小。</p>
</li>
<li><p>Bitcode ，是针对特定设备进行包大小优化，优化不明显。</p>
</li>
</ul>
<h1 id="三-优化准备工作"><a href="#三-优化准备工作" class="headerlink" title="三.优化准备工作"></a>三.优化准备工作</h1><h2 id="分析安装包组成"><a href="#分析安装包组成" class="headerlink" title="分析安装包组成"></a>分析安装包组成</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5014b7577c2405ba6cb4380e225eea7~tplv-k3u1fbpfcp-watermark.image" alt="DemoProject.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f6aa1ef17e3483b9dd6bf971cda1111~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="四-技术方案"><a href="#四-技术方案" class="headerlink" title="四.技术方案"></a>四.技术方案</h1><h2 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h2><h3 id="大资源优化"><a href="#大资源优化" class="headerlink" title="大资源优化"></a>大资源优化</h3><p>资源是指plist、js、css、json、端智能模型文件等，因这些文件和图片在优化方式差异很大，所以把两者区分开来。获取大资源主要途径是递归遍历ipa包的所有资源，体积大于指定阈值（一般20-40kb）的文件就是需要对其优化的文件</p>
<p><a target="_blank" rel="noopener" href="https://github.com/fndppx/PracticallyScripts/blob/main/%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B/big_file_check.py">https://github.com/fndppx/PracticallyScripts/blob/main/%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B/big_file_check.py</a></p>
<p>通过扫描可以看到对应超过阈值的文件:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0a75cacdbb485b853f9ae9f255b40a~tplv-k3u1fbpfcp-watermark.image" alt="pythons UsersdDesktopgithubPractical1ySeripts交件.png"></p>
<p>此外可以对其他大资源，比如皮肤资源，h5缓存文件等采用下载zip包方式获取，下载成功后合适的时机解压。</p>
<ul>
<li>异步下载：只要APP首次启动时不需要加载该资源，或者即使首次启动需要加载但是使用频率不高，那么该资源就可以走异步下载;</li>
<li>资源压缩：当APP首次启动需要加载且频率较高的情况下，可以对大块资源先进行压缩内置APP，启动阶段异步线程解压再使用；</li>
</ul>
<h3 id="无用配置或者图片文件"><a href="#无用配置或者图片文件" class="headerlink" title="无用配置或者图片文件"></a>无用配置或者图片文件</h3><p>针对特定的配置文件类型非必要的进行扫描，自己控制类型，如扫描图片和 html 文件目录是否有其他类型文件</p>
<p>针对图片资源首先将png、webp、gif、jpg排除掉，JS&amp;CSS资源是一般HTML加载的，对于需要扫描图片资源目录通过排除</p>
<p><a target="_blank" rel="noopener" href="https://github.com/fndppx/PracticallyScripts/blob/main/%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B/type_check.py">https://github.com/fndppx/PracticallyScripts/blob/main/%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B/type_check.py</a></p>
<h3 id="重复资源优化"><a href="#重复资源优化" class="headerlink" title="重复资源优化"></a>重复资源优化</h3><p><a target="_blank" rel="noopener" href="https://github.com/fndppx/PracticallyScripts/blob/main/%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B/type_check.py">https://github.com/fndppx/PracticallyScripts/blob/main/%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B/type_check.py</a></p>
<p>指定目录或者从iPA包中获取所有资源文件，通过MD5判断资源是否重复</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9431bd5827e74b89843a16225be926d3~tplv-k3u1fbpfcp-watermark.image" alt="Base.lproj.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e370c41bdba49a8870a2d92bd05137c~tplv-k3u1fbpfcp-watermark.image" alt="python3 Users ma DesktopgithubPracticallyseripts文伴检果.png"></p>
<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><h3 id="无用图片优化：-基于开源工具扫描"><a href="#无用图片优化：-基于开源工具扫描" class="headerlink" title="无用图片优化： 基于开源工具扫描"></a>无用图片优化： 基于开源工具扫描</h3><p>LSUnusedResources</p>
<p>如何扫描的</p>
<ul>
<li><p>在文件夹[imageset, launchimage, appiconset, bundle, png]中获取资源文件(默认:[imageset, jpg, png, gif])。</p>
</li>
<li><p>使用正则表达式搜索代码文件中的所有字符串名称(默认值:[h, m, mm, swift, xib, storyboard, strings, c, cpp, html, js, json, plist, css])。</p>
</li>
<li><p>从资源文件中排除所有使用的字符串名称，我们得到所有未使用的资源文件。</p>
</li>
</ul>
<h3 id="Asset-Catalog图片优化"><a href="#Asset-Catalog图片优化" class="headerlink" title="Asset Catalog图片优化"></a>Asset Catalog图片优化</h3><p>之前在bundle需要放二倍图和三倍图，同一张图片最后在用户手机上会有两份，iOS7系统有了Asset Catalog后，Asset Catalog为不同类型设备(分辨率不同)或者相同类型设备但不同配置(磁盘不同)提供定制化资源下载，当用户下载App时，只有跟用户手机硬件设备参数相匹配的资源才会被下载，其他不会下载，从而降低下载包体积；</p>
<p>优势</p>
<ul>
<li><p>包体积瘦身</p>
</li>
<li><p>统一的图片无损压缩</p>
</li>
<li><p>便利的资源管理</p>
</li>
<li><p>高效的<strong><strong>I&#x2F;O</strong></strong>操作</p>
</li>
</ul>
<p>苹果官方对比：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24adaef848c406c9eef54b8cd2a552e~tplv-k3u1fbpfcp-watermark.image" alt="Apple Deep Pixel Image Compression.png"></p>
<h3 id="HEIC图片优化"><a href="#HEIC图片优化" class="headerlink" title="HEIC图片优化"></a>HEIC图片优化</h3><p>更改PNG和JPEG图片编码格式，选择HEIC方案，基于以下优点：1、体积最小，HEIC比PNG体积减少50%，WebP比PNG优化30%；2、解码效率高，跟WebP相比，HEIC硬解码效率高，略慢于JPEG；</p>
<blockquote>
<p>HEIC(High Efficiency Image Coding)是一种图像编码标准，它可以极大提升压缩率，并有效减小储存占用，自iOS 11和macOS High Sierra(10.13)开始，苹果将HEIC设置为图片存储的默认格式，它由动态影像专家小组（MPEG）开发，并在MPEG-H Part 12（ISO&#x2F;IEC 23008-12）中定义，以下是HEIC图片的特点：</p>
</blockquote>
<p><strong>压缩率高</strong>：HEIC图片比JPEG图片压缩率高1.5倍，比PNG图片压缩率高3倍，也比GIF图片压缩率高3倍。</p>
<p><strong>节省内存</strong>：HEIC图片比JPEG图片节省20%的存储空间，比PNG图片节省50%的存储空间，比GIF图片节省80%的存储空间。</p>
<p><strong>解码效率高</strong>：在iOS系统中，HEIC采用硬解码，解码效率高，跟WebP(软编码)相比，是其100倍，但略慢于JPEG。</p>
<p><strong>保留原始图像质量</strong>：HEIC图片采用H.264和JEP格式压缩，可以保留原始图像质量。</p>
<p><strong>支持无损放大</strong>：HEIC图片支持无损放大，可以将图片放大两倍而不失真。</p>
<p><strong>色彩处理方面：</strong> HEIC图片可以根据像素点的亮度分布自动亮度、对比度和饱和度，从而更好地还原图像的真实色彩。</p>
<p><strong>系统兼容性好</strong>：我们知道iOS 11开始HEIC是图片存储的默认格式，也就是iOS 11以后的系统都支持HEIC图片，对这部分用户如何处理？在实践中发现，在iOS10系统上，当把HEIC图片放xcasset文件里，最后图片也是可以正常显示的，用Asset Catalog Tinkerer工具解压出Assets.car 文件，发现在xcasset里的HEIC图片，对于iOS10的系统，在打包时会被系统转化为png格式图片，Asset Catalog解决了HEIC图片的兼容性问题。</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715d4a8acdb44363b98203898f2c0c2d~tplv-k3u1fbpfcp-watermark.image" alt="打开.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc9437bb2dba4194be87a8c0f9a03f88~tplv-k3u1fbpfcp-watermark.image" alt="转换图像.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70b3e57d9829434f987e102337c7ce9d~tplv-k3u1fbpfcp-watermark.image" alt="转换图像.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17672525eff942cf91e9d4b5fafab0b3~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 4.png"></p>
<p>代码加载和png无差异</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *img = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;test_image_h&quot;]];</span><br><span class="line"></span><br><span class="line">[self.view addSubview:img];</span><br><span class="line"></span><br><span class="line">img.frame = CGRectMake(100, 100, 200, 100);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于大图HEIC格式明显体积小</li>
</ul>
<p>理论上来说，HEIC格式图片的体积是PNG格式图片的三分之一，但实际过程发现对于大图，这个优化效果很明显，但是对于小图尤其是小于10K的图片，HEIC图片还有可能超过PNG格式图片，所以我们在做HEIC图片编码优化时，对于小图不建议用这种方式。</p>
<ul>
<li>带有Alpha通道的PNG图片不要做有损压缩</li>
</ul>
<p>在实践过程中发现，一张PNG原图，尤其是带有Alpha通道，经过有损压缩(TinyPng或ImageOptim)后，再生成HEIC图片时，在iOS12，13，14系统上会显示绿幕，所以带有Alpha通道的PNG图片不要做有损压缩，存在兼容性问题。</p>
<p><strong>转换完成最好要测试下保证不会出现异常加载失败的问题</strong></p>
<h3 id="WebP-压缩优化"><a href="#WebP-压缩优化" class="headerlink" title="WebP****压缩优化"></a>WebP****压缩优化</h3><p>HEIC是iOS12以后推出来一种新格式，对于带有Alpha通道的并经过压缩的PNG图片，转换为HEIC格式后，在iOS12和13系统存在兼容性问题，Alpha通道全变为0，为此对于这种case，尤其是大图，如果图片大小超过了 100KB，可以考虑使用 WebP可以采用WebP压缩优化；</p>
<h4 id="来将其他图片转成-WebP"><a href="#来将其他图片转成-WebP" class="headerlink" title="来将其他图片转成 WebP"></a>来将其他图片转成 WebP</h4><p>Google开发的</p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/docs/precompiled">https://developers.google.com/speed/webp/docs/precompiled</a></p>
<p>腾讯开发的</p>
<p><a target="_blank" rel="noopener" href="http://isparta.github.io/">http://isparta.github.io/</a></p>
<p>转换完毕后显示图片时使用 libwebp 进行解析</p>
<p><a target="_blank" rel="noopener" href="https://github.com/carsonmcdonald/WebP-iOS-example">https://github.com/carsonmcdonald/WebP-iOS-example</a></p>
<p>对于小于 100KB 时，你可以使用网页工具 TinyPng 或者 GUI 工具ImageOptim进行图片压缩。</p>
<h3 id="TinyPng压缩"><a href="#TinyPng压缩" class="headerlink" title="TinyPng压缩"></a>TinyPng压缩</h3><p> WebP 在 CPU 消耗和解码时间上会比 PNG 高两倍，因为对于大于100KB的图片可以使用 WebP，对于小于 100KB 图片，使用TinyPng进行压缩，虽然压缩率没有 WebP 那么高，但是没有改变图片编码方式，所以不会增加解析性能损耗。</p>
<h2 id="编译器优化-amp-xcode架构优化"><a href="#编译器优化-amp-xcode架构优化" class="headerlink" title="编译器优化 &amp; xcode架构优化"></a>编译器优化 &amp; xcode架构优化</h2><h3 id="xcode14优化"><a href="#xcode14优化" class="headerlink" title="xcode14优化"></a>xcode14优化</h3><p><strong>Xcode</strong> <strong>支持</strong> ****XCode14的升级对包体积带来比较明显的优化，官方给出数据是应用程序下载包体积减小了 30%</p>
<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bd9fe0cf6c649ff8bb46e5464bf6cce~tplv-k3u1fbpfcp-watermark.image" alt="OC&amp;Ge+请有编洋优 Optimization.png"></p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p><strong>LinkMap检查每个类占用大小</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jayden320/LinkMap"><strong>https://github.com/jayden320/LinkMap</strong></a></p>
<p>Link Map 是 Mach-O 格式的二进制文件的一种辅助文件，它描述了可执行文件的全貌，包括编译后的每一个目标文件的信息以及它们在可执行文件中的代码段、数据段存储详情。通过Link Map文件，我们可以知道可执行文件的路径、CPU架构、目标文件、符号等信息，分析可执行文件中哪个类或库占用比较大，进行安装包瘦身，此外，我们可以清楚地了解可执行文件的内部结构和各个目标文件在其中的位置关系，这对于分析和调试非常有帮助。</p>
<p>Mach-O 查看</p>
<p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/machoview/"><strong>https://sourceforge.net/projects/machoview/</strong></a></p>
<p><strong>Object文件列表</strong></p>
<p>Object文件列表列出了所有编译后的目标文件，包括.o文件和dylib库。每个目标文件都有一个对应的编号，通过该编号可以对应到具体的类，Symbols会用到此编号。</p>
<p><strong>Section段表</strong></p>
<p>section段表描述了各个段在最终编译成的可执行文件中的偏移位置及大小，包括代码段（TEXT）和数据段（DATA）。段表中第一列是数据在文件的偏移位置，第二列是Section占用大小，第三列是Segment类型，第四列是Section类型，关于Segment和Section</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981765798cb74a5a9a3e644c0517c197~tplv-k3u1fbpfcp-watermark.image" alt="Sectiions.webp"></p>
<p><strong>2.3.4 Symbols</strong></p>
<hr>
<p>Symbols模块给出了类里面的方法在内存具体情况。其中</p>
<ul>
<li>第一列是方法起始地址，通过这个地址我们可以查上面的段表；</li>
<li>第二列是大小，通过这个可以算出方法占用的大小；</li>
<li>第三列是归属的类(.o)，值是具体编号，通过反查目标文件列表可以知道对应的类；</li>
<li>第四列是方法名称。</li>
</ul>
<p>通过Symbols模块我们可以分析出来每个类对应方法的大小。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e0f61225b1f46b08a944a423a19eca1~tplv-k3u1fbpfcp-watermark.image" alt="File NM.webp"></p>
<h3 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h3><p><strong>58开源的工具</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuba/WBBlades">https://github.com/wuba/WBBlades</a></p>
<p><strong>利用appcode 工具检测无用的代码</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jetbrains.com.cn/objc/">https://www.jetbrains.com.cn/objc/</a></p>
<p>用 AppCode 做分析的方法很简单，直接在 AppCode 里选择 Code-&gt;Inspect Code 就可以进行静态分析。</p>
<ul>
<li><p>无用类：Unused class 是无用类，Unused import statement 是无用类引入声明，Unused property 是无用的属性；</p>
</li>
<li><p>无用方法：Unused method 是无用的方法，Unused parameter 是无用参数，Unused instance variable 是无用的实例变量，Unused local variable 是无用的局部变量，Unused value 是无用的值；</p>
</li>
<li><p>无用宏：Unused macro 是无用的宏。</p>
</li>
<li><p>无用全局：Unused global declaration 是无用全局声明。</p>
</li>
</ul>
<p><strong>appcode缺点</strong></p>
<ul>
<li><p>某些库里定义了未使用的协议会被判定为无用协议</p>
</li>
<li><p>如果子类使用了父类的方法，父类的这个方法不会被认为使用了；通过点的方式使用属性，该属性会被认为没有使用；使用 performSelector 方式调用的方法也检查不出来，比如 self performSelector:@selector(arrivalRefreshTime)；</p>
</li>
<li><p>运行时声明类的情况检查不出来。比如通过 NSClassFromString 方式调用的类会被查出为没有使用的类，比如 layerClass &#x3D; NSClassFromString(@“SMFloatLayer”)。还有以[[self class] accessToken] 这样不指定类名的方式使用的类，会被认为该类没有被使用。像 UITableView 的自定义的 Cell 使用 registerClass，这样的情况也会认为这个 Cell 没有被使用。</p>
</li>
<li><p>使用 AppCode 检查出来的无用代码，还需要人工二次确认才能够安全删除掉。</p>
</li>
</ul>
<h3 id="动态检查"><a href="#动态检查" class="headerlink" title="动态检查"></a>动态检查</h3><p>运行时检查类是否真正被使用过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define RW_INITIALIZED (1&lt;&lt;29)</span><br><span class="line"></span><br><span class="line">bool isInitialized() &#123;</span><br><span class="line"></span><br><span class="line">   return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isInitialized 的结果会保存到元类的 class_rw_t 结构体的 flags 信息里，flags 的 1&lt;&lt;29 位记录的就是这个类是否初始化了的信息。而 flags 的其他位记录的信息，objc runtime 的源码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 类的方法列表已修复</span><br><span class="line"></span><br><span class="line">#define RW_METHODIZED         (1&lt;&lt;30)</span><br><span class="line"></span><br><span class="line">// 类已经初始化了</span><br><span class="line"></span><br><span class="line">#define RW_INITIALIZED        (1&lt;&lt;29)</span><br><span class="line"></span><br><span class="line">// 类在初始化过程中</span><br><span class="line"></span><br><span class="line">#define RW_INITIALIZING       (1&lt;&lt;28)</span><br><span class="line"></span><br><span class="line">// class_rw_t-&gt;ro 是 class_ro_t 的堆副本</span><br><span class="line"></span><br><span class="line">#define RW_COPIED_RO          (1&lt;&lt;27)</span><br><span class="line"></span><br><span class="line">// 类分配了内存，但没有注册</span><br><span class="line"></span><br><span class="line">#define RW_CONSTRUCTING       (1&lt;&lt;26)</span><br><span class="line"></span><br><span class="line">// 类分配了内存也注册了</span><br><span class="line"></span><br><span class="line">#define RW_CONSTRUCTED        (1&lt;&lt;25)</span><br><span class="line"></span><br><span class="line">// GC：class有不安全的finalize方法</span><br><span class="line"></span><br><span class="line">#define RW_FINALIZE_ON_MAIN_THREAD (1&lt;&lt;24)</span><br><span class="line"></span><br><span class="line">// 类的 +load 被调用了</span><br><span class="line"></span><br><span class="line">#define RW_LOADED             (1&lt;&lt;23)</span><br></pre></td></tr></table></figure>

<h1 id="五-其他流程阶段预防"><a href="#五-其他流程阶段预防" class="headerlink" title="五.其他流程阶段预防"></a>五.其他流程阶段预防</h1><p>1.开发阶段图片大小把关</p>
<p> 使用前压缩，命名规范，xcassets统一管理图片</p>
<p>2.通过Jenkins打包监控对比包大小增长</p>
<p><strong>总结</strong>：</p>
<p>通过上述对包大小优化的背景和收益的理解，再到结合工具和流程方案找出其短板，根据自己项目的情况合理采取对应方案持续优化关注，才是需要长期坚持做下去的。</p>
<p><strong>感谢参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MjU0NTI5OQ==&mid=2247560043&idx=1&sn=4ff274eb120078bdd8d0f2bddda8e1f6&chksm=c03fdb17f748520153979d2a80e86eda4d72bf549ff9ce6d8045982aad33e814927de239bfb6&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg5MjU0NTI5OQ==&amp;mid=2247560043&amp;idx=1&amp;sn=4ff274eb120078bdd8d0f2bddda8e1f6&amp;chksm=c03fdb17f748520153979d2a80e86eda4d72bf549ff9ce6d8045982aad33e814927de239bfb6&amp;scene=21#wechat_redirect</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6916317500992913421">https://juejin.cn/post/6916317500992913421</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/20/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/20/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86/" class="post-title-link" itemprop="url">iOS启动优化看我就够了</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-20 23:15:52" itemprop="dateCreated datePublished" datetime="2023-06-20T23:15:52+08:00">2023-06-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>iOS启动优化是指在iOS设备上提升应用程序的启动速度和响应性能的一系列技术和方法。随着移动设备的普及和应用程序的功能复杂化，用户对应用程序的响应速度要求也越来越高，因此启动优化成为了开发者们关注的重要领域。</p>
<p>说到启动，这其实是一个非常重要的用户体验场景，早期有些博主喜欢拿安卓和苹果打开某个应用的时间来对比设备之间的差异，也通过这个启动某个软件的时间这个指标判断两者系统的优劣。</p>
<p>当然对于用户来说在某些场景也是影响很大，拿我之前遇到一个场景来说，当时和多年未见的朋友见面，说好了请对方吃饭，到了付钱的时候，我的朋友也抢着去付钱，在这个时候，我准备点开微信app 启动的时候，忽然卡住了，然后最后让朋友抢先一步付了钱，这是不是很尴尬。</p>
<p>话说回来，苹果对于启动时间过长会有一个看门狗机制，如果启动时间过长，看门狗将终止它，这对用户来说也是致命的。</p>
<p>通常情况下，如果应用程序是他们常规工作流程的一部分，用户一天会多次启动该应用程序，而较长的启动时间会导致执行任务的延迟。</p>
<p>当用户点击主屏幕上的应用程序图标时，iOS 会在将控制权移交给应用程序进程之前准备启动应用程序。该应用程序然后运行代码以准备将其 UI 绘制到屏幕上。即使在应用的 UI 可见之后，应用可能仍在准备内容或用最终控件替换间隙界面。这些步骤中的每一个都会影响应用程序的总感知启动时间。</p>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>下面就先从启动的整个流程来看看启动到底都做了哪些事情</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95ac028121b243b5a8a2867b46a0f39f~tplv-k3u1fbpfcp-watermark.image" alt="iOS 启动优化.png"></p>
<h2 id="从几个大的阶段来划分"><a href="#从几个大的阶段来划分" class="headerlink" title="从几个大的阶段来划分"></a>从几个大的阶段来划分</h2><p>可以看出主要分为以下几个大阶段</p>
<p> 1.加载Mach-O阶段</p>
<p> 2.dyld 阶段 </p>
<p> 3.main 之后阶段：加载启动项到最终的viewDidAppear调用加载第一帧。</p>
<h2 id="从dyld和runtime角度来划分"><a href="#从dyld和runtime角度来划分" class="headerlink" title="从dyld和runtime角度来划分"></a>从dyld和runtime角度来划分</h2><p>如果结合dyld 和runtime 这两个核心模块来划分，启动阶段主要由他们两者协作完成。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a8a220428b045df93c5007d296787ff~tplv-k3u1fbpfcp-watermark.image" alt="Launch Time.webp"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a441c5bd54d04955b78ea21368dc8cdf~tplv-k3u1fbpfcp-watermark.image" alt="image2.png"></p>
<h2 id="详细阶段步骤"><a href="#详细阶段步骤" class="headerlink" title="详细阶段步骤"></a>详细阶段步骤</h2><p>那么整体的流程可以梳理为以下步骤</p>
<h3 id="一-内核态加载mach-o文件和可执行文件"><a href="#一-内核态加载mach-o文件和可执行文件" class="headerlink" title="一.内核态加载mach-o文件和可执行文件"></a>一.内核态加载mach-o文件和可执行文件</h3><p>关于mach-o文件</p>
<p><strong>Mach-O文件简介</strong></p>
<ul>
<li>Mach object的缩写，是Mac、iOS上用于存储程序、库的标准格式 ，Mach-O文件是一种叫法，就像以 .text 结尾的文件，被叫做为text文件</li>
</ul>
<p><strong>常见的Mach-O文件有：</strong></p>
<ul>
<li>MH_OBJECT：目标文件(.o)、静态库文件(.a) 静态库其实就是N个.o合并在一起</li>
<li>MH_EXECUTE：可执行文件 .app&#x2F;xx</li>
<li>MH_DYLIB：动态库文件 .dylib 或 .framework&#x2F;xx</li>
<li>MH_DYLINKER：动态链接编辑器 &#x2F;usr&#x2F;lib&#x2F;dyld</li>
<li>MH_DSYM：存储着二进制文件符号信息的文件 .dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;xx（常用于分析APP的崩溃信息）</li>
</ul>
<p><strong>可执行文件:</strong></p>
<ul>
<li>平时编写的代码最终会被编译成为一个Mach-O格式的文件</li>
<li>开发过程中所用到的动态库(比如：UIKit、Foundation) 依赖信息也会存储在可执行文件中</li>
</ul>
<h3 id="二-dyld-阶段"><a href="#二-dyld-阶段" class="headerlink" title="二.dyld 阶段"></a>二.dyld 阶段</h3><p>简单介绍下dyld是什么</p>
<blockquote>
<p>“dyld” 是苹果操作系统中的一个重要组件，它是动态链接器（dynamic linker）的缩写。动态链接器是操作系统加载和链接可执行文件所需的共享库的核心组件之一。</p>
<p>dyld 的主要功能是在程序启动时加载和链接程序所依赖的共享库，并将其映射到进程的内存空间中。它负责解析和处理共享库之间的符号依赖关系，以及处理运行时的符号重定位。</p>
<p>具体来说，dyld 的工作流程如下：</p>
<ol>
<li>加载：当一个可执行文件（如应用程序）启动时，dyld 负责加载可执行文件和它所依赖的共享库到内存中。</li>
<li>符号解析：dyld 解析可执行文件和共享库中的符号引用，找到对应的符号定义，以便正确地链接和运行程序。</li>
<li>符号重定位：在加载和链接过程中，dyld 会处理符号重定位，将程序中的符号引用指向正确的地址。</li>
<li>启动程序：完成加载和链接后，dyld 将控制权转交给程序的入口点，使其开始执行。</li>
</ol>
<p>dyld 的存在使得应用程序可以动态地加载和链接共享库，从而实现了代码的共享和重用。这也是为什么在 iOS 开发中，我们可以使用各种系统提供的框架和库来构建应用程序。dyld 是苹果操作系统中负责动态加载和链接共享库的组件，它在应用程序启动时发挥着关键的作用，确保程序能够正确地加载和执行所需的代码和库。</p>
</blockquote>
<p><strong>关于动态库:</strong></p>
<ul>
<li>程序运行时由系统动态加载到内存，而不是复制，供程序调用。</li>
<li>系统只加载一次，多个程序共用，节省内存。因此，编译内容更小，而且因为动态库是需要时才被引用，所以更快。 简单认识：系统的UIKit框架最终被dyld以动态库的形式加载到内存 ！</li>
</ul>
<h4 id="dyld阶段所做的事情"><a href="#dyld阶段所做的事情" class="headerlink" title="dyld阶段所做的事情"></a>dyld阶段所做的事情</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e14bff4660b44449918d65718dea6a45~tplv-k3u1fbpfcp-watermark.image" alt="Dyld Steps.png"></p>
<p><strong>load dylibs &gt; rebase bind &gt; objc（Notify ObjC Runtime） &gt; initializers</strong></p>
<h5 id="1-load-dylibs"><a href="#1-load-dylibs" class="headerlink" title="1.load dylibs"></a>1.load dylibs</h5><p>装载app的可执行文件，同时会递归加载所有依赖的动态库。</p>
<ul>
<li><p>Parse image（解析图像）：在这个步骤中，dyld 解析可执行文件或共享库的二进制格式。它会读取可执行文件的头部和段（segments），以及共享库的符号表和重定位信息等。通过解析图像，dyld 能够了解文件的结构、符号引用和重定位需求。</p>
</li>
<li><p>Map image（映射图像）：在这一阶段，dyld 将可执行文件或共享库映射到进程的内存空间中。它会分配适当的内存区域，并将二进制文件的内容加载到这些内存区域中。通过映射图像，dyld 将文件中的代码、数据和资源加载到内存，为后续的重定位和符号绑定做准备。</p>
</li>
</ul>
<p>当dyld加载完可执行文件 和动态库 之后通知runtime进行下一步操作。</p>
<h5 id="2-Rebase-bind"><a href="#2-Rebase-bind" class="headerlink" title="2.Rebase + bind"></a>2.Rebase + bind</h5><ul>
<li><p>Rebase image（重定位图像）：在此步骤中，dyld 处理可执行文件和共享库中的重定位信息。重定位信息描述了代码和数据的位置相对于内存中的基地址的偏移量。dyld 根据基地址和重定位信息来计算并更新代码和数据的绝对地址，以确保它们在内存中正确定位。</p>
</li>
<li><p>Bind image（符号绑定图像）：在这个阶段，dyld 解析可执行文件和共享库中的符号引用，并将它们绑定到相应的符号定义。符号绑定是将符号引用与符号定义相关联的过程，确保程序能够正确地访问和执行所需的符号。通过符号绑定，dyld 确保程序能够正确链接并执行依赖的函数和变量。</p>
</li>
</ul>
<h5 id="3-objc（Notify-ObjC-Runtime）"><a href="#3-objc（Notify-ObjC-Runtime）" class="headerlink" title="3.objc（Notify ObjC Runtime）"></a>3.objc（Notify ObjC Runtime）</h5><ul>
<li>mapimages 对二进制文件内容解析处理。</li>
<li>runtime在此处初始化，对class和category进行注册。</li>
<li>进行各种objc结构的初始化（objc 类被定义和注册）。</li>
<li>分类被插入到方法列表中。</li>
<li>selector唯一性判断。</li>
</ul>
<h5 id="4-Initializers"><a href="#4-Initializers" class="headerlink" title="4.Initializers"></a>4.Initializers</h5><ul>
<li>loadimages 调用 call_load_images 加载 类和 分类的 load方法</li>
<li>调用c++静态初始化器和__attribute（construct）修饰的函数</li>
</ul>
<p>至此可执行文件和动态库的符号sel  class protocol IMP 都已经按需加载到内存中了，被runtime管理最后,Dyld calls main()</p>
<h3 id="三-进入main函数"><a href="#三-进入main函数" class="headerlink" title="三.进入main函数"></a>三.进入main函数</h3><ul>
<li><p>接下来就是 UIApplicationMain 函数，相关的调用了，Appdelegate会依次执行 对应的生命周期方法。</p>
</li>
<li><p>创建整个app的autoreleasepool，初始化初始window，app界面开始展。</p>
</li>
<li><p>指定rootviewcontroller，调用业务代码，完成各阶段业务。</p>
</li>
<li><p>main页面viewDidAppear 完成页面第一帧渲染。至此启动完成。</p>
</li>
</ul>
<h2 id="关于启动标准"><a href="#关于启动标准" class="headerlink" title="关于启动标准"></a>关于启动标准</h2><p>苹果的标准</p>
<ul>
<li><p>针对启动时间的最佳标准 （400ms 是一个很好的目标）</p>
</li>
<li><p>最坏的情况 （不要超过20秒否则应用程序将被杀死）</p>
</li>
</ul>
<h2 id="关于优化方案"><a href="#关于优化方案" class="headerlink" title="关于优化方案"></a>关于优化方案</h2><p>优化方案从各个阶段来考虑</p>
<h3 id="1-加载mach-o阶段"><a href="#1-加载mach-o阶段" class="headerlink" title="1.加载mach-o阶段"></a>1.加载mach-o阶段</h3><p>重新排列函数符号位置，降低MACH-O文件载入内存时PageFault缺页中断频率 - 二进制重排</p>
<ul>
<li>一种是抖音的方案二进制重排。（官方说会有百分之30提升，自己尝试并没有太大提升。）</li>
<li>另外是苹果推出的pgo。（大概有百分之10左右的提升）</li>
</ul>
<p>两者类似</p>
<p><strong>原理</strong></p>
<p>二进制重排实际上是在windows和linux上就存在的技术，旨在将启动用到的函数方法尽可能的放置在二进制文件加载的前面，并且是将函数符号地址连续的编译在一起，以减少Page Fault的次数和频率，加快启动速度。现在这项技术已经移植运用到了移动端app上。</p>
<p>操作系统为了解决安全问题和效率问题，抽象出了虚拟内存页的概念。内存都是分页访问的。这里的page指的就是内存页。(就像磁盘存储的最小单位 磁盘簇，大小是4k一样) MacOS 、linux (4K为一页) iOS(16K为一页)</p>
<p>PageFault就是缺页中断：当app调用一个方法，发现该方法没有在内存中，此时操作系统就会立刻阻塞整个app进程，触发一个缺页中断。操作系统会从磁盘中读取这页数据到物理内存上 , 然后再将其映射到虚拟内存上 ( 如果当前内存已满 , 操作系统会通过置换页算法 <strong>找一页数据进行覆盖，</strong> 这也是为什么开再多的应用也不会崩掉 , 但是之前开的应用再打开时 , 就重新启动了的根本原因 )。</p>
<p>假如，app启动时期需要调用 method1、method5和method6，这三个方法分布在page1、page2和page3上。每装载一个内存页page都会发生一次PageFault(缺页终端)。通常一个PageFault的处理时间是0.1ms~1ms，取0.5ms计算。这三次处理PageFault时间是 3 * 0.5ms &#x3D; 1.5ms。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c1e6e02db94bd487a540263e9a2c3c~tplv-k3u1fbpfcp-watermark.image" alt="page1.webp"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72692b3c5e834446b3c939f439d8b137~tplv-k3u1fbpfcp-watermark.image" alt="page1.png"></p>
<h3 id="2-针对dyld阶段"><a href="#2-针对dyld阶段" class="headerlink" title="2.针对dyld阶段"></a>2.针对dyld阶段</h3><ul>
<li><p>减少动态库 合并动态库 （定期清理不必要的动态库）</p>
</li>
<li><p>减少oc 类 分类 方法 sel（定期清理不必要的类 分类）</p>
</li>
<li><p>减少c++虚函数数量</p>
</li>
<li><p>swift尽量使用struct</p>
</li>
</ul>
<h3 id="3-针对objc-和-initialize-可以看做是-runtime-阶段"><a href="#3-针对objc-和-initialize-可以看做是-runtime-阶段" class="headerlink" title="3.针对objc 和 initialize 可以看做是 runtime  阶段"></a>3.针对objc 和 initialize 可以看做是 runtime  阶段</h3><ul>
<li>用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load</li>
</ul>
<h3 id="4-针对-main函数之后阶段"><a href="#4-针对-main函数之后阶段" class="headerlink" title="4.针对 main函数之后阶段"></a>4.针对 main函数之后阶段</h3><ul>
<li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中</li>
<li>启动任务的顺序调整优化</li>
<li>降低初始视图的复杂性</li>
<li>按需加载</li>
</ul>
<h2 id="关于测试（建议在支持的最慢设备上测试）"><a href="#关于测试（建议在支持的最慢设备上测试）" class="headerlink" title="关于测试（建议在支持的最慢设备上测试）"></a>关于测试（建议在支持的最慢设备上测试）</h2><p>1.推荐2个github 工具</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ming1016/GCDFetchFeed">https://github.com/ming1016/GCDFetchFeed</a> （SMCallTrace）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/EmergeTools/ETTrace">https://github.com/EmergeTools/ETTrace</a></li>
</ul>
<p>2.Xcode 和 instrument自带工具</p>
<ul>
<li>lldb调试工具设置 <strong>Edit scheme -&gt; Run -&gt; Arguments 中将环境变量 DYLD_PRINT_STATISTICS 设为 1统计结果会在打印窗口输出</strong></li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f773a4f9c8e44e5bae8aa790f0bee20e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34b20c78d5a54d85a24864d5828b5cf2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>通过instrument 的 launching</li>
</ul>
<p>3.线上监控</p>
<p>主动埋点 分为pre-main 和 main 之后</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/667d94baa924493c9eb4fa9d0196054d~tplv-k3u1fbpfcp-watermark.image" alt="v2-d46b6f2bd967c78f704cccbb05584caa_1440w.webp"></p>
<p>通过苹果的metric</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc0051c3e40e42488266b5ea82965b75~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上基本涵盖了iOS 启动各个阶段的详细流程，以及优化方案，当然启动优化也是一个长期需要关注的稳定性指标，也要结合当前项目情况分步优化，通过优化&gt;监控&gt;优化 形成闭环，发现问题并解决问题，最终持续下去肯定会有收益的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/19/%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B9%8B%E6%88%91%E7%9C%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/19/%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B9%8B%E6%88%91%E7%9C%8B/" class="post-title-link" itemprop="url">热修复之我看</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-19 23:12:03" itemprop="dateCreated datePublished" datetime="2023-05-19T23:12:03+08:00">2023-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>移动端热修复是指在移动应用程序中对已发布的应用进行动态修复和更新，而无需用户重新下载安装新版本的应用。以下是一些研究移动端热修复的原因：</p>
<ol>
<li><p>修复应用程序漏洞和Bug：移动应用程序可能存在各种漏洞和Bug，这些问题可能会导致应用程序崩溃、功能失效或数据泄露等问题。通过研究移动端热修复技术，开发人员可以快速响应并修复这些问题，而无需用户等待和下载完整的应用程序更新。</p>
</li>
<li><p>提供快速更新和功能迭代：移动应用程序的开发和发布通常需要经过一定的时间和审核过程，这使得快速修复和更新应用程序变得困难。通过研究移动端热修复技术，开发人员可以更快地推出新功能和修复问题，以满足用户的需求并提供更好的用户体验。</p>
</li>
<li><p>减少用户流失和提高用户满意度：当用户遇到应用程序中的问题或缺陷时，他们可能会感到不满并选择卸载应用程序。通过使用移动端热修复技术，开发人员可以在最短时间内修复问题，并避免用户因问题而离开应用程序，从而提高用户满意度和用户留存率。</p>
</li>
<li><p>降低应用程序维护成本：传统的应用程序更新需要发布新版本，并要求用户下载和安装更新，这需要耗费开发人员和用户的时间和资源。通过使用移动端热修复技术，可以减少应用程序的发布次数和用户的下载次数，从而降低应用程序的维护成本。</p>
</li>
</ol>
<p>总而言之，研究移动端热修复可以提供一种快速、高效和经济的方式来修复移动应用程序中的问题，提供更好的用户体验，并降低开发和维护成本。</p>
<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>移动端热修复的痛点主要有以下几个：</p>
<p>1.上架问题: 如果被商店查到使用此功能可能会面临被拒风险。</p>
<p>2.安全风险：热修复可能会导致应用程序的安全风险，因为攻击者可能会篡改热修复包，导致应用程序崩溃或泄露敏感信息。</p>
<p>3.兼容性问题：热修复可能会引起应用程序的兼容性问题，因为新的代码可能与旧的代码不兼容，导致应用程序崩溃或异常。</p>
<p>4.调试困难：热修复的代码通常比较难以调试，因为它是动态加载的，不容易在开发环境中调试。</p>
<p>5。性能问题：热修复可能会导致应用程序的性能问题，因为它需要动态加载代码，这可能会导致应用程序响应速度变慢或者增加内存占用。</p>
<p>6.维护存在一定成本：热修复需要额外的维护成本，因为需要开发额外的代码和测试热修复的效果。</p>
<p>因此，在使用移动端热修复技术时，需要仔细权衡各种利弊，并采取相应的安全措施来确保应用程序的安全性。同时，开发人员需要充分考虑兼容性问题和性能问题，并进行充分的测试和调试工作。</p>
<h2 id="业界方案"><a href="#业界方案" class="headerlink" title="业界方案"></a>业界方案</h2><h3 id="jspatch-目前不能上架"><a href="#jspatch-目前不能上架" class="headerlink" title="jspatch 目前不能上架"></a>jspatch 目前不能上架</h3><p>JSPatch 是一个用于 iOS 应用的热修复框架，它允许开发者在不重新发布应用的情况下修复线上的 Bug 或者添加新功能。JSPatch 的原理可以简单概括如下：</p>
<ol>
<li><p>JSPatch 的运行环境是 JavaScriptCore，它是苹果提供的 JavaScript 引擎，可以在 iOS 应用中执行 JavaScript 代码。</p>
</li>
<li><p>在应用启动时，JSPatch 将下载的 JavaScript 脚本注入到 JavaScriptCore 中，并创建一个全局的 JavaScript 上下文。</p>
</li>
<li><p>JSPatch 使用 JavaScriptCore 提供的 Objective-C 与 JavaScript 交互的 API。开发者可以通过这些 API 将 Objective-C 对象和方法暴露给 JavaScript，从而实现在 JavaScript 中调用原生的 Objective-C 方法。</p>
</li>
<li><p>JavaScript 脚本中的代码可以直接访问应用中的 Objective-C 对象和方法，以及修改和执行这些对象和方法。</p>
</li>
<li><p>当开发者需要修复 Bug 或者添加新功能时，他们可以在 JavaScript 脚本中编写相应的逻辑。然后将这个脚本发布到服务器，并通知应用更新。</p>
</li>
<li><p>应用在后台通过网络请求下载最新的 JavaScript 脚本，并将其注入到 JavaScriptCore 中。</p>
</li>
<li><p>下次应用启动时，注入的新 JavaScript 脚本将生效，并可以执行修复 Bug 或者添加新功能的逻辑。</p>
</li>
</ol>
<p>总的来说，JSPatch 的原理是通过将 JavaScript 脚本注入到 iOS 应用中的 JavaScriptCore 中，实现在运行时修复 Bug 或者添加新功能。开发者可以通过 JavaScript 代码访问和修改应用中的 Objective-C 对象和方法，从而实现动态修复和扩展应用的能力。</p>
<h3 id="Ocrunner"><a href="#Ocrunner" class="headerlink" title="Ocrunner"></a>Ocrunner</h3><p>是基于 mangofix做了优化，支持直接使用oc语法做脚本，原理和mangofix 一样</p>
<h3 id="mangofix"><a href="#mangofix" class="headerlink" title="mangofix"></a>mangofix</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbeff23ce5df43db8a2c6e6facb8ed7d~tplv-k3u1fbpfcp-watermark.image" alt="1709476-16c9960a772355e4.webp"></p>
<h2 id="Mango源码分析"><a href="#Mango源码分析" class="headerlink" title="Mango源码分析"></a>Mango源码分析</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28c270ef23144fef90020a7dd228f4dc~tplv-k3u1fbpfcp-watermark.image" alt="&amp; MangoFixDemo.png"></p>
<p>主要有 Compiler , Execute，libffi，symdl 这几个核心模块组成</p>
<h4 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h4><p>主要  yacc 词法，语法解析器，内置对象映射表，AST 解析后的内置对象相关的model类组成。</p>
<h4 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h4><p>主要来承接yacc 处理后的后续操作，把对脚本解析后转换成相应的内置对象。 </p>
<p>包含 MFContext执行的上下文 它用来执行整个热修复的 脚本初始化，加密，解密执行，以及解析入口等。</p>
<p> MangoFix脚本中很多功能都是通过预先创建内置对象的方式支持的，比如常用结构体的声明、变量、宏、C函数和GCD相关的操作等，如果想详细了解MangoFix中有哪些内置对象，当然MangoFix也开放了相关接口，你也可以向MangoFix执行上下文中注入你需要的对象。</p>
<h4 id="libffi"><a href="#libffi" class="headerlink" title="libffi"></a>libffi</h4><p>主要用来动态的执行某些函数方法。</p>
<blockquote>
<p> libffi（The Foreign Function Interface library）是一个开源的软件库，它提供了一种通用的编程接口，用于调用不同编程语言之间的函数。它允许在运行时动态地调用和执行函数，而无需在编译时提前知道函数的签名或参数类型。</p>
<p>libffi的设计目标是为不同的编程语言提供一个统一的接口，使它们能够相互调用。它为许多常见的编程语言，如C、C++、Python、Ruby等提供了支持，并可以方便地扩展到其他语言。</p>
<p>libffi的核心功能是动态地生成机器码来调用函数，这使得在运行时可以根据需要解析函数的签名、分配内存、处理参数传递和返回值等操作。它提供了一个高度灵活和可移植的接口，使得开发者可以轻松地在不同的编程环境中进行函数调用。</p>
<p>libffi的主要用途之一是在解释型语言中实现对外部库的调用。通过使用libffi，解释型语言的开发者可以方便地扩展语言的功能，调用本地代码库或其他语言编写的函数。它还可以用于实现动态链接，通过在运行时加载和执行共享库中的函数。</p>
<p>总的来说，libffi是一个非常有用的库，它提供了一种通用的方式来调用不同编程语言之间的函数，为开发者提供了更大的灵活性和互操作性。无论你是开发解释型语言、扩展其他编程语言功能，还是需要实现动态链接，libffi都是一个值得考虑的选择。</p>
</blockquote>
<p>symdl是一个简单的小工具，它的功能与dlsym非常相似，使用symdl，可以传入动态链接的C函数名字符串，获取函数指针，从而实现对C函数的动态调用。</p>
<h3 id="下面来看源码执行流程"><a href="#下面来看源码执行流程" class="headerlink" title="下面来看源码执行流程"></a>下面来看源码执行流程</h3><p>首先来看下mango 脚本格式</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eb9840ad7d344a79d541b779fcdbe54~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>关于脚本语法可以去相应地址查看</p>
<p><a target="_blank" rel="noopener" href="https://github.com/YPLiang19/Mango">https://github.com/YPLiang19/Mango</a></p>
<p><strong>注意事项</strong></p>
<p>一般来说在脚本是需要加密解密的，因为如果被别人动态的修改，可能会对app造成一定的影响。</p>
<h4 id="1-对脚本进行ASE加密，此步骤一般最后会上传到服务器，通过服务器下发。"><a href="#1-对脚本进行ASE加密，此步骤一般最后会上传到服务器，通过服务器下发。" class="headerlink" title="1.对脚本进行ASE加密，此步骤一般最后会上传到服务器，通过服务器下发。"></a>1.对脚本进行ASE加密，此步骤一般最后会上传到服务器，通过服务器下发。</h4><figure class="highlight plaintext"><figcaption><span>(BOOL)encryptPlainScirptToDocument &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    NSError *outErr = nil;</span><br><span class="line"></span><br><span class="line">    BOOL writeResult = NO;</span><br><span class="line"></span><br><span class="line">    NSURL *scriptUrl = [[NSBundle mainBundle] URLForResource:@&quot;demo&quot; withExtension:@&quot;mg&quot;];</span><br><span class="line"></span><br><span class="line">    NSString *plainScriptString = [NSString stringWithContentsOfURL:scriptUrl encoding:NSUTF8StringEncoding error:&amp;outErr];</span><br><span class="line"></span><br><span class="line">    if (outErr) goto err;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        NSData *scriptData = [plainScriptString dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">        NSData *encryptedScriptData = [scriptData AES128ParmEncryptWithKey:aes128Key iv:aes128Iv];</span><br><span class="line"></span><br><span class="line">        NSString * encryptedPath= [(NSString *)[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] stringByAppendingPathComponent:@&quot;demo_encrypted.mg&quot;];</span><br><span class="line"></span><br><span class="line">        NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">        if (![fileManager fileExistsAtPath:encryptedPath]) &#123;</span><br><span class="line"></span><br><span class="line">            [fileManager createFileAtPath:encryptedPath contents:nil attributes:nil];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writeResult = [encryptedScriptData writeToFile:encryptedPath options:NSDataWritingAtomic error:&amp;outErr];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line"></span><br><span class="line">    if (outErr) NSLog(@&quot;%@&quot;,outErr);</span><br><span class="line"></span><br><span class="line">    return writeResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-context-初始化解密脚本，执行整个流程"><a href="#2-context-初始化解密脚本，执行整个流程" class="headerlink" title="2.context 初始化解密脚本，执行整个流程"></a>2.context 初始化解密脚本，执行整个流程</h4><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;

    BOOL writeResult = [self encryptPlainScirptToDocument];

    if (!writeResult) &#123;

        return NO;

    &#125;

    MFContext *context = [[MFContext alloc] initWithAES128Key:aes128Key iv:aes128Iv];

    NSString * encryptedPath= [(NSString *)[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] stringByAppendingPathComponent:@&quot;demo_encrypted.mg&quot;];

    [NSURL URLWithString:@&quot;&quot;];

    NSURL *scriptUrl = [NSURL fileURLWithPath:encryptedPath];

    [context evalMangoScriptWithURL:scriptUrl];

return YES;

&#125;
</code></pre>
<p>evalMangoScriptWithAES128Data是解密并执行的核心方法。</p>
<pre><code>- (void)evalMangoScriptWithURL:(NSURL *)url&#123;

    @autoreleasepool &#123;

        NSError *error;

        NSData *encryptedData = [NSData dataWithContentsOfURL:url];

        if (error) &#123;

            NSLog(@&quot;[MangoFix] [ERROR] : %@&quot;,error);

            return;

        &#125;

        [self evalMangoScriptWithAES128Data:encryptedData];

    &#125;
&#125;


- (void)evalMangoScriptWithAES128Data:(NSData *)scriptData &#123;

    @autoreleasepool &#123;

        NSData *mangoFixData = [scriptData AES128ParmDecryptWithKey:_key iv:_iv];

        NSString *mangoFixString = [[NSString alloc] initWithData:mangoFixData encoding:NSUTF8StringEncoding];

        if (!mangoFixString.length) &#123;

            NSLog(@&quot;[MangoFix] [ERROR] : AES128(ECBMode) decrypt error!&quot;);

            return;

        &#125;

        mf_set_current_compile_util(self.interpreter);

        mf_add_built_in(self.interpreter);

        [self.interpreter compileSourceWithString:mangoFixString];

        mf_set_current_compile_util(nil);

        mf_interpret(self.interpreter);

    &#125;

&#125;
</code></pre>
<h5 id="几个核心步骤"><a href="#几个核心步骤" class="headerlink" title="几个核心步骤"></a>几个核心步骤</h5><ul>
<li>mf_set_current_compile_util(self.interpreter);</li>
<li>mf_add_built_in(self.interpreter);</li>
<li>[self.interpreter compileSourceWithString:mangoFixString];</li>
<li>mf_set_current_compile_util(nil);</li>
<li>mf_interpret(self.interpreter);</li>
</ul>
<h5 id="1-mf-set-current-compile-util"><a href="#1-mf-set-current-compile-util" class="headerlink" title="1.mf_set_current_compile_util"></a>1.mf_set_current_compile_util</h5><p>会创建一个解析对象，通过 mf_set_current_compile_util 设置在对于线程里，推测是为了后续获取访问。</p>
<h5 id="2-mf-add-built-in"><a href="#2-mf-add-built-in" class="headerlink" title="2.mf_add_built_in"></a>2.mf_add_built_in</h5><p>这段代码是为了向MFInterpreter对象添加内置功能，包括 结构体，方法，变量，gcd相关等。通过使用dispatch_once函数，这些内置操作只会在第一次调用mf_add_built_in函数时执行一次，确保添加内置功能的唯一性和线程安全性。</p>
<pre><code>void mf_add_built_in(MFInterpreter *inter)&#123;

    static dispatch_once_t onceToken;

    dispatch_once(&amp;onceToken, ^&#123;

    add_built_in_struct_declare();

    add_build_in_function(inter);

    add_build_in_var(inter);

    add_gcd_build_in(inter);

    &#125;);
&#125;
</code></pre>
<h5 id="3-compileSourceWithString-接下来开始进行相关解析工作"><a href="#3-compileSourceWithString-接下来开始进行相关解析工作" class="headerlink" title="3.compileSourceWithString 接下来开始进行相关解析工作"></a>3.compileSourceWithString 接下来开始进行相关解析工作</h5><pre><code>- (void)compileSourceWithString:(NSString *)source&#123;

    extern void mf_set_source_string(char const *source);

    mf_set_source_string([source UTF8String]);

    extern void yyrestart  (FILE * input_file );

    extern int yyparse(void);

        yyrestart(NULL); /* 每次解析前，重置yylex */

    if (yyparse()) &#123;

    return;

    &#125;
&#125;
</code></pre>
<h5 id="4-mf-set-source-string"><a href="#4-mf-set-source-string" class="headerlink" title="4.mf_set_source_string"></a>4.mf_set_source_string</h5><p>是yacc + lex 的解析入口</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61ef21479d6e4f1089d48f04ca4cd06b~tplv-k3u1fbpfcp-watermark.image" alt="wunder YY INPUT.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0d39c4c2c17411eb61b0832e8bac10f~tplv-k3u1fbpfcp-watermark.image" alt="AST.png"></p>
<h5 id="5-经过了lex和-yacc-的处理后然后把内容放到了一个容器对象中，拿mf-add-class-definition来分析"><a href="#5-经过了lex和-yacc-的处理后然后把内容放到了一个容器对象中，拿mf-add-class-definition来分析" class="headerlink" title="5.经过了lex和 yacc 的处理后然后把内容放到了一个容器对象中，拿mf_add_class_definition来分析"></a>5.经过了lex和 yacc 的处理后然后把内容放到了一个容器对象中，拿mf_add_class_definition来分析</h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d4efc8667164905b8057a1ac5ef8a3e~tplv-k3u1fbpfcp-watermark.image" alt="Jerinlelen Jist definition.png"></p>
<h5 id="6-最终保存到了-topList-数组中"><a href="#6-最终保存到了-topList-数组中" class="headerlink" title="6.最终保存到了  topList 数组中"></a>6.最终保存到了  topList 数组中</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void mf_add_class_definition(MFClassDefinition *classDefinition)&#123;</span><br><span class="line"></span><br><span class="line">MFInterpreter *interpreter = mf_get_current_compile_util();</span><br><span class="line"></span><br><span class="line">interpreter.classDefinitionDic[classDefinition.name] = classDefinition;</span><br><span class="line"></span><br><span class="line">[interpreter.topList addObject:classDefinition];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-mf-interpret"><a href="#7-mf-interpret" class="headerlink" title="7.mf_interpret"></a>7.mf_interpret</h5><p>最终通过 mf_interpret 遍历 topList 中的对象，通过runtime执行相应的操作，如动态添加方法 属性，交换方法等。最终通过 fix_class函数执行完整个流程，后续在程序动态执行的时候 会调用事先交换处理好的方法等。</p>
<pre><code>void mf_interpret(MFInterpreter *interpreter)&#123;

    for (__kindof NSObject *top in interpreter.topList) &#123;

        if ([top isKindOfClass:[MFStatement class]]) &#123;

            execute_statement(interpreter, interpreter.topScope, top);

        &#125;else if ([top isKindOfClass:[MFStructDeclare class]])&#123;

            add_struct_declare(interpreter,top);

        &#125;else if ([top isKindOfClass:[MFClassDefinition class]])&#123;

            define_class(interpreter, top);

        fix_class(interpreter,top);

        &#125;

    &#125;

&#125;
</code></pre>
<p>看几个关键 代码 </p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0a53c29e939425abb1eeda2402cadce~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5dea8873ee64d538b19288cd21a705f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="关于性能："><a href="#关于性能：" class="headerlink" title="关于性能："></a>关于性能：</h4><p>关于性能，我没有详细分析过，但是之前看到过一篇文章，对三种方案做过性能对比如下</p>
<blockquote>
<p>性能:</p>
<p>设备: iPhone SE 2，iOS 14.3</p>
<p>在求斐波那契数列第25项的测试中:</p>
<ul>
<li><strong>JSPatch</strong>: 执行时间，平均为 0.169 s。内存占用一直稳定在 12 MB 左右。</li>
<li><strong>OCRunner</strong>: 执行时间，平均为 1.05 s。内存占用，峰值为 60 MB 左右，其他稳定在 12 MB 左右。</li>
<li><strong>Mango</strong>: 执行时间，平均时间为 2.38 s。内存占用，持续走高，最高的时候大约为 350 MB。</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我这里初衷也是对mangofix 使用流程和源码做一下简单的分析，对于最后的选择当然还要根据自身需求场景 和业务来决定是否使用哪一种，当然无论那种方案都是有一定风险的，希望能对大家有一定帮助。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/16/JavaScript%E5%B0%8F%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/16/JavaScript%E5%B0%8F%E8%BF%B0/" class="post-title-link" itemprop="url">JavaScript小述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-16 23:15:28" itemprop="dateCreated datePublished" datetime="2023-05-16T23:15:28+08:00">2023-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/530863c531c84cd1a92292cc1a935a09~tplv-k3u1fbpfcp-watermark.image" alt="v2-12c146306d8e78ebced2ad925bda57e5_1440w.jpg"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在学习前端相关知识，就做了下知识梳理方便后续回顾，同时也分享给大家，那么为什么要学习前端呢？主要有以下几点：</p>
<ol>
<li><p>Web 开发：随着移动互联网的发展，Web 应用已经成为了移动应用开发的重要组成部分。通过学习 JavaScript，iOS 开发人员可以更好地理解和应用 Web 技术，如 HTML、CSS 和 Ajax 等，从而更好地开发移动应用。</p>
</li>
<li><p>前端开发：JavaScript 是前端开发中不可或缺的一部分，掌握 JavaScript 可以帮助 iOS 开发人员更好地进行前端开发，从而实现更好的用户交互和体验。</p>
</li>
<li><p>混合开发：混合开发是一种将 Web 技术和原生技术结合起来开发应用程序的方法。通过学习 JavaScript，iOS 开发人员可以更好地理解和应用混合开发技术，从而实现更快速的应用开发和更好的用户体验。</p>
</li>
<li><p>与服务端交互：JavaScript 在 Web 应用中广泛应用于与服务端交互，如使用 Ajax 进行数据交互等。通过学习 JavaScript，iOS 开发人员可以更好地理解和应用服务端和客户端的交互，从而实现更高效的数据交互和应用开发。</p>
</li>
</ol>
<p>总的来说，学习 JavaScript 可以帮助 iOS 开发人员更好地掌握 Web 技术和前端开发，同时也可以更好地应用混合开发技术，从而提高应用程序的用户体验和开发效率，<strong>当然多学一门技术多碗饭也是不错的</strong>。</p>
<h2 id="JS知识梳理"><a href="#JS知识梳理" class="headerlink" title="JS知识梳理"></a>JS知识梳理</h2><h2 id="一-JS执行上下文"><a href="#一-JS执行上下文" class="headerlink" title="一.JS执行上下文"></a>一.JS执行上下文</h2><p>JavaScript执行上下文（execution context）是JavaScript代码在运行时的环境，它包含了代码执行所需的所有信息。当JavaScript代码在运行时，会创建一个执行上下文，并且在代码执行完毕后，这个执行上下文会被销毁。每次JavaScript代码执行，都会创建一个新的执行上下文。</p>
<p>JavaScript的执行上下文主要有三种类型：</p>
<ol>
<li><p>全局执行上下文（Global Execution Context）：它是整个JavaScript代码的默认执行上下文，所有在函数外部定义的变量和函数都属于全局执行上下文。当JavaScript代码开始运行时，就会创建全局执行上下文。</p>
</li>
<li><p>函数执行上下文（Function Execution Context）：每当一个函数被调用时，就会创建一个函数执行上下文。函数执行上下文与函数一一对应，它保存了函数内部的变量、函数参数、函数声明等信息。</p>
</li>
<li><p>Eval执行上下文（Eval Execution Context）：当JavaScript代码中使用eval()函数时，就会创建一个Eval执行上下文。Eval执行上下文可以动态生成JavaScript代码，并且在运行时创建。Eval执行上下文可以访问外部执行上下文中的变量和函数。</p>
</li>
</ol>
<p>JavaScript执行上下文是一个非常重要的概念，理解执行上下文可以帮助我们更好地理解JavaScript代码的执行过程。在JavaScript中，变量的作用域、函数的调用、this关键字等都与执行上下文相关。</p>
<h2 id="二-JS的作用域链"><a href="#二-JS的作用域链" class="headerlink" title="二.JS的作用域链"></a>二.JS的作用域链</h2><p>JavaScript 作用域链（Scope Chain）是指在 JavaScript 中变量和函数的访问规则。当在 JavaScript 中引用一个变量时，JavaScript 引擎会首先在当前作用域内查找该变量，如果找不到，则会向上层作用域中查找，直到找到该变量或查找到全局作用域为止。这些作用域的链式关系就是作用域链。</p>
<p>JavaScript 中的作用域链是由作用域嵌套关系和函数定义时的词法环境决定的。每当 JavaScript 引擎进入一个新的作用域时，就会创建一个新的词法环境对象，该对象会保存该作用域中定义的变量和函数，同时它还包含了一个指向外部词法环境的引用，这个引用就构成了作用域链。</p>
<p>作用域链的顶部是全局作用域，底部是当前执行上下文所在的作用域，作用域链的查找顺序是由底向上依次查找，直到找到目标变量或函数为止。如果在全局作用域中也找不到该变量或函数，则会抛出一个引用错误（ReferenceError）。</p>
<p>例如，下面的代码演示了作用域链的查找过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">  let b = 2;</span><br><span class="line"></span><br><span class="line">  function bar() &#123;</span><br><span class="line"></span><br><span class="line">    let c = 3;</span><br><span class="line"></span><br><span class="line">    console.log(a + b + c);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // 输出 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在上面的代码中，变量 <code>a</code>、<code>b</code> 和 <code>c</code> 分别定义在不同的作用域中，变量 <code>c</code> 可以在函数 <code>bar()</code> 中直接访问，变量 <code>b</code> 和 <code>a</code> 都不在当前作用域内，因此 JavaScript 引擎会依次向上查找作用域链，找到了变量 <code>b</code> 和 <code>a</code>，并将它们的值相加输出。</p>
<p>JavaScript 中有两种作用域，分别是全局作用域和函数作用域。在 ES6 中新增了块级作用域（使用 let 和 const 声明的变量），它们的作用域是从变量声明位置到块级作用域结束位置。</p>
<h2 id="三-JavaScript-中的闭包-和应用场景"><a href="#三-JavaScript-中的闭包-和应用场景" class="headerlink" title="三.JavaScript 中的闭包 和应用场景"></a>三.JavaScript 中的闭包 和应用场景</h2><p>JavaScript 中的闭包是指在函数中创建的一个局部作用域，该作用域中的变量在函数执行完成后仍然可以被访问和使用。简单来说，闭包就是一个函数和它所在的环境的组合。</p>
<p>具体来说，当一个函数内部定义了另一个函数，并且这个内部函数引用了外部函数的变量时，就形成了闭包。由于 JavaScript 的函数作用域和词法作用域规则，外部函数的变量在内部函数中仍然可以访问，而且在内部函数执行完成后，这些变量不会被自动清理，而是继续保存在内存中，供后续调用使用，从而形成了闭包。</p>
<p>JavaScript 中闭包的应用场景非常广泛，常见的应用场景包括：</p>
<ol>
<li><p>封装变量和函数：使用闭包可以封装变量和函数，避免全局变量的污染，同时也可以保护变量和函数不被外部直接访问和修改。</p>
</li>
<li><p>延迟执行和异步回调：使用闭包可以延迟执行函数，同时也可以在异步回调中访问外部变量和函数。</p>
</li>
<li><p>模块化编程：使用闭包可以实现模块化编程，将变量和函数封装在闭包中，避免与其他模块的变量和函数产生冲突，同时也可以更好地保护模块的私有性。</p>
</li>
<li><p>事件处理程序：使用闭包可以实现事件处理程序，使得在事件发生时可以访问外部变量和函数。</p>
</li>
</ol>
<p>需要注意的是，闭包虽然能够解决很多问题，但同时也存在着潜在的内存泄漏问题，如果闭包中保存了过多的变量和函数引用，可能会导致内存占用过多，从而影响性能。因此在使用闭包时，需要注意内存管理和性能优化。</p>
<h2 id="四-JS-的this-关键字"><a href="#四-JS-的this-关键字" class="headerlink" title="四.JS 的this 关键字"></a>四.JS 的this 关键字</h2><p>JavaScript 中的 this 关键字用于指代当前函数执行上下文中的对象。在不同的函数执行上下文中，this 可能指向不同的对象，它的具体取值取决于函数的调用方式和执行环境。下面介绍几种常见的 this 指向方式：</p>
<ol>
<li><p>全局对象：在全局执行上下文中，this 指向全局对象，在浏览器中通常是 window 对象。</p>
</li>
<li><p>函数调用：在普通函数中，this 指向调用该函数的对象。如果函数是直接作为函数调用，this 就指向全局对象或 undefined（严格模式下），如果函数作为对象的方法调用，this 就指向该对象本身。</p>
</li>
<li><p>构造函数：在使用 new 操作符创建对象时，this 指向新创建的对象。</p>
</li>
<li><p>apply 和 call：在使用函数的 apply 或 call 方法调用函数时，可以手动指定函数执行时的 this 对象。</p>
</li>
<li><p>箭头函数：在箭头函数中，this 指向函数定义时的外层作用域的 this 值，而不是调用该函数时的对象。</p>
</li>
</ol>
<p>需要注意的是，this 的取值是动态的，并且可以通过一些技巧来改变其指向。例如使用 call 和 apply 方法手动指定 this 值，或者使用 bind 方法创建一个新的函数并指定其 this 值。此外，在 ES6 中新增的箭头函数也可以解决一些 this 指向问题。但在编写代码时，应该尽量避免过多地改变 this 的指向，以保持代码的可读性和维护性。</p>
<h2 id="五-如何改变this指向"><a href="#五-如何改变this指向" class="headerlink" title="五.如何改变this指向"></a>五.如何改变this指向</h2><p>在 JavaScript 中，有多种方式可以改变函数执行时的 this 指向。以下是一些常见的方式：</p>
<ol>
<li><p>使用 call 和 apply 方法：这两个方法都可以手动指定函数执行时的 this 对象。它们的区别在于传递参数的方式不同，call 方法是将参数按照顺序传递，而 apply 方法是将参数打包成数组传递。</p>
</li>
<li><p>使用 bind 方法：bind 方法可以创建一个新函数，将原函数的 this 绑定到指定对象，并返回新函数。新函数的 this 值将始终指向绑定的对象，不会被其他方式改变。</p>
</li>
<li><p>使用箭头函数：在箭头函数中，this 始终指向函数定义时的外层作用域的 this 值，而不是调用该函数时的对象。因此，可以使用箭头函数来避免 this 指向问题。</p>
</li>
</ol>
<p>下面是一个使用 call 和 bind 方法改变 this 指向的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 定义一个对象</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;John&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个函数，打印当前对象的 name 属性</span><br><span class="line"></span><br><span class="line">function printName() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(this.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用 call 方法改变函数执行时的 this 指向</span><br><span class="line"></span><br><span class="line">printName.call(obj); // 输出 &quot;John&quot;</span><br><span class="line"></span><br><span class="line">// 使用 bind 方法创建一个新函数，并指定 this 指向为 obj</span><br><span class="line"></span><br><span class="line">var boundFunc = printName.bind(obj);</span><br><span class="line"></span><br><span class="line">// 调用新函数，输出 &quot;John&quot;</span><br><span class="line"></span><br><span class="line">boundFunc();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，改变 this 指向可能会影响函数的执行结果和副作用，因此在使用这些方法时需要谨慎考虑，并且遵循 JavaScript 的最佳实践。</p>
<h2 id="六-call-和-apply-区别"><a href="#六-call-和-apply-区别" class="headerlink" title="六.call 和 apply 区别"></a>六.call 和 apply 区别</h2><p><code>call</code> 和 <code>apply</code> 都是 JavaScript 中的函数方法，它们都可以用来改变函数执行时的 this 指向，并且都可以接受任意数量的参数。</p>
<p>它们的区别在于传递参数的方式不同：</p>
<ul>
<li><p><code>call</code> 方法：第一个参数是要绑定给 this 的对象，后面的参数是要传递给函数的参数列表，可以是任意数量的参数，按照顺序一个一个传递。</p>
</li>
<li><p><code>apply</code> 方法：第一个参数是要绑定给 this 的对象，第二个参数是要传递给函数的参数列表，必须是一个数组或类数组对象。</p>
</li>
</ul>
<p>因此，如果我们有一个数组或类数组对象，可以使用 <code>apply</code> 方法来将它们作为参数传递给函数。</p>
<p>下面是一个使用 <code>call</code> 和 <code>apply</code> 方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function greet(name, age) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(`Hello, $&#123;name&#125;! You are $&#123;age&#125; years old.`);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line"></span><br><span class="line">  age: 30</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用 call 方法调用 greet 函数，并指定 this 指向为 person</span><br><span class="line"></span><br><span class="line">greet.call(person, person.name, person.age); // 输出 &quot;Hello, John! You are 30 years old.&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用 apply 方法调用 greet 函数，并指定 this 指向为 person</span><br><span class="line"></span><br><span class="line">greet.apply(person, [person.name, person.age]); // 输出 &quot;Hello, John! You are 30 years old.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>call</code> 和 <code>apply</code> 方法都会立即调用函数，并改变函数执行时的 this 指向。如果只是想创建一个新的函数并绑定 this，可以使用 <code>bind</code> 方法。</p>
<h2 id="七-如何实现一个bind"><a href="#七-如何实现一个bind" class="headerlink" title="七.如何实现一个bind"></a>七.如何实现一个bind</h2><p>实现一个 <code>bind</code> 方法可以参考下面的步骤：</p>
<ol>
<li><p>判断调用 <code>bind</code> 方法的对象是否为函数，如果不是函数，抛出错误。</p>
</li>
<li><p>获取调用 <code>bind</code> 方法的对象和调用 <code>bind</code> 方法时传递的参数，并保存到变量中。</p>
</li>
<li><p>返回一个新函数，该函数的 this 指向为调用 <code>bind</code> 方法时传递的对象，参数列表为调用 <code>bind</code> 方法时传递的参数和调用新函数时传递的参数。</p>
</li>
<li><p>在新函数中调用原函数，并传递合并后的参数列表。</p>
</li>
</ol>
<p>下面是一个简单的 <code>bind</code> 方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Function.prototype.bind2 = function(obj, ...args1) &#123;</span><br><span class="line"></span><br><span class="line">  // 判断调用 bind 方法的对象是否为函数</span><br><span class="line"></span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    throw new TypeError(&quot;Function.prototype.bind - called on non-function&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 保存调用 bind 方法时传递的参数</span><br><span class="line"></span><br><span class="line">  const self = this;</span><br><span class="line"></span><br><span class="line">  const args2 = arguments;</span><br><span class="line"></span><br><span class="line">  // 返回一个新函数</span><br><span class="line"></span><br><span class="line">  return function(...args3) &#123;</span><br><span class="line"></span><br><span class="line">    // 合并调用 bind 方法时传递的参数和调用新函数时传递的参数</span><br><span class="line"></span><br><span class="line">    const args = [...args1, ...args3];</span><br><span class="line"></span><br><span class="line">    // 在新函数中调用原函数，并传递合并后的参数列表</span><br><span class="line"></span><br><span class="line">    return self.apply(obj, args);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function greet(name, age) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(`Hello, $&#123;name&#125;! You are $&#123;age&#125; years old.`);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line"></span><br><span class="line">  age: 30</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用自定义的 bind2 方法创建一个新函数</span><br><span class="line"></span><br><span class="line">var boundFunc = greet.bind2(person, person.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 调用新函数</span><br><span class="line"></span><br><span class="line">boundFunc(person.age); // 输出 &quot;Hello, John! You are 30 years old.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，以上仅是一个简单的 <code>bind</code> 方法实现，与原生的 <code>bind</code> 方法可能存在差异，并且在实际开发中不建议覆盖原生方法。</p>
<h2 id="八-JS的原型链"><a href="#八-JS的原型链" class="headerlink" title="八.JS的原型链"></a>八.JS的原型链</h2><p>JavaScript 中的原型链是用来描述对象之间继承关系的机制，它是由对象的原型构成的链式结构。每个对象都有一个原型（<code>prototype</code>）属性，指向它所继承的对象，如果该对象也有原型，则继续往上层原型查找，直到找到顶层原型为止。</p>
<p>在原型链中，一个对象可以访问它所继承的原型对象的属性和方法，这样就可以实现属性和方法的共享和重用。</p>
<p>例如，如果我们创建一个对象 <code>obj</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line"></span><br><span class="line">  age: 30</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么它的原型就是 <code>Object.prototype</code>，可以通过 <code>Object.getPrototypeOf(obj)</code> 方法来获取。</p>
<p>在原型链中，如果一个对象的原型是另一个对象，那么它就可以访问另一个对象的属性和方法。例如，如果我们创建一个函数 <code>Foo</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.sayHello = function() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么它的原型就是 <code>Object.prototype</code>，可以通过 <code>Object.getPrototypeOf(Foo.prototype)</code> 方法来获取。</p>
<p>如果我们创建一个对象 <code>obj</code>，并将 <code>Foo</code> 函数的实例作为它的原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj = Object.create(new Foo());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么它的原型就是 <code>Foo.prototype</code>，而 <code>Foo.prototype</code> 的原型又是 <code>Object.prototype</code>，可以通过 <code>Object.getPrototypeOf(Object.getPrototypeOf(obj))</code> 方法来获取。</p>
<p>因此，如果我们调用 <code>obj.sayHello()</code> 方法，它会先在 <code>obj</code> 对象中查找 <code>sayHello</code> 方法，如果找不到，就会去 <code>Foo.prototype</code> 对象中查找，如果还找不到，就会继续往上查找，直到找到顶层原型为止。</p>
<p>这就是 JavaScript 中原型链的基本工作原理，它是 JavaScript 实现继承的核心机制之一。</p>
<h2 id="九-如何利用原型链实现继承"><a href="#九-如何利用原型链实现继承" class="headerlink" title="九.如何利用原型链实现继承"></a>九.如何利用原型链实现继承</h2><p>在 JavaScript 中，继承可以通过原型链来实现。每个对象都有一个原型链，原型链指向了它的父对象。子对象可以通过原型链继承其父对象的属性和方法。</p>
<p>要实现继承，可以定义一个构造函数，并在其原型上定义方法和属性，然后通过子构造函数的原型指向父构造函数的实例，从而实现继承。下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义父构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在父构造函数的原型上定义方法</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子构造函数的原型指向父构造函数的实例</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子构造函数的原型上定义方法</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Dog 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Rover&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用从父对象继承的方法</span></span><br><span class="line"></span><br><span class="line">myDog.<span class="title function_">sayName</span>(); <span class="comment">// 输出 &quot;My name is Rover&quot;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用子对象的方法</span></span><br><span class="line"></span><br><span class="line">myDog.<span class="title function_">bark</span>(); <span class="comment">// 输出 &quot;Woof!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在上面的示例中，我们首先定义了一个父构造函数 <code>Animal</code>，并在其原型上定义了一个方法 <code>sayName</code>。然后我们定义了一个子构造函数 <code>Dog</code>，并通过 <code>Object.create</code> 方法将其原型指向了 <code>Animal</code> 构造函数的实例，从而实现了继承。最后，我们在子构造函数的原型上定义了一个新的方法 <code>bark</code>。</p>
<p>通过原型链实现继承的好处是可以节省内存，因为所有子对象共享同一个父对象的方法和属性。但需要注意的是，当父对象的属性值发生变化时，所有子对象都会受到影响，因为它们共享同一个原型对象。</p>
<h2 id="十-promise是什么"><a href="#十-promise是什么" class="headerlink" title="十.promise是什么"></a>十.promise是什么</h2><p>在 JavaScript 中，Promise 是一种用于处理异步操作的对象，它代表了一个可能尚未完成并且最终将产生结果的操作。</p>
<p>Promise 对象有三种状态：等待中（pending）、已完成（fulfilled）和已拒绝（rejected）。当一个 Promise 被创建时，它处于等待中状态。当操作完成时，Promise 会变为已完成状态或已拒绝状态。</p>
<p>Promise 对象有两个重要的方法：<code>then</code> 和 <code>catch</code>。当 Promise 被解决时（即从等待中状态转变为已完成状态或已拒绝状态时），<code>then</code> 方法会被调用，它接收一个回调函数，该回调函数接收 Promise 对象产生的结果或错误作为参数。如果 Promise 对象被解决为已拒绝状态，则 <code>catch</code> 方法会被调用，它也接收一个回调函数，该回调函数接收 Promise 对象产生的错误作为参数。</p>
<p>Promise 的主要优点在于它们可以减少回调函数的嵌套，使代码更易于理解和维护。它们也可以帮助处理异步代码中的错误，因为错误可以通过 <code>catch</code> 方法来处理。</p>
<p>下面是一个使用 Promise 的示例，它模拟了一个异步操作，该操作返回一个随机数并将其打印到控制台上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateRandomNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> randomNumber = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (randomNumber &lt; <span class="number">5</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;Failed to generate random number.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">resolve</span>(randomNumber);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">generateRandomNumber</span>()</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Random number generated successfully:&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error generating random number:&quot;</span>, error);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个 Promise 对象，该对象包含一个异步操作。在异步操作完成时，Promise 对象将返回一个随机数或错误。我们使用 <code>then</code> 方法来处理操作成功的情况，并使用 <code>catch</code> 方法来处理操作失败的情况。如果操作成功，我们将随机数打印到控制台上；如果操作失败，我们将错误打印到控制台上。</p>
<h2 id="十一-如何实现一个promise"><a href="#十一-如何实现一个promise" class="headerlink" title="十一.如何实现一个promise"></a>十一.如何实现一个promise</h2><p>要实现一个简单的 Promise，需要定义一个构造函数，并在其原型上定义 <code>then</code> 和 <code>catch</code> 方法。下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> handlers = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line"></span><br><span class="line">    state = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"></span><br><span class="line">    value = result;</span><br><span class="line"></span><br><span class="line">    handlers.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">handler</span>) &#123;</span><br><span class="line"></span><br><span class="line">      handler.<span class="title function_">onFulfilled</span>(result);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    state = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line">    value = error;</span><br><span class="line"></span><br><span class="line">    handlers.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">handler</span>) &#123;</span><br><span class="line"></span><br><span class="line">      handler.<span class="title function_">onRejected</span>(error);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = <span class="title function_">onFulfilled</span>(value);</span><br><span class="line"></span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">reject</span>(error);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = <span class="title function_">onRejected</span>(value);</span><br><span class="line"></span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="title function_">reject</span>(error);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        handlers.<span class="title function_">push</span>(&#123;</span><br><span class="line"></span><br><span class="line">          <span class="attr">onFulfilled</span>: onFulfilled,</span><br><span class="line"></span><br><span class="line">          <span class="attr">onRejected</span>: onRejected</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">catch</span> = <span class="keyword">function</span>(<span class="params">onRejected</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个 <code>MyPromise</code> 构造函数，它接收一个函数 <code>fn</code> 作为参数。在构造函数内部，我们定义了三个变量：<code>state</code> 表示 Promise 的状态，初始值为 “pending”；<code>value</code> 表示 Promise 对象产生的结果或错误；<code>handlers</code> 是一个数组，用于存储所有的回调函数。</p>
<p>我们还定义了两个函数 <code>resolve</code> 和 <code>reject</code>，分别用于将 Promise 对象的状态设置为已完成或已拒绝，并将结果或错误存储在 <code>value</code> 变量中。当 Promise 对象状态发生改变时，我们遍历 <code>handlers</code> 数组，并调用所有的回调函数。</p>
<p>最后，我们定义了 <code>then</code> 和 <code>catch</code> 方法。<code>then</code> 方法接收两个参数：一个回调函数 <code>onFulfilled</code>，用于处理 Promise 对象成功的情况；一个回调函数 <code>onRejected</code>，用于处理 Promise 对象失败的情况。<code>then</code> 方法返回一个新的 Promise 对象，该对象可以继续调用 <code>then</code> 方法。<code>catch</code> 方法只接收一个参数：一个回调函数 <code>onRejected</code>，用于处理 Promise 对象失败的情况。<code>catch</code> 方法返回一个新的 Promise 对象，该对象可以继续调用 <code>then</code> 方法。</p>
<p>在 <code>then</code> 方法中，我们首先检查 Promise 对象的状态。如果 Promise 对象已经完成，则立即调用回调函数并返回一个新的 Promise 对象。如果 Promise 对象尚未完成，则将回调函数添加到 <code>handlers</code> 数组中，并返回一个新的 Promise 对象。</p>
<p>在调用回调函数时，我们使用 <code>setTimeout</code> 函数将其放入事件队列中，以确保它们在当前函数调用完成后执行。在调用回调函数时</p>
<h2 id="十二-async-await"><a href="#十二-async-await" class="headerlink" title="十二. async await"></a>十二. async await</h2><p><code>async</code> 和 <code>await</code> 是 ES2017 引入的新特性，用于更方便地处理异步操作。</p>
<p><code>async</code> 用于修饰函数，将普通函数转化为异步函数。使用 <code>async</code> 关键字声明的函数会自动返回一个 Promise 对象，因此在函数内部可以使用 <code>return</code> 关键字返回一个值，也可以通过抛出异常来拒绝 Promise 对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">someAsyncOperation</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>myAsyncFunction</code> 函数使用 <code>async</code> 关键字修饰，因此它自动返回一个 Promise 对象。在函数内部，我们使用 <code>await</code> 关键字等待某个异步操作完成，并将其结果存储在 <code>result</code> 变量中。如果异步操作失败，则抛出一个异常，Promise 对象会被拒绝。</p>
<p><code>await</code> 关键字用于等待一个 Promise 对象的状态变为已完成。在使用 <code>await</code> 关键字时，函数的执行会暂停，直到 Promise 对象的状态变为已完成或已拒绝。如果 Promise 对象的状态变为已完成，则 <code>await</code> 表达式的结果为 Promise 对象的值。如果 Promise 对象的状态变为已拒绝，则 <code>await</code> 表达式会抛出一个异常。</p>
<p><code>await</code> 关键字只能在 <code>async</code> 函数内部使用。如果在普通函数中使用 <code>await</code> 关键字，会导致语法错误。此外，<code>await</code> 关键字只能用于 Promise 对象，不能用于其他类型的值。如果要等待一个普通函数的执行结果，可以使用 <code>Promise.resolve</code> 函数将其转化为一个 Promise 对象，再使用 <code>await</code> 关键字等待其完成。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">someSyncOperation</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>someSyncOperation</code> 函数是一个普通的同步函数，我们使用 <code>Promise.resolve</code> 函数将其转化为一个 Promise 对象，再使用 <code>await</code> 关键字等待其执行完成。</p>
<h2 id="十三-JavaScript的深浅拷贝"><a href="#十三-JavaScript的深浅拷贝" class="headerlink" title="十三.JavaScript的深浅拷贝"></a>十三.JavaScript的深浅拷贝</h2><p>JavaScript 中的对象和数组是引用类型，在进行赋值、传参等操作时只会复制其引用而不是复制其实际内容。因此，如果多个变量引用同一个对象，对其中一个变量所做的修改会影响到其他变量所引用的对象。为了解决这个问题，可以使用深拷贝和浅拷贝。</p>
<p>浅拷贝是指复制引用类型变量的引用，而不复制其实际内容。JavaScript 中的对象和数组提供了一些浅拷贝的方法：</p>
<ol>
<li>Object.assign()：用于将一个或多个源对象的属性复制到目标对象中，并返回目标对象。如果多个源对象具有相同的属性，则后面的属性会覆盖前面的属性。</li>
</ol>
<p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> obj2 = &#123; <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1, obj2); <span class="comment">// &#123; a: 1, b: 3, c: 4 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>Array.prototype.concat()：用于将一个或多个数组连接起来，并返回一个新的数组。</li>
</ol>
<p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> newArr = arr1.<span class="title function_">concat</span>(arr2); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>Array.prototype.slice()：用于从数组中提取一部分元素，返回一个新的数组。如果不传参数，则返回一个与原数组相同的新数组。</li>
</ol>
<p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> newArr = arr.<span class="title function_">slice</span>(); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>以上方法都是浅拷贝，只能复制一层对象或数组的内容，如果对象或数组中包含嵌套的对象或数组，则无法复制其内部的内容。</p>
<p>深拷贝是指将引用类型变量的实际内容复制一份，而不是复制其引用。JavaScript 中的对象和数组没有提供深拷贝的方法，但可以使用第三方库或自己实现深拷贝函数。常见的深拷贝方法有：</p>
<ol>
<li>JSON.parse(JSON.stringify())：将对象转化为 JSON 字符串，再将 JSON 字符串转化为新的对象。这种方法可以深拷贝普通的对象和数组，但无法拷贝包含函数、RegExp 等类型的对象。</li>
</ol>
<p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>递归复制：递归地遍历对象或数组的每一个属性，将其值复制到新的对象或数组中。这种方法可以深拷贝任何类型的对象，但可能会存在循环引用的问题，需要特殊处理。</li>
</ol>
<p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">function</span> deep</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十四.深浅copy需要注意什么</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在进行深拷贝和浅拷贝时需要注意以下几点：</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 引用类型数据的属性和方法会被复制引用而不是复制实际值，对其中一个对象的修改会影响到其他对象。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 对于包含循环引用的对象，使用深拷贝可能会导致死循环，需要特殊处理。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 使用 <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>()) 进行深拷贝时，该方法无法拷贝包含函数、<span class="title class_">RegExp</span> 等类型的对象，且可能会丢失原有的数据类型。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 对于浅拷贝，如果拷贝的对象或数组中包含引用类型的数据，则只能拷贝一层的数据，无法拷贝其内部的数据。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 对于自定义对象，需要特别注意是否拷贝了其原型链上的属性和方法。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 对于数组，深拷贝和浅拷贝的方法不同，需要选择适合的方法进行拷贝。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因此，在进行深拷贝和浅拷贝时，需要根据实际情况选择合适的方法，并且对拷贝结果进行验证，以确保拷贝的结果符合预期。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十五.如何解决循环引用问题</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">循环引用是指对象 A 中包含对象 B 的引用，同时对象 B 中也包含对象 A 的引用。这种情况下，如果使用普通的深拷贝方法进行拷贝，可能会导致无限递归的问题。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为了解决循环引用的问题，可以采用以下两种方法：</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 手动处理循环引用。在拷贝对象时，如果遇到循环引用，则可以手动处理，例如记录已经拷贝的对象的引用，或者只拷贝对象的部分属性而非整个对象等。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 使用第三方库。有些第三方库提供了深拷贝方法，并且可以处理循环引用的问题，例如 <span class="title class_">Lodash</span> 的深拷贝方法 _.<span class="title function_">cloneDeep</span>()。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下是一个手动处理循环引用的示例代码：</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function deepCopy(obj, visited = new WeakMap()) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 如果是基本类型，则直接返回</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (typeof obj !== &#x27;object&#x27; || obj === null) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return obj;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 如果对象已经被拷贝过，则返回拷贝后的对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (visited.has(obj)) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return visited.get(obj);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 处理数组类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (Array.isArray(obj)) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const result = [];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    visited.set(obj, result);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for (let i = 0; i &lt; obj.length; i++) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      result[i] = deepCopy(obj[i], visited);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return result;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 处理对象类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  const result = &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  visited.set(obj, result);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  const keys = Object.keys(obj);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  for (let i = 0; i &lt; keys.length; i++) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const key = keys[i];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    result[key] = deepCopy(obj[key], visited);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return result;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，使用了 <code>visited</code> 变量记录已经被拷贝过的对象，避免重复拷贝和死循环的问题。同时，对于数组和对象分别进行了处理，确保拷贝的结果符合预期。</p>
<h2 id="十六-如何实现一个事件的发布订阅"><a href="#十六-如何实现一个事件的发布订阅" class="headerlink" title="十六.如何实现一个事件的发布订阅"></a>十六.如何实现一个事件的发布订阅</h2><p>实现一个事件的发布订阅可以分为以下几个步骤：</p>
<ol>
<li><p>创建一个事件管理器对象，用于存储事件和对应的回调函数。可以使用对象字面量或者类的方式来创建事件管理器对象。</p>
</li>
<li><p>创建订阅事件的方法，该方法用于向事件管理器中添加事件和对应的回调函数。在该方法中，需要对事件是否已经存在进行判断，如果事件不存在，则创建该事件并将回调函数添加到事件列表中；如果事件已经存在，则直接将回调函数添加到事件列表中。</p>
</li>
<li><p>创建发布事件的方法，该方法用于触发事件并执行对应的回调函数。在该方法中，需要获取事件列表，并逐个执行回调函数。</p>
</li>
</ol>
<p>以下是一个简单的实现示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = [];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">push</span>(callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> callback.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">on</span>(<span class="string">&#x27;sayHello&#x27;</span>, <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;sayHello&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>); <span class="comment">// 输出：Hello, Tom!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>EventEmitter</code> 类中的 <code>on</code> 方法用于添加事件和回调函数，<code>emit</code> 方法用于触发事件并执行对应的回调函数。可以通过创建 <code>EventEmitter</code> 实例并调用 <code>on</code> 方法来订阅事件，调用 <code>emit</code> 方法来触发事件并执行回调函数。</p>
<h2 id="十七-JS事件循环"><a href="#十七-JS事件循环" class="headerlink" title="十七.JS事件循环"></a>十七.JS事件循环</h2><p>事件循环（Event Loop）是 JavaScript 运行时中非常重要的一个概念，它控制了 JavaScript 代码的执行顺序，保证了异步任务的正确执行。简单来说，事件循环就是一个不断循环的过程，它会检查任务队列中是否有待执行的任务，如果有，则会执行任务，并等待新的任务加入队列。</p>
<p>事件循环的实现方式不同于浏览器和 Node.js，但基本思路都是相同的。以下是一个简单的事件循环模型：</p>
<ol>
<li><p>任务分为同步任务和异步任务，同步任务会在调用栈中按顺序执行，而异步任务会被放入任务队列中等待执行。</p>
</li>
<li><p>当执行栈中的同步任务执行完毕后，事件循环会检查任务队列中是否有任务待执行。</p>
</li>
<li><p>如果任务队列中有任务，则事件循环会将第一个任务取出并放入执行栈中执行，直到任务队列为空。</p>
</li>
<li><p>如果任务队列为空，则事件循环会继续等待新的任务加入队列。</p>
</li>
</ol>
<p>在实际运行中，事件循环会根据任务类型和任务的执行状态进行不同的处理。对于异步任务，当其执行完成后会将回调函数放入任务队列中，等待事件循环将其取出并执行。对于某些异步任务，如 Promise 和 setTimeout，其回调函数会被放入微任务队列和宏任务队列中，优先级不同。</p>
<p>事件循环模型的实现方式可能会有所不同，但其基本思路和机制都是相似的。掌握事件循环的原理和机制可以帮助开发者更好地理解 JavaScript 的异步编程模型，并编写出更高效、更优雅的代码。</p>
<h2 id="十八-宏任务和微任务有什么区别"><a href="#十八-宏任务和微任务有什么区别" class="headerlink" title="十八.宏任务和微任务有什么区别"></a>十八.宏任务和微任务有什么区别</h2><p>在 JavaScript 中，任务可以分为宏任务（macro-task）和微任务（micro-task），它们在事件循环中有不同的优先级和执行顺序。简单来说，宏任务是由浏览器或 Node.js 发起的任务，而微任务是由 JavaScript 代码本身发起的任务。</p>
<p>以下是宏任务和微任务的一些区别：</p>
<ol>
<li><p>执行时机：在一个事件循环中，宏任务会在微任务之前执行。当宏任务执行完成后，会执行所有的微任务，直到微任务队列为空。因此，微任务比宏任务更加优先执行。</p>
</li>
<li><p>添加方式：宏任务是由浏览器或 Node.js API 发起的，例如 setTimeout、setInterval、requestAnimationFrame、I&#x2F;O 操作等，它们会被放入宏任务队列中等待执行。而微任务是由 JavaScript 代码本身发起的，例如 Promise、MutationObserver 等，它们会被放入微任务队列中等待执行。</p>
</li>
<li><p>调用栈：当宏任务被执行时，会创建一个新的全局上下文并放入调用栈中。而当微任务被执行时，是在当前调用栈执行结束后立即执行的，不会创建新的全局上下文。</p>
</li>
<li><p>数量限制：在一个事件循环中，宏任务的数量是有限制的，而微任务的数量没有限制。如果宏任务队列中有大量的任务需要执行，可能会导致微任务长时间得不到执行。</p>
</li>
</ol>
<p>了解宏任务和微任务的区别和优先级，可以帮助开发者更好地理解事件循环的工作原理，编写出更加高效和可维护的 JavaScript 代码。</p>
<h2 id="十九-关于函数式编程"><a href="#十九-关于函数式编程" class="headerlink" title="十九.关于函数式编程"></a>十九.关于函数式编程</h2><p>函数式编程（Functional Programming，简称 FP）是一种编程范式，它将计算过程看作是函数之间的组合，并避免了状态和可变数据。函数式编程强调的是将函数作为基本的构建块，而不是将对象或语句作为基本的构建块。</p>
<p>函数式编程的核心概念包括：</p>
<ol>
<li><p>纯函数：纯函数是指函数的输出只由输入决定，不受外部环境的影响，也不会对外部环境造成影响。纯函数没有副作用，可以进行缓存和优化。</p>
</li>
<li><p>不可变性：不可变性指的是数据一旦被创建就不能被改变，每一次修改数据都会创建新的数据。不可变性避免了对数据的直接修改和共享数据带来的风险。</p>
</li>
<li><p>函数组合：函数组合是将多个函数组合成一个新的函数，实现代码复用和模块化。函数组合可以通过函数柯里化、高阶函数和函数管道等方式实现。</p>
</li>
<li><p>高阶函数：高阶函数是指接受函数作为参数或返回函数作为结果的函数，可以实现抽象和通用的代码。</p>
</li>
</ol>
<p>函数式编程可以带来许多好处，例如：</p>
<ol>
<li><p>可维护性：函数式编程强调模块化和抽象，可以更容易地理解和维护代码。</p>
</li>
<li><p>可测试性：纯函数和不可变性使得测试更加容易和可靠，可以减少测试的复杂度和耗时。</p>
</li>
<li><p>可扩展性：函数式编程可以更好地处理复杂性，通过函数的组合和抽象可以处理更多的需求和场景。</p>
</li>
<li><p>并发性：函数式编程天生适合并发编程，因为它没有共享状态和副作用，可以避免并发风险和竞态条件。</p>
</li>
</ol>
<p>函数式编程已经被广泛应用于各种编程语言和应用场景中，例如 JavaScript、Python、Haskell、Scala 等。</p>
<h2 id="二十-Service-worker"><a href="#二十-Service-worker" class="headerlink" title="二十.Service worker"></a>二十.Service worker</h2><p>Service Worker 是浏览器提供的一种 JavaScript 工具，可以在浏览器背后运行，拦截网络请求，控制 Web 页面或应用程序的缓存以及离线使用。</p>
<p>Service Worker 是一种网络代理，可以拦截 Web 页面或应用程序的网络请求，将请求重定向到本地缓存或网络，并返回结果。因为 Service Worker 运行在浏览器背后，所以它可以在没有网络连接的情况下提供 Web 应用程序的核心功能。</p>
<p>Service Worker 有以下特点：</p>
<ol>
<li><p>离线缓存：Service Worker 可以缓存 Web 页面或应用程序的资源，使得用户可以在离线情况下使用 Web 应用程序。</p>
</li>
<li><p>事件驱动：Service Worker 是基于事件驱动的，它可以监听浏览器的网络请求事件，并根据需要进行处理。</p>
</li>
<li><p>跨域支持：Service Worker 支持跨域请求，可以拦截和处理来自不同域名的网络请求。</p>
</li>
<li><p>安全性：Service Worker 可以通过 HTTPS 协议来确保通信的安全性。</p>
</li>
</ol>
<p>使用 Service Worker 可以提高 Web 应用程序的性能和用户体验，具体应用场景包括：</p>
<ol>
<li><p>离线缓存：使用 Service Worker 可以在用户离线时提供 Web 应用程序的核心功能，避免用户在没有网络连接的情况下无法使用应用程序。</p>
</li>
<li><p>首屏渲染优化：使用 Service Worker 可以缓存 Web 页面或应用程序的资源，减少页面加载时间，提高用户体验。</p>
</li>
<li><p>推送通知：使用 Service Worker 可以接收来自服务器的推送通知，实现即时通讯和推送服务。</p>
</li>
</ol>
<p>Service Worker 是一个相对新的技术，需要浏览器的支持才能使用。在使用 Service Worker 时需要注意安全性和性能等方面的问题，避免对用户的使用造成负面影响。</p>
<h2 id="二十一-web-worker"><a href="#二十一-web-worker" class="headerlink" title="二十一.web worker"></a>二十一.web worker</h2><p>Web Worker 是一种在浏览器中运行 JavaScript 代码的机制，它允许在后台线程中运行脚本，从而避免阻塞主线程。Web Worker 可以在主线程之外创建新的线程，使得 Web 应用程序可以同时进行多个任务，提高性能和用户体验。</p>
<p>Web Worker 的主要特点包括：</p>
<ol>
<li><p>多线程：Web Worker 可以在后台线程中运行 JavaScript 代码，避免阻塞主线程，提高 Web 应用程序的性能。</p>
</li>
<li><p>可以通过消息传递来通信：Web Worker 和主线程之间可以通过消息传递来进行通信，从而实现多个线程之间的协作。</p>
</li>
<li><p>安全性：Web Worker 在沙箱中运行，只能访问自己的代码和数据，不能直接访问主线程中的代码和数据。</p>
</li>
</ol>
<p>使用 Web Worker 可以解决一些耗时的操作，比如对大数据进行排序、解析或者加密等。在这些操作中，Web Worker 可以在后台线程中进行计算，不会阻塞主线程，从而提高 Web 应用程序的性能和用户体验。</p>
<p>需要注意的是，Web Worker 中不能直接访问 DOM 元素，需要通过消息传递的方式来与主线程进行通信。此外，Web Worker 也需要考虑安全性的问题，避免恶意脚本的攻击。</p>
<h2 id="二十二-JS常用方法"><a href="#二十二-JS常用方法" class="headerlink" title="二十二.JS常用方法"></a>二十二.JS常用方法</h2><p>JavaScript 作为一门高级编程语言，提供了大量的内置方法和函数，可以用来处理和操作各种数据类型和数据结构。随着 ES6（ECMAScript 2015）的发布，JavaScript 又增加了许多新的语言特性和内置方法，下面介绍一些 ES6 中常用的内置方法。</p>
<ol>
<li><p>let 和 const：ES6 引入了新的关键字 let 和 const，可以用来声明变量和常量，let 声明的变量是块级作用域，const 声明的常量是不可修改的。</p>
</li>
<li><p>箭头函数：箭头函数是一种更简洁的函数定义方式，它使用 &#x3D;&gt; 符号来定义函数，可以省略 function 关键字和 return 语句，同时还可以继承外部作用域的 this 关键字。</p>
</li>
<li><p>模板字符串：ES6 引入了模板字符串，可以用来定义多行字符串和插入变量，使用反引号 &#96; 来定义模板字符串，使用 ${} 来插入变量。</p>
</li>
<li><p>解构赋值：ES6 中可以使用解构赋值来提取对象或数组中的值，可以用来快速获取对象或数组中的属性或元素。</p>
</li>
<li><p>for…of 循环：ES6 引入了 for…of 循环，可以用来遍历可迭代对象（如数组、字符串、Set 和 Map）中的元素。</p>
</li>
<li><p>Promise：Promise 是一种异步编程的解决方案，可以用来处理异步操作和回调地狱的问题。</p>
</li>
<li><p>async&#x2F;await：async&#x2F;await 是 ES7 中引入的异步编程的解决方案，可以用来处理异步操作和 Promise 的问题，让异步代码看起来更像同步代码。</p>
</li>
<li><p>扩展运算符：扩展运算符（…）可以用来将一个数组或对象展开成多个参数，也可以用来将多个参数合并成一个数组或对象。</p>
</li>
<li><p>Set 和 Map：ES6 引入了新的数据结构 Set 和 Map，Set 是一种无重复元素的集合，Map 是一种键值对的集合。</p>
</li>
<li><p>class：ES6 引入了 class 关键字，可以用来定义类和构造函数，使得 JavaScript 的面向对象编程更加规范和易用。</p>
</li>
</ol>
<p>这些是 ES6 中常用的一些内置方法和语言特性，它们可以让 JavaScript 代码更加简洁、易读和易维护。</p>
<h2 id="二十三-JS常用数组方法"><a href="#二十三-JS常用数组方法" class="headerlink" title="二十三.JS常用数组方法"></a>二十三.JS常用数组方法</h2><p>JavaScript 中数组是一种常见的数据结构，它提供了很多内置方法用来处理和操作数组。下面介绍一些常用的数组方法：</p>
<ol>
<li><p>push()：将一个或多个元素添加到数组的末尾，并返回新数组的长度。</p>
</li>
<li><p>pop()：移除数组的最后一个元素，并返回该元素的值。</p>
</li>
<li><p>shift()：移除数组的第一个元素，并返回该元素的值。</p>
</li>
<li><p>unshift()：将一个或多个元素添加到数组的开头，并返回新数组的长度。</p>
</li>
<li><p>splice()：从数组中添加或移除元素，可以用来删除、插入或替换元素。</p>
</li>
<li><p>slice()：返回数组的一个子数组，从开始索引到结束索引（不包括结束索引）。</p>
</li>
<li><p>forEach()：遍历数组中的每个元素，执行指定的回调函数。</p>
</li>
<li><p>map()：对数组中的每个元素执行指定的操作，并返回操作后的新数组。</p>
</li>
<li><p>filter()：返回一个新数组，包含数组中所有符合条件的元素。</p>
</li>
<li><p>reduce()：对数组中的所有元素进行累加或其他操作，返回一个累加结果。</p>
</li>
<li><p>find()：返回数组中第一个符合条件的元素，如果没有符合条件的元素，则返回 undefined。</p>
</li>
<li><p>findIndex()：返回数组中第一个符合条件的元素的索引，如果没有符合条件的元素，则返回 -1。</p>
</li>
<li><p>concat()：将两个或多个数组合并成一个新数组。</p>
</li>
<li><p>join()：将数组中的所有元素转换为字符串，并用指定的分隔符连接起来。</p>
</li>
<li><p>reverse()：反转数组中的元素顺序。</p>
</li>
<li><p>sort()：对数组中的元素进行排序，默认按照 Unicode 字符顺序进行排序。</p>
</li>
</ol>
<p>这些是 JavaScript 中常用的一些数组方法，它们可以让我们更方便地处理和操作数组，提高代码的效率和可读性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/12/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/12/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">小话设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-12 00:03:41" itemprop="dateCreated datePublished" datetime="2023-05-12T00:03:41+08:00">2023-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一.背景"></a>一.背景</h2><p>在我们平时开发过程中，遇到最多的问题基本上都是软件设计相关的一系列问题，如设计不合理，造成开发效率低下，维护和扩展性底，bug率高，那么这个时候优秀的设计模式就至关重要了。</p>
<p>学习设计模式可以帮助软件开发人员更好地设计和开发高质量的软件系统。设计模式是在软件开发中经过实践证明有效的最佳实践的总结，它们提供了一组可复用的解决方案，可帮助开发人员处理常见的软件设计问题。</p>
<p>以下是设计模式对我们日常开发维护起到的一些好处：</p>
<ol>
<li>提高代码质量：设计模式鼓励开发人员使用一些经过验证的解决方案，这些方案已经在实践中证明是有效的。通过使用这些解决方案，开发人员可以编写更加清晰、易于维护和扩展的代码。</li>
<li>提高代码复用性：设计模式提供了可重用的解决方案，使得开发人员可以在不同的项目和场景中使用这些方案来解决相似的问题。</li>
<li>更好的团队协作：设计模式提供了一种共同的语言和标准，使得团队成员可以更好地相互沟通和理解。</li>
<li>更快的开发速度：使用设计模式可以加速软件开发过程，因为它们提供了可重用的解决方案，使得开发人员可以更快地实现系统功能。</li>
</ol>
<p>总之，学习设计模式可以帮助软件开发人员更加高效地工作，提高软件系统的质量和可维护性。下面就详细梳理下23种设计模式。</p>
<h2 id="二-设计模式的6大设计原则"><a href="#二-设计模式的6大设计原则" class="headerlink" title="二.设计模式的6大设计原则"></a>二.设计模式的6大设计原则</h2><p>设计模式的6大设计原则，也被称为SOLID原则，它们是：</p>
<h3 id="1-单一职责原则（Single-Responsibility-Principle，SRP）："><a href="#1-单一职责原则（Single-Responsibility-Principle，SRP）：" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle，SRP）："></a>1. 单一职责原则（Single Responsibility Principle，SRP）：</h3><p>   一个类应该只有一个引起它变化的原因。简单来说，就是一个类应该只有一种职责，不应该承担太多的职责，避免代码耦合性过高。</p>
<h3 id="2-开放封闭原则（Open-Closed-Principle，OCP）："><a href="#2-开放封闭原则（Open-Closed-Principle，OCP）：" class="headerlink" title="2. 开放封闭原则（Open-Closed Principle，OCP）："></a>2. 开放封闭原则（Open-Closed Principle，OCP）：</h3><p>   一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。也就是说，在不修改原有代码的情况下，可以通过扩展来增加功能。</p>
<h3 id="3-里氏替换原则（Liskov-Substitution-Principle，LSP）："><a href="#3-里氏替换原则（Liskov-Substitution-Principle，LSP）：" class="headerlink" title="3. 里氏替换原则（Liskov Substitution Principle，LSP）："></a>3. 里氏替换原则（Liskov Substitution Principle，LSP）：</h3><p>   所有引用基类对象的地方，都可以用其子类对象替换，而不影响程序的正确性。也就是说，子类对象可以在程序中替换父类对象，而程序的行为不会发生变化。</p>
<h3 id="4-接口隔离原则（Interface-Segregation-Principle，ISP）："><a href="#4-接口隔离原则（Interface-Segregation-Principle，ISP）：" class="headerlink" title="4. 接口隔离原则（Interface Segregation Principle，ISP）："></a>4. 接口隔离原则（Interface Segregation Principle，ISP）：</h3><p>   客户端不应该依赖它不需要的接口。简单来说，就是要将一个庞大的接口拆分成多个小的、专门的接口，以便于客户端只需知道它需要使用的方法。</p>
<h3 id="5-依赖倒置原则（Dependency-Inversion-Principle，DIP）："><a href="#5-依赖倒置原则（Dependency-Inversion-Principle，DIP）：" class="headerlink" title="5. 依赖倒置原则（Dependency Inversion Principle，DIP）："></a>5. 依赖倒置原则（Dependency Inversion Principle，DIP）：</h3><p>   高层模块不应该依赖底层模块，二者都应该依赖抽象接口；抽象接口不应该依赖具体实现，具体实现应该依赖抽象接口。简单来说，就是要面向接口编程，而不是面向实现编程。</p>
<h3 id="6-迪米特法则（Law-of-Demeter，LoD）："><a href="#6-迪米特法则（Law-of-Demeter，LoD）：" class="headerlink" title="6. 迪米特法则（Law of Demeter，LoD）："></a>6. 迪米特法则（Law of Demeter，LoD）：</h3><p>   一个对象应该对其他对象保持最少的了解。简单来说，就是一个对象应该只与它直接的朋友进行交流，不与陌生人说话。这可以减少对象之间的耦合，提高代码的复用性和可维护性。</p>
<h2 id="三-设计模式"><a href="#三-设计模式" class="headerlink" title="三.设计模式"></a>三.设计模式</h2><p>可以分为三类：</p>
<h3 id="1-创建型模式（Creational-Patterns）："><a href="#1-创建型模式（Creational-Patterns）：" class="headerlink" title="1.  创建型模式（Creational Patterns）："></a>1.  创建型模式（Creational Patterns）：</h3><p>用于创建对象的模式，这些模式将对象的创建和使用分离开来，从而提高了系统的灵活性和可扩展性。工厂方法模式、抽象工厂模式、单例模式、建造者模式和原型模式属于创建型模式。</p>
<h3 id="2-结构型模式（Structural-Patterns）："><a href="#2-结构型模式（Structural-Patterns）：" class="headerlink" title="2.  结构型模式（Structural Patterns）："></a>2.  结构型模式（Structural Patterns）：</h3><p>用于描述如何将类或对象组合成更大的结构，从而构成更为复杂的系统。这些模式关注对象的组合方式，以及类和对象之间的关系。适配器模式、桥接模式、组合模式、装饰者模式、外观模式、享元模式和代理模式属于结构型模式。</p>
<h3 id="3-行为型模式（Behavioral-Patterns）："><a href="#3-行为型模式（Behavioral-Patterns）：" class="headerlink" title="3.  行为型模式（Behavioral Patterns）："></a>3.  行为型模式（Behavioral Patterns）：</h3><p>用于描述对象之间的通信和协作，以及类和对象之间的职责分配。这些模式关注对象之间的交互方式，以及如何实现对象的行为。模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式和访问者模式属于行为型模式。</p>
<h3 id="以下是23种常见的设计模式："><a href="#以下是23种常见的设计模式：" class="headerlink" title="以下是23种常见的设计模式："></a>以下是23种常见的设计模式：</h3><h4 id="1-工厂方法模式（Factory-Method-Pattern）"><a href="#1-工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="1. 工厂方法模式（Factory Method Pattern）"></a>1. 工厂方法模式（Factory Method Pattern）</h4><p>定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c4a3c5fc456441a812dbc1a8db9f201~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="2-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2. 抽象工厂模式（Abstract Factory Pattern）"></a>2. 抽象工厂模式（Abstract Factory Pattern）</h4><p>定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9c065a219f9420fa725815e391402b3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="3-单例模式（Singleton-Pattern）"><a href="#3-单例模式（Singleton-Pattern）" class="headerlink" title="3. 单例模式（Singleton Pattern）"></a>3. 单例模式（Singleton Pattern）</h4><p>定义：确保一个类只有一个实例，并提供全局访问点。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841cd60f5e4f44868c70cdcb54e0fb34~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="4-建造者模式（Builder-Pattern）"><a href="#4-建造者模式（Builder-Pattern）" class="headerlink" title="4. 建造者模式（Builder Pattern）"></a>4. 建造者模式（Builder Pattern）</h4><p>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee57f567125e44f2a9fd4ebe3d7401a1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="5-原型模式（Prototype-Pattern）"><a href="#5-原型模式（Prototype-Pattern）" class="headerlink" title="5. 原型模式（Prototype Pattern）"></a>5. 原型模式（Prototype Pattern）</h4><p>定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/315b422dfac6499d807ad37b773ece80~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="6-适配器模式（Adapter-Pattern）"><a href="#6-适配器模式（Adapter-Pattern）" class="headerlink" title="6. 适配器模式（Adapter Pattern）"></a>6. 适配器模式（Adapter Pattern）</h4><p>定义：将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca90e5f06fa44f5eb503b1c5c79afcf7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="7-桥接模式（Bridge-Pattern）"><a href="#7-桥接模式（Bridge-Pattern）" class="headerlink" title="7. 桥接模式（Bridge Pattern）"></a>7. 桥接模式（Bridge Pattern）</h4><p>定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87cc05867f6e49108184705f23d9f4f7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="8-组合模式（Composite-Pattern）"><a href="#8-组合模式（Composite-Pattern）" class="headerlink" title="8. 组合模式（Composite Pattern）"></a>8. 组合模式（Composite Pattern）</h4><p>定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13594dc231004a94aabc52b1329dbd7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="9-装饰者模式（Decorator-Pattern）"><a href="#9-装饰者模式（Decorator-Pattern）" class="headerlink" title="9. 装饰者模式（Decorator Pattern）"></a>9. 装饰者模式（Decorator Pattern）</h4><p>定义：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更加灵活。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd17b60f94cb40c7b6c6f49c8a294729~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="10-外观模式（Facade-Pattern）"><a href="#10-外观模式（Facade-Pattern）" class="headerlink" title="10. 外观模式（Facade Pattern）"></a>10. 外观模式（Facade Pattern）</h4><p>定义：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高级接口，这个接口使得这一子系统更加容易使用。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904e37d93e4b47e7b74ded6729297722~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="11-享元模式（Flyweight-Pattern）"><a href="#11-享元模式（Flyweight-Pattern）" class="headerlink" title="11. 享元模式（Flyweight Pattern）"></a>11. 享元模式（Flyweight Pattern）</h4><p>定义：运用共享技术有效地支持大量细粒度的对象。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d161bea8d03d4b5f917a04493e17b736~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="12-代理模式（Proxy-Pattern）"><a href="#12-代理模式（Proxy-Pattern）" class="headerlink" title="12. 代理模式（Proxy Pattern）"></a>12. 代理模式（Proxy Pattern）</h4><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf9fa5b9f94b43b6b880a85552036cc8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="13-模板方法模式（Template-Method-Pattern）"><a href="#13-模板方法模式（Template-Method-Pattern）" class="headerlink" title="13. 模板方法模式（Template Method Pattern）"></a>13. 模板方法模式（Template Method Pattern）</h4><p>定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e3102ef943495e98ffaa6f627d0a8c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="14-命令模式（Command-Pattern）"><a href="#14-命令模式（Command-Pattern）" class="headerlink" title="14. 命令模式（Command Pattern）"></a>14. 命令模式（Command Pattern）</h4><p>定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd3b1f1a3c494fcbaa29c46a7c7e5d07~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="15-迭代器模式（Iterator-Pattern）"><a href="#15-迭代器模式（Iterator-Pattern）" class="headerlink" title="15. 迭代器模式（Iterator Pattern）"></a>15. 迭代器模式（Iterator Pattern）</h4><p>定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2f6d438dadf46b8b1ad1069d2cbda2c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="16-观察者模式（Observer-Pattern）"><a href="#16-观察者模式（Observer-Pattern）" class="headerlink" title="16. 观察者模式（Observer Pattern）"></a>16. 观察者模式（Observer Pattern）</h4><p>定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a8490b7e564d89894c2248c04f3abc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="17-中介者模式（Mediator-Pattern）"><a href="#17-中介者模式（Mediator-Pattern）" class="headerlink" title="17. 中介者模式（Mediator Pattern）"></a>17. 中介者模式（Mediator Pattern）</h4><p>定义：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edaef6085acf426d91ba2175ba57fbaf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="18-备忘录模式（Memento-Pattern）"><a href="#18-备忘录模式（Memento-Pattern）" class="headerlink" title="18. 备忘录模式（Memento Pattern）"></a>18. 备忘录模式（Memento Pattern）</h4><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ecfba236d8746019186b233341725f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="19-解释器模式（Interpreter-Pattern）"><a href="#19-解释器模式（Interpreter-Pattern）" class="headerlink" title="19. 解释器模式（Interpreter Pattern）"></a>19. 解释器模式（Interpreter Pattern）</h4><p>定义：给定一个语言，定义它的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8369f7458264d188121bb7fbe1e15d2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="20-状态模式（State-Pattern）"><a href="#20-状态模式（State-Pattern）" class="headerlink" title="20. 状态模式（State Pattern）"></a>20. 状态模式（State Pattern）</h4><p>定义：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc885e7bb8354d219d627dcb80260c0b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="21-策略模式（Strategy-Pattern）"><a href="#21-策略模式（Strategy-Pattern）" class="headerlink" title="21. 策略模式（Strategy Pattern）"></a>21. 策略模式（Strategy Pattern）</h4><p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换。本模式使得算法可独立于使用它的客户而变化。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06493f39d9ab494eadca7c100fbe278e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="22-职责链模式（Chain-of-Responsibility-Pattern）"><a href="#22-职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="22. 职责链模式（Chain of Responsibility Pattern）"></a>22. 职责链模式（Chain of Responsibility Pattern）</h4><p>定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ac8d7832cdf42e68a0f4c7bf1250e50~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="23-访问者模式（Visitor-Pattern）"><a href="#23-访问者模式（Visitor-Pattern）" class="headerlink" title="23. 访问者模式（Visitor Pattern）"></a>23. 访问者模式（Visitor Pattern）</h4><p>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的前提下定义作用于这些元素的新操作。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c944a2c6151462486b1e6d0885ec071~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>以上是23种设计模式的介绍，在项目中还需要多去实践才能灵活贯通。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/11/iOS%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/11/iOS%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">iOS编译速度优化实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-11 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-11T00:00:00+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h1><p>随着业务的发展免不了带来工程代码的飞速增加，程的业务代码数量超过10w行的非常普遍，使用的的二方&#x2F;三方 Pod 库的数量也会持续增加，工程的急速膨胀给我们的日常开发中带来了诸多痛点，在项目体量越来越大的情况下，编译速度也随之增长，工程编译速度降低，clean-build 一次需要 10-15min 左右，目前在大部分项目中xcode全部编译一次少则5分钟，多则10多分钟，甚至更久，严重影响开发效率。有时候一个小的改动也需要等待长达好几分钟的编译时间，打包速度降低，在打包提测窗口增加了等待的时长，在硬件资源有限的情况下，并且在不影响业务方开发习惯的前提下，如何解决这些摆在团队面前的难题，便成了我们迫在眉睫的迫切需求。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>针对这个问题，做了多方面的探究，从业界方案参考来看大概有以下几种策略去解决。</p>
<ol>
<li>xcode 编译选项优化</li>
<li>编译生成中间产物CCache优化</li>
<li>直接生成二进制编译</li>
</ol>
<h1 id="一-Xcode-编译选项优化"><a href="#一-Xcode-编译选项优化" class="headerlink" title="一. Xcode 编译选项优化"></a>一. Xcode 编译选项优化</h1><h2 id="1-Xcode配置"><a href="#1-Xcode配置" class="headerlink" title="1.Xcode配置"></a>1.Xcode配置</h2><h3 id="1-1-Enable-build-duration-setting-in-Xcode"><a href="#1-1-Enable-build-duration-setting-in-Xcode" class="headerlink" title="1.1. Enable build duration setting in Xcode"></a>1.1. Enable build duration setting in Xcode</h3><p>你可以直接在 Xcode 的 UI 中启用计时器。默认情况下此计时器不可见，但如果在命令行中运行以下命令，则每次构建应用程序时都会显示一个时间。</p>
<p>启用计时器后，您将在 Xcode 的构建状态栏中看到编译应用程序所需的时间。</p>
<p>终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</span><br></pre></td></tr></table></figure>

<p>启用计时器后，重启xcode ，您将在 Xcode 的构建状态栏中看到编译应用程序所需的时间。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf31cd81c5e443bbb9997874645966eb~tplv-k3u1fbpfcp-watermark.image" alt="Bulld Succeededl 17.3785.png"></p>
<h3 id="1-2使用新的构建系统"><a href="#1-2使用新的构建系统" class="headerlink" title="1.2使用新的构建系统"></a>1.2使用新的构建系统</h3><p>Apple 在 Xcode 9 中推出了一个新的构建系统，但默认情况下并未激活。Apple 的“New Build System”完全用 Swift 编写，旨在提高整体性能和依赖管理。但是，对于 Xcode 10，新的构建设置已默认激活并从<strong>Xcode Files-&gt; Project&#x2F;Workspace Settings启用</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4137ce399c00429e96a221bcf57eb4f9~tplv-k3u1fbpfcp-watermark.image" alt="Shared Workspace Settinas.png"><br>您可以在工作区设置中或通过调用以下方式启用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -UseNewBuildSystem=YES.</span><br></pre></td></tr></table></figure>



<h3 id="1-3-添加警告以查看函数或表达式是否导致编译时间变长"><a href="#1-3-添加警告以查看函数或表达式是否导致编译时间变长" class="headerlink" title="1.3. 添加警告以查看函数或表达式是否导致编译时间变长"></a>1.3. 添加警告以查看函数或表达式是否导致编译时间变长</h3><p>Xcode 具有内置功能，可让您识别导致编译时间变长的函数和表达式。您可以指定编译时间限制并确定代码库中超出此限制的区域。</p>
<p>在项目构建设置“其他 Swift 标志”中添加以下行</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xfrontend -warn-long-function-bodies=300 </span><br><span class="line"></span><br><span class="line">-Xfrontend -warn-long-expression-type-checking=300</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48d5ed1e058f43ec80bb85e9aac9b7a1~tplv-k3u1fbpfcp-watermark.image" alt="0_-IHHautFe768XJpz.webp"></p>
<p>300 整数表示您对函数和表达式设置的编译时限制。它以毫秒为单位。</p>
<p>如果函数或表达式花费的时间超过您指定的时间，这些标志将警告您。这意味着您必须优化您的函数或表达式。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95fe13a6447248da9f7808a0a51e4bc0~tplv-k3u1fbpfcp-watermark.image" alt="0N9qavcIVkF05XZ29.png"></p>
<h3 id="1-4-增加-Xcode-线程数"><a href="#1-4-增加-Xcode-线程数" class="headerlink" title="1.4. 增加 Xcode 线程数"></a>1.4. 增加 Xcode 线程数</h3><p>默认情况下，Xcode 将使用与 CPU 内核数相同的线程数。增加 Xcode 使用的线程数可以显着提高编译性能。这利用了一些处理器的多线程或模拟额外内核的能力。请记住，您可能需要进行试验以确定使用代码库进行并行构建的收益是否递减，然后相应地调整线程数。让我们尝试将 Xcode 配置为使用 3、4 或 8 个线程，看看哪一个为您的用例提供最佳性能。</p>
<p>您可以设置 Xcode 从终端使用的进程数，如下所示：</p>
<p><code>$defaults write com.apple.Xcode PBXNumberOfParallelBuildSubtasks 4 </code></p>
<h3 id="1-5-增加为-Swift-项目运行的并发构建任务的数量"><a href="#1-5-增加为-Swift-项目运行的并发构建任务的数量" class="headerlink" title="1.5. 增加为 Swift 项目运行的并发构建任务的数量"></a>1.5. 增加为 Swift 项目运行的并发构建任务的数量</h3><p>在 Xcode 9.2 中，Apple 引入了一项实验性功能，允许 Xcode 并行运行 Swift 构建任务。默认情况下，此功能未启用，您需要从命令行自行打开它。</p>
<p>默认写入 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively -bool YES</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-6-调整-iOS-模拟器（当然可以选择使用真机）"><a href="#1-6-调整-iOS-模拟器（当然可以选择使用真机）" class="headerlink" title="1.6. 调整 iOS 模拟器（当然可以选择使用真机）"></a>1.6. 调整 iOS 模拟器（当然可以选择使用真机）</h3><p>Apple iOS 测试模拟器让您可以跨不同的软件和硬件组合进行测试。通过使用 Physical Size 或 Pixel Accurate 窗口大小，您可以减少测试的大小和完成测试所需的时间。最终，这些配置更改使用的资源更少，有助于防止测试速度变慢，可以选择并拖动模拟器的任何角落以调整其大小并根据您的要求进行设置。另外，您可以按 CMD+1、CMD+2 或 CMD+3</p>
<h3 id="1-7-并行构建"><a href="#1-7-并行构建" class="headerlink" title="1.7. 并行构建"></a>1.7. 并行构建</h3><p>此选项允许 Xcode 通过同时构建不相互依赖的目标来加快总构建时间。对于具有许多可以轻松并行运行的较小依赖项的项目，这可以节省时间。</p>
<p>在 Xcode 10 中打开项目时，构建并行化应该已经启用。要检查或更改此选项，请打开方案编辑器，在边栏中选择“Build”并确保在顶部选中“Parallelize Build”。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24de558688d42b286fb70d7cd8d2bf5~tplv-k3u1fbpfcp-watermark.image" alt="2 Shared.png"></p>
<h3 id="1-8-仅构建活动架构"><a href="#1-8-仅构建活动架构" class="headerlink" title="1.8. 仅构建活动架构"></a>1.8. 仅构建活动架构</h3><p>当您的调试配置被选中时，您的项目应该只构建活动架构。默认情况下，此设置应处于活动状态，但值得检查以防万一。</p>
<p>导航到Build Active Architecture Only项目的构建设置中。确保 Debug 设置为Yes并且 release 设置为No。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f37af8023474e8c861ef6559396f053~tplv-k3u1fbpfcp-watermark.image" alt="Bulld Active Architecture Only.png"></p>
<p>确保为您的调试配置将 Build Active Architecture Only 设置为 Yes</p>
<h2 id="2-适当的构建设置"><a href="#2-适当的构建设置" class="headerlink" title="2.适当的构建设置"></a>2.适当的构建设置</h2><h3 id="2-1-优化-dSYM-生成"><a href="#2-1-优化-dSYM-生成" class="headerlink" title="2.1. 优化 dSYM 生成"></a>2.1. 优化 dSYM 生成</h3><p><strong>DWARF：</strong> 是一种广泛使用的标准化调试数据格式。DWARF 最初是与可执行和可链接格式 (ELF) 一起设计的，尽管它独立于目标文件格式。</p>
<p><strong>调试符号 (dSYM)：</strong> 默认情况下，应用程序的调试版本将调试符号存储在已编译的二进制文件中，而应用程序的发布版本将调试符号存储在配套的 dSYM 文件中以减小二进制文件的大小。</p>
<p><em>DWARF</em> 和带有 <em>dSYM</em> 文件的 <em>DWARF</em> 有什么区别？</p>
<p>不同之处在于，对于带有 dSYM 文件的 DWARF，您的存档 app.xcarchive（用于 AdHoc 分发）还包含在崩溃报告中对代码进行反向符号化所需的 dSYM 文件。因此，如果您需要它在归档您的应用程序以进行分发时对崩溃报告进行外部分析，您应该将 DWARF 与 dSYM 文件一起使用。在 OSX 的早期阶段，Apple 不想经历在其链接器中引入<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/DWARF">DWARF</a>支持的麻烦。他们为此目的创建了一个单独的链接器 (dsymutil)，它从目标文件中获取调试信息并将其放在一个普通的地方：一个 dSYM 包。</p>
<p>虽然 dSYM 捆绑包对发布构建很有用，但在开发过程中不需要它们。调试器可以从构建后仍然存在的中间目标文件中获取调试信息。</p>
<p>在 XCode 中，我们可以将构建的“调试信息格式”设置为“DWARF”而不是“DWARF with dSYM File”。</p>
<p>确保您设置Debug Information Format为始终为您的发布版本和未在模拟器上运行的调试版本创建 dSYM 文件。在 iOS 模拟器上运行时不需要创建它们。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0e87fa618eb4c8199c04f747020761f~tplv-k3u1fbpfcp-watermark.image" alt="Debug informatlon Format.png"></p>
<p>在 iOS 模拟器上运行时不应生成 dSYM 文件，但应为所有其他实例生成</p>
<h3 id="2-2-全模块优化-WMO"><a href="#2-2-全模块优化-WMO" class="headerlink" title="2.2. 全模块优化 (WMO)"></a>2.2. 全模块优化 (WMO)</h3><p>在 Xcode 中，我们可以选择三个优化级别：<em>None</em>、<em>Fast</em> 和 <em>Fast</em>、<em>Whole Module Optimization</em>。</p>
<p>使用 Whole Module Optimization 使编译速度非常快。但是选择快速或快速，整个模块优化将不允许开发人员调试应用程序。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269f1b2bab4d40b9b88a2b1091918f74~tplv-k3u1fbpfcp-watermark.image" alt="Faet, Whale.png"></p>
<h3 id="2-3-优化级别"><a href="#2-3-优化级别" class="headerlink" title="2.3 优化级别"></a>2.3 优化级别</h3><p>优化级别有两个不同的部分</p>
<p>1.Apple LLVM 9.0 Code Generation -&gt; Optimization Level -&gt; Debug <strong>GCC_OPTIMIZATION_LEVEL</strong><br>有6个优化级别。</p>
<p>GCC_OPTIMIZATION_LEVEL &#x3D;<br>fast（最快和积极的优化）<br>s（最快和最小）<br>3（最快）<br>2（更快）<br>1（快）<br>0（无）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e028956565440c904685d114381d00~tplv-k3u1fbpfcp-watermark.image" alt="0xyvuOAWqdaJKE5_l.png"></p>
<p>2.Swift Compiler Code Generation -&gt; Optimization Level -&gt; Debug <strong>SWIFT_OPTIMIZATION_LEVEL</strong></p>
<p>有3个优化级别SWIFT_OPTIMIZATION_LEVEL &#x3D;-Onone-O (Fast Single File Optimization)-Owholemodule (Fast, Whole Module Optimization)</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef603635d5db4b9491e1b7b32cecafbf~tplv-k3u1fbpfcp-watermark.image" alt="Optimization Leval.png"></p>
<p>使用<em>Whole Module Optimization</em>使编译速度非常快。但是选择快速或快速，整个模块优化将不允许开发人员调试应用程序。</p>
<h2 id="3-代码优化"><a href="#3-代码优化" class="headerlink" title="3.代码优化"></a>3.代码优化</h2><h3 id="3-1-优化代码"><a href="#3-1-优化代码" class="headerlink" title="3.1 优化代码"></a>3.1 优化代码</h3><p> 我们可以优化代码，这将有助于我们缩短编译时间。我们添加了其他链接器标志-warn-long-function-bodies &amp; -warn-long-expression-type-checking来识别编译时间过长的函数和表达式，现在我们需要手动优化这些表达式或函数.</p>
<ul>
<li>对类本身中扩展 v 的方法中的方法进行基准测试。</li>
<li>添加类型注释，以便编译器不需要推断类型。</li>
<li>避免三元运算符， <strong>?:</strong> 。</li>
<li>通过手动解包来避免使用 nil 合并运算符<strong>if let</strong>。</li>
<li>使用字符串插值而不是连接。</li>
</ul>
<h3 id="3-2-第三方依赖"><a href="#3-2-第三方依赖" class="headerlink" title="3.2 第三方依赖"></a>3.2 第三方依赖</h3><p>有一些非常流行的依赖管理技术&#x2F;工具：Cocoa Pod、Carthage、Swift Package Manager、git Submodule。</p>
<p>在 iOS 项目中处理 3rd 方依赖项的最常见方法是使用 CocoaPods。它使用简单，但如果您关心构建时间，则它不是最佳选择。</p>
<p>您可以使用的一种替代方法是<a target="_blank" rel="noopener" href="https://github.com/Carthage/Carthage">Carthage</a>。它比 CocoaPods 更难使用，但它会缩短您的构建时间。</p>
<h3 id="3-3-优化-CocoaPods"><a href="#3-3-优化-CocoaPods" class="headerlink" title="3.3 优化 CocoaPods"></a>3.3 优化 CocoaPods</h3><p>如果您使用 CocoaPods，您可以通过将以下内容添加到 Podfile 的末尾来优化所有依赖项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">post_install 执行 |installer| </span><br><span class="line"></span><br><span class="line">  installer.pods_project.targets.each 做|目标| </span><br><span class="line"></span><br><span class="line">    target.build_configurations.each 做 |config| </span><br><span class="line"></span><br><span class="line">      如果 config.name == &#x27;Debug&#x27; </span><br><span class="line"></span><br><span class="line">        config.build_settings[&#x27;OTHER_SWIFT_FLAGS&#x27;] = [&#x27;$(inherited)&#x27;, &#x27;-Onone&#x27;] </span><br><span class="line"></span><br><span class="line">        config.build_settings[&#x27;SWIFT_OPTIMIZATION_LEVEL&#x27;] = &#x27;-Owholemodule&#x27; </span><br><span class="line"></span><br><span class="line">      end </span><br><span class="line"></span><br><span class="line">    end </span><br><span class="line"></span><br><span class="line">  end </span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-对代码的小改动"><a href="#3-4-对代码的小改动" class="headerlink" title="3.4 对代码的小改动"></a>3.4 对代码的小改动</h3><ul>
<li>当您知道不需要覆盖声明时，请使用“final”。关键字final是对类、方法或属性的声明的限制，使得声明不能被覆盖。这意味着编译器可以发出直接函数调用而不是间接调用。</li>
<li>当不需要在文件外部访问声明时，使用“private”和“fileprivate”。将private或fileprivate关键字应用于声明会将声明的可见性限制在声明它的文件中。这允许编译器能够确定所有其他可能覆盖的声明。</li>
<li>在数组中使用值类型：在 Swift 中，类型可以分为两个不同的类别：值类型（结构、枚举、元组）和引用类型（类）。一个关键的区别是值类型不能包含在 NSArray 中。因此，当使用值类型时，优化器可以消除 Array 中的大部分开销，这些开销是处理数组支持 NSArray 的可能性所必需的。</li>
<li>其他…</li>
</ul>
<h1 id="二-编译生成中间产物CCache优化"><a href="#二-编译生成中间产物CCache优化" class="headerlink" title="二. 编译生成中间产物CCache优化"></a>二. 编译生成中间产物CCache优化</h1><p><a target="_blank" rel="noopener" href="https://github.com/ccache/ccache"><strong>https://github.com/ccache/ccache</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://ccache.dev/performance.html"><strong>https://ccache.dev/performance.html</strong></a></p>
<p>Ccache 是一个编译器缓存。它通过缓存以前的编译并检测何时再次进行相同的编译来<a target="_blank" rel="noopener" href="https://ccache.dev/performance.html">加速重新编译。</a></p>
<p>cache 的性能取决于很多因素，这使得很难预测给定用例的改进。如果预期命中率较低，则由于缓存未命中的开销（通常为 5%-20%，但启用依赖模式时仅为 1%-3%），使用 ccache 时可能会出现净性能损失). 此外，如果与构建工具（编译器、链接器等）使用的内存量相比构建机器的内存不足，则使用 ccache 可能会降低性能，因为 ccache 的缓存文件可能会刷新操作系统磁盘中的其他文件缓存。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5dfac365c1d4e90b1b94e9566e601c3~tplv-k3u1fbpfcp-watermark.image" alt="CCache流程.png"></p>
<p>优点：</p>
<ol>
<li>无侵入、无影响现有的业务的要求，无入侵、开发人员无感知。</li>
<li>在某些情况下能大幅度地提升编译速度。</li>
<li>不需要对项目作出大调整，只需部署相关环境和一些脚本支持。</li>
<li>不需要改变开发工具链。</li>
<li>同一个目录下，CCache 的缓存命中率相对稳定。</li>
</ol>
<p>存在些某问题：</p>
<ol>
<li>在未有缓存的情况下，首次打包编译的时间比原来的翻近一倍，原来20+min，首次将近40+min，在资源紧张的情况下，甚至是更多。</li>
<li>修改一些引用较多的文件（如公共库、底层库改动），容易造成大范围的缓存失效，速度会变得比原来未使用ccache时更慢。</li>
<li>多个项目相同的组件不支持缓存共享，有多个分支打包的需求，修改目录名称后，缓存即失效。</li>
<li>机器的Ccache有最大的缓存上限，且Debug&#x2F;Release区别缓存，多个项目、多个分支很容易超出上限，一台Ci机器同时支持多个项目会触发CCache清缓存。</li>
<li>对机器硬盘读写要求高，如不是全部固态硬盘，速度影响大。</li>
<li>CCache 不支持 Clang Modules，系统框架例如 AVFoundation、CoreLocation等， Xcode 不会再帮你自动引入，会导致编译失败。</li>
<li>CCache 不支持 PCH 文件</li>
<li>CCache 目前不支持 Swift</li>
</ol>
<h1 id="三-直接生成二进制编译"><a href="#三-直接生成二进制编译" class="headerlink" title="三. 直接生成二进制编译"></a>三. 直接生成二进制编译</h1><p>先看下编译流程，我们每次编译工程大概如下，那么如果能直接省略前边从预处理到生成二进制文件的过程，不就解决了编译时间的问题么。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51d7b2d4f216432d90ee99a13f596a3d~tplv-k3u1fbpfcp-watermark.image" alt="AST.png"></p>
<h2 id="1-cocoapods-binary"><a href="#1-cocoapods-binary" class="headerlink" title="1.cocoapods-binary"></a>1.cocoapods-binary</h2><p>cocoapods-binary 通过开关，在 pod insatll 的过程中进行 library 的预编译，生成 framework，并自动集成到项目中</p>
<p>整个预编译工作分成了三个阶段来完成：</p>
<ul>
<li>binary pod 的安装</li>
<li>binary pod 的预编译</li>
<li>binary pod 的集成</li>
</ul>
<p><strong>Binary Pod 的安装</strong></p>
<p>Binary Pod 的安装作是以 pre_install hook 作为入口，开始插件的运作。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6edd7df942a045278c08a021b230e0e6~tplv-k3u1fbpfcp-watermark.image" alt="pod install.webp"></p>
<p><strong>Binary Pod 的预编译</strong></p>
<p>cocoapods-binary 在下载 binary pod 源码前会先检查是否已经有预编译好的二进制包，如果没有缓存才会开始binary pod 的下载和预编译。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca440e32686345f7b40187e2978d91bf~tplv-k3u1fbpfcp-watermark.image" alt="oodinstall.webp"></p>
<p><strong>binary pod 的集成</strong></p>
<p>具体可以看 <a target="_blank" rel="noopener" href="https://github.com/leavez/cocoapods-binary">https://github.com/leavez/cocoapods-binary</a></p>
<p><strong>存在很多限制</strong></p>
<p>1.CocoaPods 在 1.7 以上版本修改了 framework 生成逻辑，不会把 bundle copy 至 framework，因此需要将 Pod 环境固定到 1.6.2；</p>
<p>2.pod 要支持 binary，header ref 需要变更为 #import &lt;&gt; 或者 @import 以符合 moduler 标准；</p>
<p>3.需要统一开发环境。如果项目支持 Swift，不同 compiler 编译产物有 Swift 版本兼容问题；</p>
<p>4.最终的 binary 体积比使用源码的时候大一点，不建议最终上传 Store</p>
<p>5.如果需要 debug 就需要切换回源码，或者通过 dSYM 映射来完成方法对定位。</p>
<p>6.适用于人数不多的中小型项目。一旦项目依赖库较多，可能就不太适用了，限制太多，同时对开发的要求和环境的一致性要求比较高。</p>
<h2 id="2-cocoapods-imy-bin（前提需要先实现组件化）"><a href="#2-cocoapods-imy-bin（前提需要先实现组件化）" class="headerlink" title="2.  cocoapods-imy-bin（前提需要先实现组件化）"></a>2.  cocoapods-imy-bin（前提需要先实现组件化）</h2><p><strong>优点：</strong></p>
<ol>
<li>无侵入、无影响现有的业务。</li>
<li>不影响未接入二进制化方案的业务团队，提供配置文件。 </li>
<li>只要项目能编译通过就制作，即使独立组件编译失败。</li>
<li>支持无二进制版本时，自动采用源码版本。</li>
<li>支持只需项目能编译通过就能制作二进制组件，无需再关心pod lint等。</li>
<li>支持pod bin local 命令一键自动化制作、上传、存储项目本地已经存在的二进制组件，可配合ci打包的编译产物使用。</li>
<li>支持指定依赖分支、支持:podspec &#x3D;&gt;’’, :git 方式的引用</li>
<li>支持同时 .a、Framework 静态库产出</li>
<li>支持archive时，根据Podfile自动获取podsepc依赖的库，无需强制去spec仓库拉取。</li>
<li>支持多套隔离环境，如Debug&#x2F;Release&#x2F;Dev配置，方便为Debug&#x2F;Release&#x2F;Dev各种环境提供专用二进制组件。</li>
<li>支持输出.a二进制组件制作binary.podsepc无需模板。</li>
<li>支持稳定的二进制组件，在上传二进制组件的binary.podsepc跳过pod lint验证，加快速度。</li>
<li>支持pod bin auto 命令一键自动化制作、上传、存储单个二进制组件</li>
<li>支持pod bin auto –all-make 命令一键自动化制作、上传、存储该项目下所有组件的二进制组件</li>
<li>支持 是否使用二进制文件、是否制作二进制文件和二进制&#x2F;源码调试功能的白名单设置</li>
<li>支持pod install&#x2F;update 多线程模式，加快pod过程，<strong>Pod速度提升80%+</strong> 。</li>
<li>支持pod bin install&#x2F;update 命令，实现无入侵修改Podfile内容，避免直接修改工程的Podfile文件而导致提交冲突、误提交。</li>
<li>支持pod bin code命令，实现二进制库不切换源码库、程序无需重新运行的调试能力</li>
</ol>
<p><strong>缺点：</strong></p>
<p><strong>这个方案的前提是实现组件化</strong></p>
<p>在实施组件私有化后，就真正实现了代码仓库隔离，各业务线同学都会在自己的业务组件内开发，需求开发完成后将 podspec 提交到私有源，壳工程执行 pod update 即可将新开发的业务组件更新下来，就可以直接打包提测了。其实组件拆分算得上是体力活，但这是二进制的基础，这个结构搭不好二进制将无从谈起。</p>
<h3 id="单私有源方案"><a href="#单私有源方案" class="headerlink" title="单私有源方案"></a>单私有源方案</h3><p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/373beffcc7b3467b82fb61b8d5723349~tplv-k3u1fbpfcp-watermark.image" alt="pod 私有库.png"></p>
<p>二进制目前市场上有单私有源、双私有源两种可行方案，下面对这两种方案进行下简单的说明：</p>
<p>单私有源指的是只有一个装 podspec 的私有仓库，也就是上面图中的 PrivateRepo 仓库。那么一个仓库怎么实现源码与二进制的切换呢？其实也很简单，通过在 podspec 配置环境变量即可，总结有如下几步：</p>
<ol>
<li>在 Class 同级目录下创建 Lib 文件夹，将二进制 framework 拷贝其中，并推送至远程仓库</li>
</ol>
<p> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">**├── Assets**</span><br><span class="line"></span><br><span class="line">**│   └── Media.xcassets**</span><br><span class="line"></span><br><span class="line">**│       ├── Contents.json**</span><br><span class="line"></span><br><span class="line">**│       └── cb_fx.imageset**</span><br><span class="line"></span><br><span class="line">**│           ├── Contents.json**</span><br><span class="line"></span><br><span class="line">**├── Classes**</span><br><span class="line"></span><br><span class="line">**│   ├── HelloWorld.h**</span><br><span class="line"></span><br><span class="line">**│   └── HelloWorld.m**</span><br><span class="line"></span><br><span class="line">**└── Lib**</span><br><span class="line"></span><br><span class="line">**└── HelloWorld.framework**</span><br><span class="line"></span><br><span class="line">**├── Headers -&gt; Versions/Current/Headers**</span><br><span class="line"></span><br><span class="line">**├── HelloWorld -&gt; Versions/Current/HelloWorld**</span><br><span class="line"></span><br><span class="line">**├── Resources -&gt; Versions/Current/Resources**</span><br><span class="line"></span><br><span class="line">**└── Versions**</span><br><span class="line"></span><br><span class="line">**├── A**</span><br><span class="line"></span><br><span class="line">**│   ├── Headers**</span><br><span class="line"></span><br><span class="line">**│   │   ├── HelloWorld.h**</span><br><span class="line"></span><br><span class="line">**│   │   ├── ClassA.h**</span><br><span class="line"></span><br><span class="line">**│   │   ├── ClassB.h**</span><br><span class="line"></span><br><span class="line">**│   │   └── ClassC.h**</span><br><span class="line"></span><br><span class="line">**│   ├── HelloWorld**</span><br><span class="line"></span><br><span class="line">**│   └── Resources**</span><br><span class="line"></span><br><span class="line">**│       └── HelloWorld.bundle**</span><br><span class="line"></span><br><span class="line">**│           ├── Assets.car**</span><br><span class="line"></span><br><span class="line">**│           └── Info.plist**</span><br><span class="line"></span><br><span class="line">**└── Current -&gt; A**</span><br></pre></td></tr></table></figure>

<ol>
<li>通过环境变量，修改 podspec 的 sourcefile 指向：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**if ENV[&#x27;IS_SOURCE&#x27;] || ENV[&quot;#&#123;s.name&#125;_SOURCE&quot;]**</span><br><span class="line"></span><br><span class="line">**s.source_files = &quot;#&#123;s.name&#125;/Classes/**/*&quot;**</span><br><span class="line"></span><br><span class="line">**else**</span><br><span class="line"></span><br><span class="line">**s.ios.vendored_frameworks = &quot;#&#123;s.name&#125;/Lib/#&#123;s.name&#125;.framework&quot;**</span><br><span class="line"></span><br><span class="line">**end**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>设置 preserve_paths</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**s.preserve_paths = &quot;#&#123;s.name&#125;/Lib/**/*.framework&quot;,&quot;#&#123;s.name&#125;/Classes/**/*&quot;**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>podspec 中配置 preserve_paths，确保缓存中同时存在源码和二进制的资源及文件，因为 pod 的缓存机制，如果不设置的话在源码和二进制切换时会产生文件的丢失，导致切换时会产生不可预知的问题。</p>
<ol start="3">
<li>将 podspec 发布到 PrivateRepo 即可。</li>
</ol>
<p>完成上面的配置，通过在终端输入：IS_SOURCE pod install 和 pod install 来安装源码和二进制 。如果想要某个库是源码，其他的库为二进制形式，以上图 HelloWorld 为例子，通过输入 HelloWorld_SOURCE pod install 即可让 HelloWorldrepo 为源码形式，其他的组件库为二进制形式。</p>
<p>虽然单私有源单版本的方案可以实现源码与二进制的转换，但是我们觉得这个方案存在以下不妥：</p>
<ol>
<li>如果想要对多个组件进行二进制源码的切换将会非常繁琐，pod 命令因为要在终端输入 SOURCE 的缘故也会变得非常长。</li>
<li>破坏了 pod 的缓存机制，pod 的缓存流程可以简单理解如下：</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5324d71671aa4fdfa9ecb77715efc63b~tplv-k3u1fbpfcp-watermark.image" alt="pod instal.png"></p>
<p>通过上面读取缓存的流程可以看出，如果组件本地只有源码的形式存在，会无法安装二进制，因为本地已经存在了就不会再去 git 上拉取二进制了。这个问题也可以解决，按照上图的思路，将一级和二级缓存删除掉，这样 pod 会直接去下载 git 上的组件进行安装。</p>
<p>考虑到团队内不可能每个人都对这些流程很熟悉的缘故，这会对大家日常工作影响较大，毕竟它对 Cocoapods 的缓存机制有所入侵，另外随着二进制版本增多，git 仓库也会越来越庞大，最终就有了双私有源方案。</p>
<h3 id="双私有源方案"><a href="#双私有源方案" class="headerlink" title="双私有源方案"></a>双私有源方案</h3><p>双私有源的方案是本篇的重点，cocoapods-bin 正是采用的这种方案，它指的是有两个装 podspec 的仓库，一个装源码的 podspec，例如前面说到的 PrivateRepo 仓库，另一个装二进制版本的 podspec，暂时将它起名叫 PrivateRepo_Bin，另外还需要一个静态服务器，用来存储二进制的 zip 包，供别人安装。</p>
<p>双私有源的方案相对单私有源来说稍复杂些，额外需要将二进制包上传到 zip 服务器中，再生成一个二进制版本的 podspec，将其发布到二进制私有源 。让团队的所有同学都来维护二进制版本的 podspec 和二进制 zip 包无疑会严重拖累大家的工作效率，cocoapods-bin 这类插件正是为了解决这些问题，后面会通过 cocoapods-core 源码和 cocoapods-bin 源码来分析二进制插件的背后原理。</p>
<p>源码 podspec 和二进制 podspec 的大致区别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;git&quot;: &quot;https://github.com/xxx/xxx.git&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;tag&quot;: &quot;0.1.0&quot;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;resource_bundles&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;xxx&quot;: [</span><br><span class="line"></span><br><span class="line">      &quot;xxx/Assets/**/*.xcassets&quot;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;source_files&quot;: &quot;xxx/Classes/**/*&quot;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;http&quot;: &quot;http://localhost:8080/frameworks/xxx/0.1.0/zip&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;type&quot;: &quot;zip&quot;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;resources&quot;: [</span><br><span class="line"></span><br><span class="line">    &quot;xxx.framework/Versions/A/Resources/*.bundle&quot;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;ios&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;vendored_frameworks&quot;: &quot;xxx.framework&quot;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>它们主要区别在 source_files 和 vendored_frameworks，将源码的 podspec 修改一下，通过 pod repo push PrivateRepo_Bin HelloMoto.podspec 命令将其发布到 PrivateRepo_Bin 仓库。双私有源的架构图如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d022f76261f34084ad636750576aad5a~tplv-k3u1fbpfcp-watermark.image" alt="pod  二进制.png"></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>iOS 有两种类型的静态库，一种是 .a 后缀，另一种是 .framework 后缀结尾，其实它们本质没有什么区别，都是被多个 .o 打包而成，只不过 .a 是一个纯二进制文件，需要配合 .h 和资源文件一起使用，.framework 内包含头文件和资源文件可以直接使用。但是引用 .framework 需要使用 &lt;&gt; 方式，.a 库可直接使用 “” ，具体使用那种格式可以酌情而定。</p>
<h3 id="二进制打包"><a href="#二进制打包" class="headerlink" title="二进制打包"></a>二进制打包</h3><p><a href="https://link.juejin.cn/?target=https://github.com/square/cocoapods-generate">cocoapods-generate</a></p>
<p>cocoapods-generate 是 cocoapods-packager 作者的另一个插件，它提供了构建工程的能力，和 cocoapods-packager 相比缺失了构建 framework 功能。但它有个好处，不依赖 git，可以直接根据提供的 podspec 文件在本地生成对应的工程。生成工程后，可以自定义打包脚本，使用 xcodebuild 相关命令构建对应二进制。开发 Cocoapods Plugin 的时候，配置上 Gemfile 依赖即可使用 cocoapods-generate：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">group :debug do</span><br><span class="line"></span><br><span class="line">    gem &#x27;ruby-debug-ide&#x27;</span><br><span class="line"></span><br><span class="line">    gem &#x27;debase&#x27;,&#x27;0.2.5.beta1&#x27;</span><br><span class="line"></span><br><span class="line">    gem &#x27;rake&#x27;,&#x27;13.0.0&#x27;</span><br><span class="line"></span><br><span class="line">    gem &quot;cocoapods&quot;, &#x27;1.9.3&#x27;</span><br><span class="line"></span><br><span class="line">    gem &quot;cocoapods-generate&quot;,&#x27;2.0.0&#x27;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行 bundle install 后，就可以直接在插件脚本内使用了：</p>
<h3 id="二进制上传"><a href="#二进制上传" class="headerlink" title="二进制上传"></a>二进制上传</h3><p>二进制上传主要是配置环境：</p>
<ol>
<li>二进制文件上传前需要先搭建 mongodb 数据库，用来存储二进制相关信息，例如包名、版本等。可以直接通过 Homebrew 执行 brew install <a href="mailto:&#109;&#x6f;&#110;&#103;&#x6f;&#x64;&#x62;&#45;&#99;&#x6f;&#x6d;&#x6d;&#x75;&#x6e;&#x69;&#x74;&#121;&#64;&#x34;&#x2e;&#x32;">&#109;&#x6f;&#110;&#103;&#x6f;&#x64;&#x62;&#45;&#99;&#x6f;&#x6d;&#x6d;&#x75;&#x6e;&#x69;&#x74;&#121;&#64;&#x34;&#x2e;&#x32;</a> 安装，推荐一个 mongodb 的可视化工具：<a href="https://link.juejin.cn/?target=https://robomongo.org/download?inappupdate">Robo 3T</a>。</li>
<li>下载 <a href="https://link.juejin.cn/?target=https://github.com/tripleCC/binary-server">binary-server</a> 代码，在 mongodb 跑起来之后，cd 到 binary-server 下，执行 npm install 和 npm start。</li>
<li>终端执行上传命令（详细参考 <a href="https://link.juejin.cn/?target=https://github.com/tripleCC/binary-server/blob/master/README.md">binary-server&#x2F;README.md</a>）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;上传url&#x27; -F &quot;name=#&#123;@spec.name&#125;&quot; -F &quot;version=#&#123;@spec.version&#125;&quot; -F &quot;annotate=#&#123;@spec.name&#125;_#&#123;@spec.version&#125;_log&quot; -F &quot;file=@#&#123;zip_file&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建二进制-podspec"><a href="#创建二进制-podspec" class="headerlink" title="创建二进制 podspec"></a>创建二进制 podspec</h3><p>了解二进制 podspec 生成之前，需要先了解 Cocoapods 是如何读取 podspec 文件的。在执行 pod install 后，Cocoapods 在解析依赖的过程中，根据 podfile.lock 指定的版本，构建 Specification（定义在 cocoapod-core 中用来描述 podspec 的对象） 对象。</p>
<p>cocoapods-core&#x2F;specification.rb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def self.from_file(path, subspec_name = nil)</span><br><span class="line"></span><br><span class="line">  #目标 .podspec 的本地路径</span><br><span class="line"></span><br><span class="line">  path = Pathname.new(path)</span><br><span class="line"></span><br><span class="line">  #校验 podspec 是否存在</span><br><span class="line"></span><br><span class="line">  unless path.exist?</span><br><span class="line"></span><br><span class="line">    raise Informative, &quot;No podspec exists at path `#&#123;path&#125;`.&quot;</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  #文件转为 utf-8 格式字符串</span><br><span class="line"></span><br><span class="line">  string = File.open(path, &#x27;r:utf-8&#x27;, &amp;:read)</span><br><span class="line"></span><br><span class="line">  # Work around for Rubinius incomplete encoding in 1.9 mode</span><br><span class="line"></span><br><span class="line">  if string.respond_to?(:encoding) &amp;&amp; string.encoding.name != &#x27;UTF-8&#x27;</span><br><span class="line"></span><br><span class="line">    string.encode!(&#x27;UTF-8&#x27;)</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  #执行或解析string</span><br><span class="line"></span><br><span class="line">  from_string(string, path, subspec_name)</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>cocoapods-core&#x2F;specification.rb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def self.from_string(spec_contents, path, subspec_name = nil)</span><br><span class="line"></span><br><span class="line">  path = Pathname.new(path).expand_path</span><br><span class="line"></span><br><span class="line">  spec = nil</span><br><span class="line"></span><br><span class="line">  case path.extname</span><br><span class="line"></span><br><span class="line">  #解析 .podspec</span><br><span class="line"></span><br><span class="line">  when &#x27;.podspec&#x27;</span><br><span class="line"></span><br><span class="line">    Dir.chdir(path.parent.directory? ? path.parent : Dir.pwd) do</span><br><span class="line"></span><br><span class="line">      #通过 eval 执行 Pod::Specification::DSL 内定义的方法</span><br><span class="line"></span><br><span class="line">      spec = ::Pod._eval_podspec(spec_contents, path)</span><br><span class="line"></span><br><span class="line">      unless spec.is_a?(Specification)</span><br><span class="line"></span><br><span class="line">        raise Informative, &quot;Invalid podspec file at path `#&#123;path&#125;`.&quot;</span><br><span class="line"></span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">   #解析 .json</span><br><span class="line"></span><br><span class="line">  when &#x27;.json&#x27;</span><br><span class="line"></span><br><span class="line">    #string 转为 hash 存储到 Specification 中</span><br><span class="line"></span><br><span class="line">    spec = Specification.from_json(spec_contents)</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">    raise Informative, &quot;Unsupported specification format `#&#123;path.extname&#125;` for spec at `#&#123;path&#125;`.&quot;</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  spec.defined_in_file = path</span><br><span class="line"></span><br><span class="line">  spec.subspec_by_name(subspec_name, true)</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此可以看出，podspec 文件支持两种扩展名，podspec 和 json，分别以不同的方式处理。</p>
<h3 id="关于二进制源码切换（美团方案）"><a href="#关于二进制源码切换（美团方案）" class="headerlink" title="关于二进制源码切换（美团方案）"></a>关于二进制源码切换（美团方案）</h3><p> <a href="https://link.juejin.cn/?target=https://github.com/MeetYouDevs/cocoapods-imy-bin">cocoapods-imy-bin</a>支持源码切换和调试，具体实现原理应该和美团<strong>zsource</strong>类似</p>
<p>Xcode 在编译 Debug 版本的二进制过程中，在二进制中某个字段存储了该二进制所对应的源码的文件地址。当我们在 Xcode 中打断点进行调试的时候，Xcode 会根据二进制中这个字段中存储的源码文件地址，打开对应的源码文件，并在 UI 上展示该源码文件</p>
<p>我们都知道苹果的 Mach-O 二进制文件使用的是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> 这种格式来存放调试相关的数据的。但因为我们很难从这个问题中提炼几个精确的关键词在搜索引擎中检索，所以很难通过简单的几次检索就获取到我们想要的答案：二进制这个字段的名称，在初期甚至无法确定这个字段应该是从 Mach-O 的资料中检索还是从 DWARF 的资料中检索。</p>
<p>通过实验，确定了二进制中源码文件的路径确实是用普通的字符来存储的；紧接着，我们用 MachOViewer 来查看二进制文件，以获取到更友好的二进制信息。利用 MachOViewer，我们可以发现这些信息都存在了二进制的 “__debug_str” Section 中。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202ac433d0d04db79a84ad1bc86e7611~tplv-k3u1fbpfcp-watermark.image" alt="foo.m.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/126540df2b7c46019c8edf1cca596925~tplv-k3u1fbpfcp-watermark.image" alt="d916cfe6bcbcd140837d44932a1a9d0c566355.jpg"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e70329f4c184683ae1a77ff035d5479~tplv-k3u1fbpfcp-watermark.image" alt="AT-nane(userscang3teorkspaceMeftuanZSourcezscVfewController.n.jpg"></p>
<p>AT_name</p>
<p>AT_comp_dir</p>
<p>通过实验，以及找到的这两个字段的描述，我们基本可以确定，即便工程是使用二进制构建，只要二进制 AT_name 字段中的路径存在对应的源码文件，App 一样可以使用源码进行断点调试。这种调试方式除了修改源码再次构建不能生效以外，其他的调试场景都和直接使用源码构建无异。考虑到我们日常的调试场景绝大多数都只需要查看其他组件的源码，并不需要修改，把这个功能工程化还是非常有意义的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>以上功能  <a href="https://link.juejin.cn/?target=https://github.com/MeetYouDevs/cocoapods-imy-bin">cocoapods-imy-bin</a> 基本上都已实现，自己也在项目中运用过，但是遇到了部分库 依赖的问题，导致业务库有些无法生成成功，最后只是尝试在三方库实现了如上流程，也算是一个探索过程。也希望能给大家带来一定的思路和启发。，有兴趣可以去研究下 <a href="https://link.juejin.cn/?target=https://github.com/MeetYouDevs/cocoapods-imy-bin">cocoapods-imy-bin</a> 源码实现。</p>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://ricardo-castellanos-herreros.medium.com/speeding-up-xcode-builds-97173cb1adba">https://ricardo-castellanos-herreros.medium.com/speeding-up-xcode-builds-97173cb1adba</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html">https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6903407900006449160">https://juejin.cn/post/6903407900006449160</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/02/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/02/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">flutter 生命周期详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-02T00:00:00+08:00">2023-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们在学习某个新技术的时候，首先至关重要的是要去了解他的一个整体流程如生命周期等，这样我们在学习和使用的过程才能对技术细节把控，以下主要讲解生命周期相关细节。</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><strong>先看图</strong>:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee71979562404a89aceeaecbbfa3eaf5~tplv-k3u1fbpfcp-watermark.image" alt="2-5.a59bef97.jpg"></p>
<p>Flutter的生命周期主要包含以下内容：</p>
<h2 id="1-initState-：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。"><a href="#1-initState-：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。" class="headerlink" title="1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。"></a>1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。</h2><p>initState：当 widget 第一次插入到 widget 树时会被调用，对于每一个State对象，Flutter 框架只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用BuildContext.dependOnInheritedWidgetOfExactType（该方法用于在 widget 树上获取离当前 widget 最近的一个父级InheritedWidget，关于InheritedWidget我们将在后面章节介绍），原因是在初始化完成后， widget 树中的InheritFrom widget也可能会发生变化，所以正确的做法应该在在build（）方法或didChangeDependencies()中调用它</p>
<h2 id="2-didChangeDependencies-：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。"><a href="#2-didChangeDependencies-：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。" class="headerlink" title="2.  didChangeDependencies()：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。"></a>2.  didChangeDependencies()：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。</h2><p>当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget ，然后在之后的build() 中Inherited widget发生了变化，那么此时InheritedWidget的子 widget 的didChangeDependencies()回调都会被调用。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter 框架会通知 widget 调用此回调。需要注意，组件第一次被创建后挂载的时候（包括重创建）对应的didChangeDependencies也会被调用</p>
<h2 id="3-build-：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。"><a href="#3-build-：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。" class="headerlink" title="3.  build()：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。"></a>3.  build()：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。</h2><p> build()：此回调读它主要是用于构建 widget 子树的，会在如下场景被调用：</p>
<ul>
<li><ol>
<li>在调用initState()之后。</li>
</ol>
</li>
<li><ol start="2">
<li>在调用didUpdateWidget()之后。</li>
</ol>
</li>
<li><ol start="3">
<li>在调用setState()之后。</li>
</ol>
</li>
<li><ol start="4">
<li>在调用didChangeDependencies()之后。</li>
</ol>
</li>
<li><ol start="5">
<li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其他位置之后。</li>
</ol>
</li>
</ul>
<h2 id="4-didUpdateWidget-：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。"><a href="#4-didUpdateWidget-：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。" class="headerlink" title="4.  didUpdateWidget()：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。"></a>4.  didUpdateWidget()：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。</h2><p>在 widget 重新构建时，Flutter 框架会调用widget.canUpdate来检测 widget 树中同一位置的新旧节点，然后决定是否需要更新，如果widget.canUpdate返回true则会调用此回调。正如之前所述，widget.canUpdate会在新旧 widget 的 key 和 runtimeType 同时相等时会返回true，也就是说在在新旧 widget 的key和runtimeType同时相等时didUpdateWidget()就会被调用。</p>
<h2 id="5-setState-：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。"><a href="#5-setState-：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。" class="headerlink" title="5.  setState()：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。"></a>5.  setState()：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。</h2><p>setState 在使用过程中可能会引起有些不必要的渲染可以使用</p>
<p><strong>ValueListenableBuilder</strong> 做优化</p>
<h2 id="6-deactivate-：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。"><a href="#6-deactivate-：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。" class="headerlink" title="6.  deactivate()：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。"></a>6.  deactivate()：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。</h2><p>当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter 框架会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。</p>
<h2 id="7-dispose-：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。"><a href="#7-dispose-：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。" class="headerlink" title="7.  dispose()：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。"></a>7.  dispose()：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。</h2><p>当 State 对象从树中被永久移除时调用；通常在此回调中释放资源。</p>
<h2 id="其他-reassemble"><a href="#其他-reassemble" class="headerlink" title="其他 reassemble()"></a>其他 reassemble()</h2><p>reassemble()：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</p>
<p>以上主要为整个生命周期的过程方法。</p>
<h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><p>布局过程4步骤</p>
<ol>
<li>父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。</li>
<li>子节点根据约束信息确定自己的大小（size）。</li>
<li>父节点根据特定布局规则（不同布局组件会有不同的布局算法）确定每一个子节点在父节点布局空间中的位置，用偏移 offset 表示。</li>
<li>递归整个过程，确定出每一个节点的大小和位置。</li>
</ol>
<p>可以看到，组件的大小是由自身决定的，而组件的位置是由父组件决定的。</p>
<p>Flutter 中的布局类组件很多，根据孩子数量可以分为单子组件和多子组件，下面我们先通过分别自定义一个单子组件和多子组件来直观理解一下Flutter的布局过程，之后会介绍一下布局更新过程和 Flutter 中的 Constraints（约束）。</p>
<h1 id="flutter-布局更新"><a href="#flutter-布局更新" class="headerlink" title="flutter 布局更新"></a>flutter 布局更新</h1><p><strong>对于更新边界是一个非常重要的知识点，对于我们实现高性能刷新绘制有很大的作用。</strong></p>
<h2 id="1-布局边界"><a href="#1-布局边界" class="headerlink" title="1.布局边界"></a>1.布局边界</h2><p>理论上，某个组件的布局变化后，就可能会影响其他组件的布局，所以当有组件布局发生变化后，最笨的办法是对整棵组件树 relayout（重新布局）！但是对所有组件进行 relayout 的成本还是太大，所以我们需要探索一下降低 relayout 成本的方案。实际上，在一些特定场景下，组件发生变化后我们只需要对部分组件进行重新布局即可（而无需对整棵树 relayout ）。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ebbdfb10924caaa2fd01207a0e4cad~tplv-k3u1fbpfcp-watermark.image" alt="Rondorview.png"></p>
<p><strong>上图</strong> 假如 Text3 的文本长度发生变化，则会导致 Text4 的位置和 Column2 的大小也会变化；又因为 Column2 的父组件 SizedBox 已经限定了大小，所以 SizedBox 的大小和位置都不会变化。所以最终我们需要进行 relayout 的组件是：Text3、Column2，这里需要注意：</p>
<ol>
<li>Text4 是不需要重新布局的，因为 Text4 的大小没有发生变化，只是位置发生变化，而它的位置是在父组件 Column2 布局时确定的。</li>
<li>很容易发现：假如 Text3 和 Column2 之间还有其他组件，则这些组件也都是需要 relayout 的。</li>
</ol>
<p>在本例中，Column2 就是 Text3 的 relayoutBoundary （重新布局的边界节点）。每个组件的 renderObject 中都有一个 _relayoutBoundary 属性指向自身的布局边界节点，如果当前节点布局发生变化后，自身到其布局边界节点路径上的所有的节点都需要 relayout。</p>
<p>那么，一个组件是否是 relayoutBoundary 的条件是什么呢？这里有一个原则和四个场景，原则是“组件自身的大小变化不会影响父组件”，如果一个组件满足以下四种情况之一，则它便是 relayoutBoundary ：</p>
<h3 id="1-当前组件父组件的大小不依赖当前组件大小时；"><a href="#1-当前组件父组件的大小不依赖当前组件大小时；" class="headerlink" title="1.  当前组件父组件的大小不依赖当前组件大小时；"></a>1.  当前组件父组件的大小不依赖当前组件大小时；</h3><p> 这种情况下父组件在布局时会调用子组件布局函数时并会给子组件传递一个 parentUsesSize 参数，该参数为 false 时表示父组件的布局算法不会依赖子组件的大小。</p>
<h3 id="2-组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。"><a href="#2-组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。" class="headerlink" title="2.  组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。"></a>2.  组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。</h3><p> 这样的话后代组件的大小变化就不会影响自身的大小了，这种情况组件的 sizedByParent 属性必须为 true。</p>
<h3 id="3-父组件传递给自身的约束是一个严格约束（固定宽高）；"><a href="#3-父组件传递给自身的约束是一个严格约束（固定宽高）；" class="headerlink" title="3.  父组件传递给自身的约束是一个严格约束（固定宽高）；"></a>3.  父组件传递给自身的约束是一个严格约束（固定宽高）；</h3><p> 这种情况下即使自身的大小依赖后代元素，但也不会影响父组件。</p>
<h3 id="4-组件为根组件；"><a href="#4-组件为根组件；" class="headerlink" title="4.  组件为根组件；"></a>4.  组件为根组件；</h3><p> Flutter 应用的根组件是 RenderView，它的默认大小是当前设备屏幕大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line">  _relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-markNeedsLayout"><a href="#2-markNeedsLayout" class="headerlink" title="2. markNeedsLayout"></a>2. markNeedsLayout</h2><p>当组件布局发生变化时，它需要调用 markNeedsLayout 方法来更新布局，它的功能主要有两个：</p>
<ol>
<li>将自身到其 relayoutBoundary 路径上的所有节点标记为 “需要布局” 。</li>
<li>请求新的 frame；在新的 frame 中会对标记为“需要布局”的节点重新布局。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void markNeedsLayout() &#123;</span><br><span class="line"></span><br><span class="line">   _needsLayout = true;</span><br><span class="line"></span><br><span class="line">  if (_relayoutBoundary != this) &#123; // 如果不是布局边界节点</span><br><span class="line"></span><br><span class="line">    markParentNeedsLayout(); // 递归调用前节点到其布局边界节点路径上所有节点的方法 markNeedsLayout</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;// 如果是布局边界节点 </span><br><span class="line"></span><br><span class="line">    if (owner != null) &#123;</span><br><span class="line"></span><br><span class="line">      // 将布局边界节点加入到 pipelineOwner._nodesNeedingLayout 列表中</span><br><span class="line"></span><br><span class="line">      owner!._nodesNeedingLayout.add(this); </span><br><span class="line"></span><br><span class="line">      owner!.requestVisualUpdate();//该函数最终会请求新的 frame</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="3-flushLayout"><a href="#3-flushLayout" class="headerlink" title="3. flushLayout()"></a>3. flushLayout()</h2><p>markNeedsLayout 执行完毕后，就会将其 relayoutBoundary 节点添加到 pipelineOwner._nodesNeedingLayout 列表中，然后请求新的 frame，新的 frame 到来时就会执行 drawFrame 方法（</p>
<p>flushLayout() 中会对之前添加到 _nodesNeedingLayout 中的节点重新布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void flushLayout() &#123;</span><br><span class="line"></span><br><span class="line">  while (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line"></span><br><span class="line">    final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line"></span><br><span class="line">    _nodesNeedingLayout = &lt;RenderObject&gt;[]; </span><br><span class="line"></span><br><span class="line">    //按照节点在树中的深度从小到大排序后再重新layout</span><br><span class="line"></span><br><span class="line">    for (final RenderObject node in dirtyNodes..sort((a,b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line"></span><br><span class="line">      if (node._needsLayout &amp;&amp; node.owner == this)</span><br><span class="line"></span><br><span class="line">        node._layoutWithoutResize(); //重新布局</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 flushLayout() 中刷新布局时要先对dirtyNodes 根据在树中的深度按照从小到大排序？从大到小不行吗？</p>
<ul>
<li>因为节点更新是从父节点到子节点以此跟新，如果颠倒了顺序会带来不必要的更新操作，大大影响了性能。</li>
</ul>
<h2 id="4-Layout流程"><a href="#4-Layout流程" class="headerlink" title="4. Layout流程"></a>4. Layout流程</h2><p>如果组件有子组件，则在 performLayout 中需要调用子组件的 layout 方法先对子组件进行布局， layout 的核心流程如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123;</span><br><span class="line"></span><br><span class="line">  RenderObject? relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  // 先确定当前组件的布局边界</span><br><span class="line"></span><br><span class="line">  if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line"></span><br><span class="line">    relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // _needsLayout 表示当前组件是否被标记为需要布局</span><br><span class="line"></span><br><span class="line">  // _constraints 是上次布局时父组件传递给当前组件的约束</span><br><span class="line"></span><br><span class="line">  // _relayoutBoundary 为上次布局时当前组件的布局边界</span><br><span class="line"></span><br><span class="line">  // 所以，当当前组件没有被标记为需要重新布局，且父组件传递的约束没有发生变化，</span><br><span class="line"></span><br><span class="line">  // 且布局边界也没有发生变化时则不需要重新布局，直接返回即可。</span><br><span class="line"></span><br><span class="line">  if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果需要布局，缓存约束和布局边界</span><br><span class="line"></span><br><span class="line">  _constraints = constraints;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 后面解释</span><br><span class="line"></span><br><span class="line">  if (sizedByParent) &#123;</span><br><span class="line"></span><br><span class="line">    performResize();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 执行布局</span><br><span class="line"></span><br><span class="line">  performLayout();</span><br><span class="line"></span><br><span class="line">  // 布局结束后将 _needsLayout 置为 false</span><br><span class="line"></span><br><span class="line">  _needsLayout = false;</span><br><span class="line"></span><br><span class="line">  // 将当前组件标记为需要重绘（因为布局发生变化后，需要重新绘制）</span><br><span class="line"></span><br><span class="line">  markNeedsPaint();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>简单来讲布局过程分以下几步：</p>
<ol>
<li>确定当前组件的布局边界。</li>
<li>判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局时需要同时满足三个条件：</li>
</ol>
<ul>
<li>当前组件没有被标记为需要重新布局。</li>
<li>父组件传递的约束没有发生变化。</li>
<li>当前组件的布局边界也没有发生变化时。</li>
</ul>
<ol start="3">
<li>调用 performLayout() 进行布局，因为 performLayout() 中又会调用子组件的 layout 方法，所以这时一个递归的过程，递归结束后整个组件树的布局也就完成了。</li>
<li>请求重绘。</li>
</ol>
<h3 id="sizedByParent"><a href="#sizedByParent" class="headerlink" title="sizedByParent"></a>sizedByParent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (sizedByParent) &#123;</span><br><span class="line"></span><br><span class="line">  performResize(); //重新确定组件大小</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sizedByParent 为 true 时表示：当前组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。前面我们说过，performLayout 中确定当前组件的大小时通常会依赖子组件的大小，如果 sizedByParent 为 true，则当前组件的大小就不依赖子组件大小了，为了逻辑清晰，Flutter 框架中约定，当sizedByParent 为 true 时，确定当前组件大小的逻辑应抽离到 performResize() 中，这种情况下 performLayout 主要的任务便只有两个：对子组件进行布局和确定子组件在当前组件中的布局起始位置偏移</p>
<p>通过一个 AccurateSizedBox 示例来演示一下 sizedByParent 为 true 时我们应该如何布局：</p>
<h3 id="AccurateSizedBox"><a href="#AccurateSizedBox" class="headerlink" title="AccurateSizedBox"></a>AccurateSizedBox</h3><p>Flutter 中的 SizedBox 组件会将其父组件的约束传递给其子组件，这也就意味着，如果父组件限制了最小宽度为100，即使我们通过 SizedBox 指定宽度为50，那也是没用的，<strong>因为 SizedBox的实现中会让 SizedBox 的子组件先满足 SizedBox 父组件的约束</strong>。还记得之前我们想在 AppBar 中限制 loading 组件大小的例子吗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AppBar(</span><br><span class="line"></span><br><span class="line">    title: Text(title),</span><br><span class="line"></span><br><span class="line">    actions: &lt;Widget&gt;[</span><br><span class="line"></span><br><span class="line">      SizedBox( // 尝试使用SizedBox定制loading 宽高</span><br><span class="line"></span><br><span class="line">        width: 20, </span><br><span class="line"></span><br><span class="line">        height: 20,</span><br><span class="line"></span><br><span class="line">        child: CircularProgressIndicator(</span><br><span class="line"></span><br><span class="line">          strokeWidth: 3,</span><br><span class="line"></span><br><span class="line">          valueColor: AlwaysStoppedAnimation(Colors.white70),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a97e15eff5244ee39741947dd5b2918a~tplv-k3u1fbpfcp-watermark.image" alt="尺寸限制类容器.png"></p>
<p>之所以不生效，是因为父组件限制了最小高度，当然我们也可以使用 UnconstrainedBox + SizedBox 来实现我们想要的效果，但是这里我们希望通过一个组件就能搞定，为此我们自定义一个 AccurateSizedBox 组件，它和 SizedBox 的主要区别是 AccurateSizedBox 自身会遵守其父组件传递的约束<strong>而不是让其子组件去满足AccurateSizedBox 父组件的约束</strong>，具体：</p>
<ol>
<li>AccurateSizedBox 自身大小只取决于父组件的约束和用户指定的宽高。</li>
<li>AccurateSizedBox 确定自身大小后，限制其子组件大小。</li>
</ol>
<p>根据上边的几个规则找到解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AccurateSizedBox extends SingleChildRenderObjectWidget &#123;</span><br><span class="line"></span><br><span class="line">  const AccurateSizedBox(&#123;</span><br><span class="line"></span><br><span class="line">    Key? key,</span><br><span class="line"></span><br><span class="line">    this.width = 0,</span><br><span class="line"></span><br><span class="line">    this.height = 0,</span><br><span class="line"></span><br><span class="line">    required Widget child,</span><br><span class="line"></span><br><span class="line">  &#125;) : super(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  final double width;</span><br><span class="line"></span><br><span class="line">  final double height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    return RenderAccurateSizedBox(width, height);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void updateRenderObject(context, RenderAccurateSizedBox renderObject) &#123;</span><br><span class="line"></span><br><span class="line">    renderObject</span><br><span class="line"></span><br><span class="line">      ..width = width</span><br><span class="line"></span><br><span class="line">      ..height = height;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RenderAccurateSizedBox extends RenderProxyBoxWithHitTestBehavior &#123;</span><br><span class="line"></span><br><span class="line">  RenderAccurateSizedBox(this.width, this.height);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  double width;</span><br><span class="line"></span><br><span class="line">  double height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 当前组件的大小只取决于父组件传递的约束</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  bool get sizedByParent =&gt; true;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // performResize 中会调用</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Size computeDryLayout(BoxConstraints constraints) &#123;</span><br><span class="line"></span><br><span class="line">    //设置当前元素宽高，遵守父组件的约束</span><br><span class="line"></span><br><span class="line">    return constraints.constrain(Size(width, height));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // @override</span><br><span class="line"></span><br><span class="line">  // void performResize() &#123;</span><br><span class="line"></span><br><span class="line">  //   // default behavior for subclasses that have sizedByParent = true</span><br><span class="line"></span><br><span class="line">  //   size = computeDryLayout(constraints);</span><br><span class="line"></span><br><span class="line">  //   assert(size.isFinite);</span><br><span class="line"></span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">    child!.layout(</span><br><span class="line"></span><br><span class="line">      BoxConstraints.tight(</span><br><span class="line"></span><br><span class="line">          Size(min(size.width, width), min(size.height, height))),</span><br><span class="line"></span><br><span class="line">      // 父容器是固定大小，子元素大小改变时不影响父元素</span><br><span class="line"></span><br><span class="line">      // parentUseSize为false时，子组件的布局边界会是它自身，子组件布局发生变化后不会影响当前组件</span><br><span class="line"></span><br><span class="line">      parentUsesSize: false,</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>上面代码有三点需要注意：</p>
<ol>
<li>我们的 RenderAccurateSizedBox 不再直接继承自 RenderBox，而是继承自 RenderProxyBoxWithHitTestBehavior，RenderProxyBoxWithHitTestBehavior 是间接继承自 RenderBox的，它里面包含了默认的命中测试和绘制相关逻辑，继承自它后就不用我们再手动实现了。</li>
<li>我们将确定当前组件大小的逻辑挪到了computeDryLayout 方法中，因为RenderBox 的 performResize 方法会调用 computeDryLayout ，并将返回结果作为当前组件的大小。按照Flutter 框架约定，我们应该重写computeDryLayout 方法而不是 performResize 方法，就像在布局时我们应该重写 performLayout 方法而不是 layout 方法；不过，这只是一个约定，并非强制，但我们应该尽可能遵守这个约定，除非你清楚的知道自己在干什么并且能确保之后维护你代码的人也清楚。</li>
<li>RenderAccurateSizedBox 在调用子组件 layout 时，将 parentUsesSize 置为 false，这样的话子组件就会变成一个布局边界。</li>
</ol>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AccurateSizedBoxRoute extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  const AccurateSizedBoxRoute(&#123;Key? key&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    final child = GestureDetector(</span><br><span class="line"></span><br><span class="line">      onTap: () =&gt; print(&quot;tap&quot;),</span><br><span class="line"></span><br><span class="line">      child: Container(width: 300, height: 300, color: Colors.red),</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return Row(</span><br><span class="line"></span><br><span class="line">      children: [</span><br><span class="line"></span><br><span class="line">        ConstrainedBox(</span><br><span class="line"></span><br><span class="line">          constraints: BoxConstraints.tight(Size(100, 100)),</span><br><span class="line"></span><br><span class="line">          child: SizedBox(</span><br><span class="line"></span><br><span class="line">            width: 50,</span><br><span class="line"></span><br><span class="line">            height: 50,</span><br><span class="line"></span><br><span class="line">            child: child,</span><br><span class="line"></span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        Padding(</span><br><span class="line"></span><br><span class="line">          padding: const EdgeInsets.only(left: 8),</span><br><span class="line"></span><br><span class="line">          child: ConstrainedBox(</span><br><span class="line"></span><br><span class="line">            constraints: BoxConstraints.tight(Size(100, 100)),</span><br><span class="line"></span><br><span class="line">            child: AccurateSizedBox(</span><br><span class="line"></span><br><span class="line">              width: 50,</span><br><span class="line"></span><br><span class="line">              height: 50,</span><br><span class="line"></span><br><span class="line">              child: child,</span><br><span class="line"></span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600937b6eb75418d8d88dfaf888aa15a~tplv-k3u1fbpfcp-watermark.image" alt="306.png"></p>
<p>可以发现，当父组件约束子组件大小宽高是100时，我们通过 SizedBox 指定 Container 大小是为 50×50 是不能成功的， 而通过 AccurateSized 时成功了。</p>
<p>这里需要提醒一下读者，如果一个组件的的 sizedByParent 为 true，那它在布局子组件时也是能将 parentUsesSize 置为 true 的，sizedByParent 为 true 表示自己是布局边界，而将 parentUsesSize 置为 true 或 false 决定的是子组件是否是布局边界，两者并不矛盾，这个不要混淆了。顺便提一点 Flutter 自带的 OverflowBox 组件的实现中，它的 sizedByParent 为 true，在调用子组件layout 方法时，parentUsesSize 传的是 true，具体通过OverflowBox 的实现源码可以找到原因。</p>
<h3 id="AfterLayout"><a href="#AfterLayout" class="headerlink" title="AfterLayout"></a>AfterLayout</h3><p>AfterLayout 可以在布局结束后拿到子组件的代理渲染对象 （RenderAfterLayout）， RenderAfterLayout 对象会代理子组件渲染对象 ，因此，通过RenderAfterLayout 对象也就可以获取到子组件渲染对象上的属性，比如件大小、位置等。</p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AfterLayout extends SingleChildRenderObjectWidget &#123;</span><br><span class="line"></span><br><span class="line">  AfterLayout(&#123;</span><br><span class="line"></span><br><span class="line">    Key? key,</span><br><span class="line"></span><br><span class="line">    required this.callback,</span><br><span class="line"></span><br><span class="line">    Widget? child,</span><br><span class="line"></span><br><span class="line">  &#125;) : super(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    return RenderAfterLayout(callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void updateRenderObject(</span><br><span class="line"></span><br><span class="line">      BuildContext context, RenderAfterLayout renderObject) &#123;</span><br><span class="line"></span><br><span class="line">    renderObject..callback = callback;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///组件树布局结束后会被触发，注意，并不是当前组件布局结束后触发</span><br><span class="line"></span><br><span class="line">  final ValueSetter&lt;RenderAfterLayout&gt; callback;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RenderAfterLayout extends RenderProxyBox &#123;</span><br><span class="line"></span><br><span class="line">  RenderAfterLayout(this.callback);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ValueSetter&lt;RenderAfterLayout&gt; callback;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">    super.performLayout();</span><br><span class="line"></span><br><span class="line">    // 不能直接回调callback，原因是当前组件布局完成后可能还有其他组件未完成布局</span><br><span class="line"></span><br><span class="line">    // 如果callback中又触发了UI更新（比如调用了 setState）则会报错。因此，我们</span><br><span class="line"></span><br><span class="line">    // 在 frame 结束的时候再去触发回调。</span><br><span class="line"></span><br><span class="line">    SchedulerBinding.instance</span><br><span class="line"></span><br><span class="line">        .addPostFrameCallback((timeStamp) =&gt; callback(this));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /// 组件在屏幕坐标中的起始点坐标（偏移）</span><br><span class="line"></span><br><span class="line">  Offset get offset =&gt; localToGlobal(Offset.zero);</span><br><span class="line"></span><br><span class="line">  /// 组件在屏幕上占有的矩形空间区域</span><br><span class="line"></span><br><span class="line">  Rect get rect =&gt; offset &amp; size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码有三点需要注意：</p>
<ol>
<li>callback 调用时机不是在子组件完成布局后就立即调用，原因是子组件布局完成后可能还有其他组件未完成布局，如果此时调用callback，一旦 callback 中存在触发更新的代码（比如调用了 setState）则会报错。因此我们在 frame 结束的时候再去触发回调。</li>
<li>RenderAfterLayout 的 performLayout方法中直接调用了父类 RenderProxyBox 的 performLayout方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">  if (child != null) &#123;</span><br><span class="line"></span><br><span class="line">    child!.layout(constraints, parentUsesSize: true);</span><br><span class="line"></span><br><span class="line">    size = child!.size;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    size = computeSizeForNoChild(constraints);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到是直接将父组件传给自身的约束传递给子组件，并将子组件的大小设置为自身大小。也就是说 RenderAfterLayout 的大小和其子组件大小是相同的</p>
<p>我们定义了 offset 和 rect 两个属性，它们是组件相对于屏幕的的位置偏移和占用的矩形空间范围。但是实战中，我们经常需要获取的是子组件相对于某个父级组件的坐标和矩形空间范围，这时候我们可以调用 RenderObject 的localToGlobal 方法，比如下面的的代码展示了Stack中某个子组件获取相对于Stack 的矩形空间范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget build(context)&#123;</span><br><span class="line"></span><br><span class="line">  return Stack(</span><br><span class="line"></span><br><span class="line">    alignment: AlignmentDirectional.topCenter,</span><br><span class="line"></span><br><span class="line">    children: [</span><br><span class="line"></span><br><span class="line">      AfterLayout(</span><br><span class="line"></span><br><span class="line">        callback: (renderAfterLayout)&#123;</span><br><span class="line"></span><br><span class="line">         //我们需要获取的是AfterLayout子组件相对于Stack的Rect</span><br><span class="line"></span><br><span class="line">         _rect = renderAfterLayout.localToGlobal(</span><br><span class="line"></span><br><span class="line">            Offset.zero,</span><br><span class="line"></span><br><span class="line">            //找到 Stack 对应的 RenderObject 对象</span><br><span class="line"></span><br><span class="line">            ancestor: context.findRenderObject(),</span><br><span class="line"></span><br><span class="line">          ) &amp; renderAfterLayout.size;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        child: Text(&#x27;Flutter@wendux&#x27;),</span><br><span class="line"></span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>Constraints（约束）主要描述了最小和最大宽高的限制，理解组件在布局过程中如何根据约束确定自身或子节点的大小对我们理解组件的布局行为有很大帮助，现在我们就通过一个实现 200*200 的红色 Container 的例子来说明。为了排除干扰，我们让根节点（RenderView）作为 Container 的父组件，我们的代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Container(width: 200, height: 200, color: Colors.red)</span><br></pre></td></tr></table></figure>

<p>但实际运行之后，你会发现整个屏幕都变成了红色！为什么呢？我们看看 RenderView 的布局实现：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line"></span><br><span class="line">void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">  //configuration.size 为当前设备屏幕</span><br><span class="line"></span><br><span class="line">  _size = configuration.size; </span><br><span class="line"></span><br><span class="line">  if (child != null)</span><br><span class="line"></span><br><span class="line">    child!.layout(BoxConstraints.tight(_size)); //强制子组件和屏幕一样大</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要介绍一下两种常用的约束：</p>
<ol>
<li>宽松约束：不限制最小宽高（为0），只限制最大宽高，可以通过 BoxConstraints.loose(Size size) 来快速创建。</li>
<li>严格约束：限制为固定大小；即最小宽度等于最大宽度，最小高度等于最大高度，可以通过 BoxConstraints.tight(Size size) 来快速创建。</li>
</ol>
<p>可以发现，RenderView 中给子组件传递的是一个严格约束，即强制子组件大小等于屏幕大小，所以 Container 便撑满了屏幕。那我们怎么才能让指定的大小生效呢？标准答案就是<strong>引入一个中间组件，让这个中间组件遵守父组件的约束，然后对子组件传递新的约束</strong>。对于这个例子来讲，最简单的方式是用一个 Align 组件来包裹 Container：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@override</span><br><span class="line"></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">  var container = Container(width: 200, height: 200, color: Colors.red);</span><br><span class="line"></span><br><span class="line">  return Align(</span><br><span class="line"></span><br><span class="line">    child: container,</span><br><span class="line"></span><br><span class="line">    alignment: Alignment.topLeft,</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Align 会遵守 RenderView 的约束，让自身撑满屏幕，然后会给子组件传递一个宽松约束（最小宽高为0，最大宽高为200），这样 Container 就可以变成 200 * 200 了。</p>
<p>当然我们还可以使用其他组件来代替 Align，比如 UnconstrainedBox，但原理是相同的.</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> flutter 的布局流程</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce14d1a9b7b49c591722d6cefd68c93~tplv-k3u1fbpfcp-watermark.image" alt="saz&#39;s.png"></p>
<p><strong>在进行布局的时候，Flutter 会以 DFS（深度优先遍历）方式遍历渲染树，并 <strong>将限制以自上而下的方式</strong> 从父节点传递给子节点。子节点若要确定自己的大小，则 <strong>必须</strong> 遵循父节点传递的限制。子节点的响应方式是在父节点建立的约束内 <strong>将大小以自下而上的方式</strong> 传递给父节点。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/02/Pod-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/02/Pod-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Pod 二进制实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-02T00:00:00+08:00">2022-11-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="pod二进制详细步骤"><a href="#pod二进制详细步骤" class="headerlink" title="pod二进制详细步骤"></a>pod二进制详细步骤</h2><h3 id="使用步骤流程"><a href="#使用步骤流程" class="headerlink" title="使用步骤流程"></a>使用步骤流程</h3><p>这个流程适用于所有符合条件的工程 包括主工程 或者 能独立运行的pod私有库</p>
<p>源码地址：</p>
<p><a href="mailto:git@git.zuoyebang.cc">git@git.xxx.cc</a>:native&#x2F;XXSpecs.git</p>
<p>二进制私有源地址：</p>
<p><a href="mailto:git@git.zuoyebang.cc">git@git.xxx.cc</a>:XXX_all_lib&#x2F;XXBinarySpecs.git</p>
<p>二进制服务器地址：</p>
<p><a target="_blank" rel="noopener" href="http://10.254.12.244:9090/frameworks/%25s/%25s/zip">http://10.254.12.244:9090/frameworks/%s/%s/zip</a>   (打包机配置的环境)</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/321afe3ddbf747708146f007ae4f5187~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="一-环境配置"><a href="#一-环境配置" class="headerlink" title="一.环境配置"></a>一.环境配置</h2><p>二进制服务器搭建</p>
<h3 id="1-mongodb"><a href="#1-mongodb" class="headerlink" title="1.mongodb"></a>1.mongodb</h3><h4 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580478a0d813480caec2bcd62aa2134b~tplv-k3u1fbpfcp-watermark.image" alt="舞入 usrlocal.png"></p>
<p>当创建&#x2F;data&#x2F;db 可能会遇到权限问题，直接手动在该目录下新建data和db文件加解决</p>
<h4 id="启动monogo"><a href="#启动monogo" class="headerlink" title="启动monogo"></a>启动monogo</h4><p>sudo mongod –dbpath&#x3D;&#x2F;Users&#x2F;xxx&#x2F;data&#x2F;db(这个路径为数据库存储的目录，你在哪里创建就指向哪里) 来启动mongod</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4636b78584ee46ce8adfd57bd985a903~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="开启-node-js-服务"><a href="#开启-node-js-服务" class="headerlink" title="开启 node.js 服务"></a>开启 node.js 服务</h4><p>开启 node.js 服务，保证mongo服务已经开启(最终保存静态库资源)</p>
<p>1.进入binary-server 目录 执行npm install 成功后 npm start 启动服务器(app.js 为入口文件，可以设置ip地址和端口号)</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f07129ba891d48dbaee917575248a790~tplv-k3u1fbpfcp-watermark.image" alt="YYModel.png"></p>
<p>2.如果遇到端口被占用就先关闭占用的端口</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3707f0a3a2c486db58772675397b15f~tplv-k3u1fbpfcp-watermark.image" alt="binary-server - -zsh - 80x24.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d1584742e6e4f3aa76fe80e9f71122b~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 9.png"></p>
<p>3.再次启动，打开浏览器访问对应端口地址，验证是否成功开启，页面访问正常为启动成功</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b93fb2e3f59f4792b02043798e8a6182~tplv-k3u1fbpfcp-watermark.image" alt="conplete 1op of this run can be found 1n.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec92a54ad9574254970960419dade165~tplv-k3u1fbpfcp-watermark.image" alt="© localhost8081frameworks.png"></p>
<h3 id="2-创建一个二进制私有源"><a href="#2-创建一个二进制私有源" class="headerlink" title="2.创建一个二进制私有源"></a>2.创建一个二进制私有源</h3><p><a target="_blank" rel="noopener" href="https://git.zuoyebang.cc/yike_all_lib/YKBinarySpecs">https://git.zuoyebang.cc/yike_all_lib/YKBinarySpecs</a></p>
<p>主要保存二进制资源的版本信息和对应的资源地址  (如zip包的获取地址)</p>
<h4 id="本地私有源"><a href="#本地私有源" class="headerlink" title="本地私有源"></a>本地私有源</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/858651bda2ba43059165c4cd1e3f9af4~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 13.png"></p>
<p>私有源json数据，里边对应私有源的静态库zip下载地址和一些信息</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1f58886e0e349358324600748387946~tplv-k3u1fbpfcp-watermark.image" alt="nane“Brotl1”,.png"></p>
<h3 id="3-安装打包插件"><a href="#3-安装打包插件" class="headerlink" title="3.安装打包插件"></a>3.安装打包插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods-imy-bin</span><br></pre></td></tr></table></figure>

<h3 id="4-工程需要的一些配置文件"><a href="#4-工程需要的一些配置文件" class="headerlink" title="4.工程需要的一些配置文件"></a>4.工程需要的一些配置文件</h3><p>目前为了简化流程通过主工程制作，最优的情况应该是 在每个pod库里边这样配置，但是由于目前大部分pod库不能独立编译，所以此插件是支持只 要主工程通过podspec生成 依赖模块，就可以生成podspec里边所有依赖的二进制文件</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbace522a3564e128d0b1c55ce0554d4~tplv-k3u1fbpfcp-watermark.image" alt="000.png"></p>
<h4 id="1-BinArchive-json"><a href="#1-BinArchive-json" class="headerlink" title="(1)BinArchive.json"></a>(1)BinArchive.json</h4><p>为制作二进制的白名单配置，可以忽略那些库不制作白名单，或者那些库不支持也可以放进去</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a83254b24b4457a15b0f0058caf5a1~tplv-k3u1fbpfcp-watermark.image" alt="archive-wnite-pod-11st 制作二週期自名筆®.png"></p>
<h4 id="2-podfile-local"><a href="#2-podfile-local" class="headerlink" title="(2)podfile_local"></a>(2)podfile_local</h4><p>此文件只是改插件为了区分本地依赖的库，实际情况可以不用</p>
<p>声明插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin &#x27;cocoapods-imy-bin&#x27;</span><br></pre></td></tr></table></figure>
<p>使用二进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_binaries!</span><br></pre></td></tr></table></figure>
<p>设置使用源码的库白名单(可选)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_use_source_pods</span><br></pre></td></tr></table></figure>


<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/500bfd87c46b48b4b59ff3eb729421bb~tplv-k3u1fbpfcp-watermark.image" alt="Podfilelocal.png"></p>
<h4 id="3-主工程-podspec"><a href="#3-主工程-podspec" class="headerlink" title="(3)主工程.podspec"></a>(3)主工程.podspec</h4><p>哪些需要打成二进制的库，就添加进去，真实情况生成二进制最好一个一个打，因为多个同时生成可能会出错，具体需要看错误信息，以下为目前 能制作二进制的库文件</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f754938aac4ea982b37bebd65607ce~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="二-开始使用"><a href="#二-开始使用" class="headerlink" title="二.开始使用"></a>二.开始使用</h2><h3 id="1-添加私有库到本地"><a href="#1-添加私有库到本地" class="headerlink" title="1.添加私有库到本地"></a>1.添加私有库到本地</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add xxBinarySpecs  https://git.xxBinarySpecs.git</span><br></pre></td></tr></table></figure>
<h3 id="2-配置打包变量"><a href="#2-配置打包变量" class="headerlink" title="2.配置打包变量"></a>2.配置打包变量</h3><p>如果是m1 电脑 pod 命令 需要加上arch -x86_64</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arch -x86_64)pod bin init</span><br></pre></td></tr></table></figure>
<ol>
<li> 配置私有库地址</li>
<li> 配置二进制私有源地址</li>
<li> 配置二进制服务器地址</li>
<li> 配置打包二进制的格式 目前就验证了zip，其他格式未验证</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620f246e88b14d9f8b5a9e89766ef0e8~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 19.png"></p>
<h3 id="3-开始制作二进制"><a href="#3-开始制作二进制" class="headerlink" title="3.开始制作二进制"></a>3.开始制作二进制</h3><p>注意项目根目录的homework.spec文件为需要生成二进制的库，最好一个一个打，因为把所有的库同时打会出现依赖问题，不好查找原因，此外某些 库最好指定版本号，不然生成的二进制对应不上工程podfile指定的版本</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d815f5daca94a509842e7d93a438d43~tplv-k3u1fbpfcp-watermark.image" alt="s.dependency.png"></p>
<p>(1)(arch -x86_64)pod bin auto –all-make</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ba271193db9431e883dfc9c1f2381ca~tplv-k3u1fbpfcp-watermark.image" alt="wit. Tre priottne aiseBteere weesle.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/946ee37142954f37a2b9f3c1c011f396~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 22.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9669da8d4ae8491384ea10de2758ca03~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 24.png"></p>
<p>(2)最终会自动编译完成转换成zip，同时生成对应版本的spec文件上传到二进制私有源和二进制服务器</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c17e7ce0e84c3791f9bab177d5f7b2~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 25.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2e0434001b847f69f6fcb94e636fd8b~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 26.png"></p>
<p>(3)同步二进制到工程中</p>
<p> 把xxx.spec中的注释的库都放开，目前测试发现如果不放开可能有些库同步不过来(此步骤可选)</p>
<p> 需要update 不然二进制库更新不过来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arch -x86_64)pod bin update --no-repo-update</span><br></pre></td></tr></table></figure>
<p>(4)最终如下生成.a</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f15a2ff3dd0d4b6185ed45ce51eebb91~tplv-k3u1fbpfcp-watermark.image" alt="252.png"></p>
<h2 id="三-结果对比"><a href="#三-结果对比" class="headerlink" title="三.结果对比"></a>三.结果对比</h2><p>目前只是把基础库和第三方库大部分库生成了.a ,业务库由于依赖过多，加上不能独立编译，因此目前无法生成</p>
<p>通过对比,编译耗时优化了20s左右(之前测试是190s)</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c96ef44e7cd44bd694458dfc52f7e632~tplv-k3u1fbpfcp-watermark.image" alt="Succeeded I 178.659s.png"></p>
<p>TODO:</p>
<p>此插件目前也存在一些问题，可能使用过程会遇到一些问题，大部分在pod bin auto 的时候出现，具体问题需要看具体原因了。   此库的源码默认应该安装在目录  &#x2F;Library&#x2F;Ruby&#x2F;Gems&#x2F;2.6.0&#x2F;gems&#x2F;cocoapods-imy-bin-0.3.1.3 有熟悉ruby的可以看看具体实现。</p>
<p><strong>问题list</strong></p>
<p>1.不支持spec声明FrameWork ，lipo合并静态库不支持FrameWork会出现问题</p>
<p>2.遇到执行pod bin auto 生成.a 出现搜索源码spec错误，如源码tag版本过多，超出搜索限制 json被截取导致出错</p>
<p><a target="_blank" rel="noopener" href="https://docs.github.com/cn/rest/search">https://docs.github.com/cn/rest/search</a></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a42bda23d92445cba6600958389f4bb~tplv-k3u1fbpfcp-watermark.image" alt="1E FTOr.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/139894c3622e4dc091dfcb130737b561~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 30.png"><br>3.遇到编译错误就搜索 关键字 1 error 看看是否是依赖某些库没有声明打成二进制，如果有就在xxx.podspec 里边添加对应库的依赖，前提 是此库支持打成二进制</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c3dccbf719d430480ecef8a256b783d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/01/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/01/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">编译和链接浅析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-01T00:00:00+08:00">2022-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-解释语言和编译语言差别"><a href="#1-解释语言和编译语言差别" class="headerlink" title="1.解释语言和编译语言差别"></a>1.解释语言和编译语言差别</h1><h3 id="编译语言"><a href="#编译语言" class="headerlink" title="编译语言"></a>编译语言</h3><p>把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1ef403d063841e3a3ac3060483c2356~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="解释性语言"><a href="#解释性语言" class="headerlink" title="解释性语言"></a>解释性语言</h3><p>把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d055131b3d432cab78af4739363d79~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="2-程序是怎么运行起来的"><a href="#2-程序是怎么运行起来的" class="headerlink" title="2.程序是怎么运行起来的"></a>2.程序是怎么运行起来的</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux下，可以直接使用GCC来编译Hello World程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>上述过程分解如下</p>
<ul>
<li>预编译（预处理） </li>
<li>编译 </li>
<li>汇编 </li>
<li>链接</li>
</ul>
<p>GCC 编译过程分解<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50657750c10a4526836813b508355374~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="3-编译流程"><a href="#3-编译流程" class="headerlink" title="3.编译流程"></a>3.编译流程</h1><blockquote>
<p>3.1 预编译（预处理）编译 汇编 链接</p>
</blockquote>
<h2 id="1-预编译（预处理）"><a href="#1-预编译（预处理）" class="headerlink" title="1.预编译（预处理）"></a>1.预编译（预处理）</h2><p>预编译步骤将源代码文件<code>hello.c</code>以及相关头文件，如：<code>stdio.h</code>等预编译生成一个.i文件。对于C++程序，其源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，预编译生成.ii文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i  (-E 表示只进行预编译）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cpp hello.c &gt; hello.i </span><br></pre></td></tr></table></figure>

<p>过程如下</p>
<p><strong>预编译</strong>主要处理源代码中的以“#”开始的预编译指令，如：“#include”、“#define”等，其主要处理规则如下：</p>
<ul>
<li>将所有的“#define”删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，如：“#if”、“#ifdef”、“#else”、“#endif”。</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，因为被包含的文件可能还包含其他文件。</li>
<li>删除所有的注释“&#x2F;&#x2F;”和“&#x2F; **&#x2F;”。</li>
<li>添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的#pragma编译器指令，因为编译器须要试用他们。</li>
</ul>
<p>预编译生成的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p>
<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>编译</strong>就是把预处理生成的文件进行一系列词法分析、语法分析、语义分析、优化，生成相应的汇编代码文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一。</p>
<p>编译步骤相当于执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ gcc -S hello.i -o hello.s </span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. $ gcc -S hello.c -o hello.s </span><br></pre></td></tr></table></figure>


<p>现在版本的GCC把预编译和编译两个步骤合并成了一个步骤，使用一个叫cc1的程序来完成。该程序位于“<code>/usr/lib/gcc/x86_64-linux-gnu/4.8/</code>”，我们可以直接调用cc1来完成它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c</span><br></pre></td></tr></table></figure>

<p>事实上，对于不同的语言，预编译与编译的程序是不同的，如下所示：</p>
<ul>
<li>C：<strong>cc1</strong></li>
<li>C++：<strong>cc1plus</strong></li>
<li>Objective-C：<strong>cc1obj</strong></li>
<li>Fortran：<strong>f771</strong></li>
<li>Java：<strong>jc1</strong></li>
</ul>
<p>GCC是对这些后台程序的封装，它会根据不同的参数来调用预编译程序cc1、汇编器as、链接器ld。</p>
<h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3.汇编"></a>3.汇编</h2><p><strong>汇编</strong>就是将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。汇编过程相对于编译比较简单，其没有复杂的语法、语义，也无需做指令优化，只是根据汇编指令和机器指令的对照表进行翻译。</p>
<p>汇编步骤相当执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o </span><br></pre></td></tr></table></figure>

<p>或</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c -o hello.o </span><br></pre></td></tr></table></figure>

<p>GCC本质上是调用汇编器as来完成汇编步骤的，我们可以直接调用as来完成该步骤：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure>


<h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h2><p>最早的纸片机器 -&gt;汇编语言-&gt;高级语言</p>
<p>为了更好地理解计算机程序的编译和链接的过程，我们简单地回顾计算机程序开发的历<br>史<br>一定会非常有益。计算机的程序开发并非从一开始就有着这么复杂的白动化编译、链接过<br>程。原始的链接概念远在高级程序语言发明之前就已经存在了，在最开始的时候，程序员（当<br>时程序员的概念应该跟现在相差很大了，先把一个程序在纸上写好，当然当时没有很高级的<br>语言，用的都是机器语言，甚至连汇编诺言都没有。当程序须委被运行时，程序员人工将他<br>写的程序写入到存储设各上，最原始的存储设备之一就是纸带，即在纸岸上打相应的孔。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73083cd119fa4b02b3cebd8305d310b6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>现在问题来了，程序并不是一写好就永远不变化的，它可能会经常被修改。比如我们在<br>第1条指令之后、第5条指令之前插入了一条或多条指令，那么第5条指令及后面的指令的<br>位貴将会相应地往后移动，原先第一条指令的低4位的数字将需要相应地调整。在这个过程<br>中，程序员需要人工重新计算每个子程序或跳转的目标地址。当程序修改的时候，这此位置<br>都要重新计算，十分繁琐又耗时，并且很容易出错。这种重新计算各个目标的地址过程被叫<br>做重定位 (Relocation）。</p>
<p>如果我们有多条纸带的程序，这些程序之间可能会有类似的跨纸带之间的跳转，这种程<br>序经常修改导致跳转目标地址变化在程序拥有多个模块的时候更为严重。人工鄉定进行指令<br>的修正以确保所有的跳转目标地址都正确，在程序规模越水越人以后变得越来越复杂和繁琐。<br>没办法，这种黑暗的程序员生活是没有办法容忍的。先驱者发明了汇编语言，这相比机<br>器语言米说是个很大的进步。汇编语言使用接近人类的各种符号和标记来帮助记忆，比如指<br>令采用两个或三个字母的缩写，记佳“imp”比记住 0001xxxX 是跳转(iump）指令容易得<br>名了：汇编语言还可以使用符号来标记位置，比如一个符号“divide”表示一个除法子程序<br>的起始地址，比记住从某个位置开始的第几条指令是除法子程序方便得多。最重要的足，这<br>种符号的方法使得人们从具体的指令地址中逐步解放出来。比如前面纸带程序中，我们把刚<br>开始第5条指令开始的子程序命名为“foo”，那么第一条指令的汇编就是：<br>jmp foo<br>当然人们可以使用这种符号命名子程序或跳转目标以后，不管这个“foo”之前插入或<br>滅少了多少条指令导致 “f00”目标地址发生了什么变化，汇编器在每次汇编程序的时候会<br>重新计算“foo”这个符号的地址，然后把所有引用到“foo”的指令修正到这个正确的地址。<br>整个过程不需要人工参与，对于一个有成百上千个类似的符号的程序，程序员终于摆脱了这<br>种低级的繁琐的调整地址的工作，用一句政治口号来说叫做“极大地解放了生产力”。符号<br>(Svmbol）这个概念随着汇编话言的普及迅凍被伸用，它用来表示一个地址．这个协址可<br>能是一段子程序（后来发展成函数）的起始地址，<br>也可以是一个变量的起始地址。</p>
<p>有了汇编语言以后，生产力大大提高了，随之而来的是软件的规模也开始日渐庞大。这<br>时程序的代码量也已经开始快速地膨账，导致人们要开始考愁将不同功能的代码以一定的方<br>式组织起米，使得更加容易阅读和理解，以便于日后修改和重复使用。自然而然，人们开始<br>将代码按照功能或性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其<br>他结构米组织。这个在现代的软件源代码组织中很常见，比如在 C语言中，最小的单位是</p>
<p>变量和函数，若干个变量和两数组成一个模块，存放在一个“c”的源代码文件里，然后这<br>些源代码文件按照目录结构来组织。在比较高级的语言中，如Java 中，每个类是一个基本<br>的模块，若干个类模块组成一个包（Package），若干个包组合成一个程序。<br>在现代软件开发过程中，软件的规模往往都很大，动辄数百万行代码，如果都放在-<br>模块肯定无法想象。所以现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖<br>又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读<br>理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等，</p>
<p>在现代软件开发过程中，软件的规模往往都很大，动辄数百万行代码，如果都放在一个<br>模块肯定无法想象。所以现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖<br>又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、<br>理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。<br>在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是<br>须解决的问题。模块之问如何组合的问题可以归结为模块之间如何通信的问题，最常见的属<br>于静态语言的 C&#x2F;C++模块之间通信有两种方式，<br>一种是模块间的函数调用，另外一种是模块<br>间的变量访问。两数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以<br>这两种方式都可以归结为一种方式，那就是模块间符号的引用。模块问依靠符号来通信类似<br>于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者-<br>拼接刚好完美组合（见图2-7）。这个模块的拼接过程就是本书的一个主题：链接 (Linking )。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4926d4c703343608e08fbe317bae368~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>链接</strong>主要是将前面步骤生成多个目标文件进行重定位等复杂的操作，从而生成可执行文件。链接可分为静态链接和动态链接。</p>
<h1 id="3-2编译器做了什么"><a href="#3-2编译器做了什么" class="headerlink" title="3.2编译器做了什么"></a>3.2编译器做了什么</h1><p>背景 为什么出现了编译器</p>
<p>词法分析，语法分析，语义分析，中间语言生成，目标代码生成与优化</p>
<p>下面我们以一行简单的C语言代码为例，简单描述从<strong>源代码（Source Code）</strong> 到<strong>最终目标代码</strong>的过程。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)\</span><br></pre></td></tr></table></figure>



<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1.词法分析"></a>1.词法分析</h3><p>首先源代码被输入到<strong>扫描器（Scanner）</strong> ，扫描器的任务很简单，只是简单地进行词法分析，运用一种类似于<strong>有限状态机（Finite State Machine）</strong> 的算法将源代码的字符序列分割成一系列的<strong>记号（Token）</strong> 。</p>
<p>以上述代码为例，总共包含了28个非空字符，经过扫描后，产生了16个记号。</p>
<table>
<thead>
<tr>
<th>记号</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>标识符</td>
</tr>
<tr>
<td>[</td>
<td>左方括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>[</td>
<td>右方括号</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>赋值</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>4</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
<tr>
<td>*</td>
<td>乘号</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>2</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>6</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
</tbody></table>
<p>词法分析产生的记号一般可以分为一下几类：<strong>关键字</strong>、<strong>字面量</strong>（包含数字、字符串等）和<strong>特殊符号</strong>（如加号、等号）。</p>
<p>在识别记号的同时，扫描器也完成了其他工作。如：将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p>
<p>有一个名为lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。正因为有这样一个程序存在，编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则即可。</p>
<p>对于一些预处理的语言，c语言，他的宏替换和文件包含等工作一般不归编译器的范围，交给了一个独立的预处理器。</p>
<h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h3><p><strong>语法分析器（Grammar Parser）</strong> 将对由扫描器产生的记号进行语法分析。从而产生<strong>语法树（Syntax Tree）</strong> 。整个分析过程采用了<strong>上下文无关语法（Context-freeGrammar）</strong> 的分析手段。简单地讲，由语法分析器生成的语法树是以<strong>表达式（Expression）</strong> 为节点的树。</p>
<p>以上述代码为例，其中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句，下图所示为该语句经过语法分析器后生成的语法树。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d67137f8fb41e78ca2509a5069952e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。如：乘法表达式的优先级比加法高，圆括号表达式的优先级比乘法高，等等。另外，有些符号具有多重含义，如“*”在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，因此语法分析阶段必须对这些内容进行区分。如果出现了表达式不合法，如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。</p>
<p>有一个名为yacc（Yet Another Compiler Compiler）的工具可以实现语法分析。其根据用户给定的语法规则对输入的记号序列进行解析，从而构建出语法树。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器编写一个语法分析器。因此，其也称为“编译器编译器（Compiler Compiler）”</p>
<h3 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3.语义分析"></a>3.语义分析</h3><p>语法分析仅仅完成了对表达式的语法层面的分析，但它并不了解这个语句的真正含义，如：C语言里两个指针做乘法运算是没有意义的，但这个语句在语法上是合法的。编译器所能分析的语义是<strong>静态语义（Static Semantic）</strong> ，所谓静态语义是指在编译期间可以确定的语义，与之对应的<strong>动态语义（Dynamic Semantic）</strong> 就是只有在运行期才能确定的语义。</p>
<p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型的转换过程，语义分析过程中需要完成该步骤。比如讲一个浮点赋值给一个指针时，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般是指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。</p>
<p>经过语义分析阶段之后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。下图所示为标记语义后的语法树。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f3307b4861b4c68a8ad133e2a358b66~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-中间语言生成"><a href="#4-中间语言生成" class="headerlink" title="4.中间语言生成"></a>4.中间语言生成</h3><p>现代编译器有着很多层次的优化，<strong>源码优化器（Source Code Optimizer）</strong> 则是在源代码级别进行优化。上述例子中，（2 + 6）这个表达式可以被优化掉。因为它的值在编译期就可以被确定。下图所示为优化后的语法树。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf6515b9fa32489fa8789d25518abbaf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>事实上，直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong> ，它是语法树的顺序表示，其实它已经非常接近目标代码了。但它一般与目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器的名字等。</p>
<p>中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：<strong>三地址码（Three-address Code）</strong> 、<strong>P-代码（P-Code）</strong> 。以三地址码为例，最基本的三地址码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br><span class="line"># 表示将变量y和z进行op操作后，赋值给x。</span><br></pre></td></tr></table></figure>

<p>因此，可以将上述例子的代码翻译成三地址码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = 2 + 6</span><br><span class="line">t2 = index + 4</span><br><span class="line">t3 = t2 * t1</span><br><span class="line">array[index] = t3</span><br></pre></td></tr></table></figure>

<p>为了使所有的操作符合三地址码形式，这里使用了几个临时变量：t1、t2和t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1 &#x3D; 6。因此，进一步优化后可以得到如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t2 = index + 4</span><br><span class="line">t2 = t2 * 8</span><br><span class="line">array[index] = t2</span><br></pre></td></tr></table></figure>

<p>中间代码将编译器分为<strong>前端（Front End）</strong> 和<strong>后端（Back End）</strong> 。编译器前端负责产生机器无关的中间代码，编译器后端负责将中间代码转换成目标机器代码。这样，对于一些可跨平台的编译器，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。</p>
<p>比如clange就是一个前端工具，而LLVM则负责后端处理。GCC则是一个套装，包揽了前后端的所有任务。</p>
<h3 id="5-目标代码生成与优化"><a href="#5-目标代码生成与优化" class="headerlink" title="5.目标代码生成与优化"></a>5.目标代码生成与优化</h3><ol>
<li>目标代码生成</li>
</ol>
<p>目标代码生成主要由<strong>代码生成器（Code Generator）</strong> 完成。代码生成器将中间代码转换成目标机器代码，该过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。</p>
<p>上述例子的中间代码，经过代码生成器的处理之后可能会生成如下所示的代码序列（以x86汇编为例，假设index的类型为int型，array的类型为int型数组）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl index, %ecx            ; value of index to ecx</span><br><span class="line">addl $4, %ecx               ; ecx = ecx + 4</span><br><span class="line">mull $8, %ecx               ; ecx = ecx * 8</span><br><span class="line">movl index, %eax            ; value of index to eax</span><br><span class="line">movl %ecx, array(,%eax,4)    ; array[index] = ecx</span><br></pre></td></tr></table></figure>

<p>2.目标代码优化</p>
<p>目标代码生成后，由<strong>目标代码优化器（Target Code Optimizer）</strong> 来进行优化。比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</p>
<p>上述例子中，乘法由一条相对复杂的<strong>基址比例变址寻址（Base Index Scale Addressing）</strong> 的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。如下所示为优化后的目标代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(,%edx,8), %eax</span><br><span class="line">movl %eax, array(,%edx,4)</span><br></pre></td></tr></table></figure>

<p>经过扫描、语法分析、语义分析、源代码优化、目标代码生成、目标代码优化等一系列步骤之后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题：</p>
<blockquote>
<p>index和array的地址还没有确定</p>
</blockquote>
<p>如果我们把目标代码使用汇编器编译成真正能够在机器上运行的指令，那么index和array的地址来自哪里？</p>
<p>如果index和array定义在跟上面的源代码同一个编译单元里，那么编译器可以为index和array分配空间，确定地址；但如果是定义在其他的程序模块呢？</p>
<p>事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源文件编译成一个未链接的目标文件，然后由编译器最终将这些目标文件链接起来形成可执行文件。（<strong>引出链接器</strong>）</p>
<h1 id="3-3-编译器前端-后端"><a href="#3-3-编译器前端-后端" class="headerlink" title="3.3 编译器前端 后端"></a>3.3 编译器前端 后端</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><ul>
<li>传统编译器的设计</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/501a04b3cb734d5eb91d66649e0816b2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>编译器前端(Frontend)<br>编译器前端的任务是解析源代码。它会进行：词法分析、语法分析、语义分析，检查源代码是否存在错误，然后构建抽象语法树，LLVM的前端会生成中间代码IR。</p>
</li>
<li><p>优化器(Optimizer)<br> 优化器负责进行各种优化。改善运行时间，例如消除冗余计算等。</p>
</li>
<li><p>后端(Backend)<br> 也可以叫代码生成器(CodeGenerator)，将代码映射到目标指令集。生成机器语言，并且进行机器相关的代码优化。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d5b83165eb5457182adc43e5fb9e188~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<p>随着高级语言越来越多，终端类型种类的增加，所使用的的CPU架构等也不尽相同。<br>所以为了适配多种环境，不得不设计不同的编译器，而这些编译器前端和后端往往是捆绑在一起的。</p>
<p>LLVM的设计之初，即将编译器前端(Frontend)和后端(Backend)进行了分离。\</p>
<p>将前端和后端针对不同的架构，按照独立的项目进行研发，而它们均采用通用的代码形式IR。\</p>
<p>当编译器决定支持多种语言或多种硬件架构时，LLVM最重要的地方就体现出来了，使用通用的代码表示形式(IR)，它是用来在编译器中表示代码的形式。<br>所以LLVM可以为任何编程语言独立编写前端，并且可以为任意硬件架构独立编写后端。\</p>
<p>ios 编译架构</p>
<p>Objective C&#x2F;C&#x2F;C++使用的编译器前端是Clang，Swift是Swift，后端都是LLVM。\</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da3dc4b2aed546ac902a729087274252~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="4-链接器"><a href="#4-链接器" class="headerlink" title="4.链接器"></a>4.链接器</h1><p>连接器 介绍 背景</p>
<h2 id="4-1-静态链接"><a href="#4-1-静态链接" class="headerlink" title="4.1 静态链接"></a>4.1 静态链接</h2><p>当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件呢？过程是怎么样的，这就是链接的核心内容：静态链接</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b84afad36d42488113a9ec5de7c8b3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>如模块 a和模块 通过gcc编译器将a.c和b.c编译成目标文件a.o和b.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c b.c</span><br></pre></td></tr></table></figure>

<p>经过编译，从代码中可以看b.c到定义了2个全局符号，变量shared 和 函数swap ,a.c 定义了全局符号main，模块a.c 引用了b.的 shared 和 swap，下面把a.c和b.c 链接到一起，最终为一个可执行文件</p>
<h3 id="1-空间与地址分配"><a href="#1-空间与地址分配" class="headerlink" title="1.空间与地址分配"></a>1.空间与地址分配</h3><p>可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。</p>
<p>按序叠加</p>
<p>一个最简单的方案就是将输入的文件按序叠加，将目标文件依次合并</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dff1e44703c849198a2fd222e9a65a5d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p>
<p>相似段合并<br>一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的  <strong><code>.text</code>节</strong>合并到输出文件的 <strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50d3f5bdc4f042408deb55055bcf5e47~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p>
<ol>
<li>在输出的可执行文件中的空间</li>
<li>在装载后的虚拟地址中的空间</li>
</ol>
<p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p>
<p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong>  的方法。即整个链接过程分为两步：</p>
<ul>
<li><strong>第一步 地址与空间分配</strong><br>扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</li>
<li><strong>第二步 符号解析与重定位</strong><br>使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fc10b0c22f849e997b5346d3b720dd7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了<a target="_blank" rel="noopener" href="http://chuquan.me/2018/05/21/elf-introduce/">ELF文件结构</a>一文中没有介绍的 <strong>程序头表（Program Header Table）</strong>  结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ <code>text</code>段）、数据段（ <code>data</code>段 ）。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa2606ed86144aa901fb634fa21f4d1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以发现，链接前目标文件中所有节的 <strong>VMA（Virtual Memory Address）</strong>  都是0，因为虚拟空间还没有分配。链接后，可执行文件<code>ab</code>中各个节被分配到了相应的虚拟地址，如<code>.text</code>节被分配到了地址<code>0x0000000000400450</code>。</p>
<p>那么，为什么链接器要将可执行文件<code>ab</code>的<code>.text</code>节分配到<code>0x0000000000400450</code>？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux x86-64系统中，代码段总是从<code>0x0000000000400000</code>开始的，另外<code>.text</code>节之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code>等占用了一定的空间，所以就被分配到了<code>0x0000000000400450</code>。</p>
<h3 id="符号地址确定"><a href="#符号地址确定" class="headerlink" title="符号地址确定"></a>符号地址确定</h3><p>符号解析</p>
<p>在<strong>两步链接</strong>中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。</p>
<p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p>
<p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p>
<p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p>
<p><strong>COMMON块（### 多重定义的全局符号解析）</strong></p>
<p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？</p>
<p>Linux编译系统采用如下的方法解决多重定义的全局符号解析：</p>
<p><strong>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</strong></p>
<p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li><strong>规则1：不允许有多个同名的强符号。</strong></li>
<li><strong>规则2：如果有一个强符号和多个弱符号同名，则选择强符号。</strong></li>
<li><strong>规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。</strong></li>
</ul>
<p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p>
<ul>
<li><strong>情况1：两个或两个以上的强符号类型不一致。</strong></li>
<li><strong>情况2：有一个强符号，其他都是弱符号，出现类型不一致。</strong></li>
<li><strong>情况3：两个或两个以上弱符号类型不一致。</strong></li>
</ul>
<p>其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 <strong>COMMON块（Common Block<br>）</strong>  的机制来处理。其过程如下：</p>
<p><strong>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。</strong></p>
<p>重定位表<br>事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p>
<p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong>  专门用来保存这些与重定位相关的信息。</p>
<p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p>
<p>我们可以使用objdump工具来查看目标文件中的重定位表：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b53dc46d914c72981178fe0bdd6b64~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>我们可以看到每个要被重定位的地方是一个 <strong>重定位入口（Relocation Entry）</strong> 。利用数据结构成员包含的信息，即可完成重定位。</p>
<p>** 指令修正方式</p>
<h1 id="4-2-动态链接"><a href="#4-2-动态链接" class="headerlink" title="4.2 动态链接"></a>4.2 动态链接</h1><p>为什么要动态链接？</p>
<p>静态链接使得不同的程序开发者和部门能够相对独立地开发和测试自己的程序模块，从<br>某种意义上来讲大大促进了程序开发的效率，原先限制程序的规模也随之扩大。但是慢慢地<br>静态链接的诸多缺点也逐步暴露出来，比如浪费内存和磁盘空间、模块更新困难等问题，使<br>得人们不得不号找一种更好的方式来组织程序的模块</p>
<p><strong>内存和磁盘空间</strong></p>
<p>静态链接这种方法的确很简单，原理上很容易理解，实践上很难实現，在操作系统和硬<br>件不发达的早期，绝大部分系统采用这种方案。随着计算机软件的发展，这种方法的缺点很<br>快就暴露出来了，那就是静态连接的方式对于计算机内存和磁盘的空间浪费非常严重。特别<br>是多进程操作系统情况下，静态链接极大地浪费了内存空间，想象一下每个程序内部除了都<br>保留着 printf（）函数、scanf（）函数、strlen（）等这样的公用库函数，还有数量相当可观的其他库<br>函数及它们所需要的辅助数据结构。在现在的 Linux 系统中，<br>一个普通程序会使用到的C<br>语言静态库至少在 1MB 以上，那么，如果我们的机器中运行着100 个这样的程序，就要浪<br>费近100 MB 的内存：如果磁盘中有2000 个这样的程序，就要浪费近 2 GB 的磁盘空间，<br>很多 Linux 的机器中，&#x2F;usr&#x2F;bin下就有数干个可执行文件。</p>
<p>比如图 了-1 所示的Programl 和 Program2 分别包含Programl.0 和Program2.0两个模块，</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22c04db183db46129047b39b0c7f7217~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>并且它们还共用 Lib.o 这两模块。在静态连接的情况下，因为 Programl 和 Program2 都用到<br>了 Lib.o这个模块，所以它们同时在链接输出的可执行文件 Program1 和 Program2 有两个副<br>本。当我们同时运行 Programl 和 Program2 时， Lib.。在磁盘中和内存中都有两份副本。当<br>系统中存在大最的类似于Lib.。 的被多个程序共享的目标文件时，其中很大一部分空间就被<br>浪费了。在静态链接中，C语言静态库是很典型的浪费空间的例子，还有其他数以千计的库<br>如果都需要静态链接，那么空间浪费无法想象</p>
<p><strong>程席开发和发布</strong><br>空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也<br>会带来很多麻烦。比如程序 Program1 所使用的 Lib.o是由一个第三方厂商提供的，当该厂<br>商更新了 Lib.o。的时候（比如修正了i.。里面包含的-<br>一个Bug），那么Programl 的厂商就需<br>要拿到最新版的 Lib.o，然后将其与 Program1.o链接后，将新的 Program1 整个发布给用户<br>这样做的缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户。<br>比如一个程序有20个模块，每个模块 1MB，那么每次更新任何一个模块，用户就得重新获<br>取这个 20 MB 的程序。如果程序都使用静态链接，那么通过网络来更新程序将会非常不便，<br>因为一旦程序任何位置的一个小改动，都会导致整个程序重新下载</p>
<p>动态链接<br>要解决空间浪费和更新困难这两个问题最简单的办法就是把程序的模块相互分割开来，<br>形成独立的文件，而不再将它们静态地链接在一起。简单地讲，就是不对那些组成程序的目<br>标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行<br>时再进行，这就是动态链接(Dynamic Linking）的基本思想。<br>还是以 Programl 和Program2 为例，假设我们保留 Programl.0、Program2.0 和 Lib.o<br>个目标文件。当我们要运行 Program1 这个程序时，系统首先加载 Program1.0，当系统发现<br>Programl.0 中用到了 Lib.o，即 Program1.0依赖于 Lib.o，那么系统接着加载 Lib.o，如果<br>Program1.0或 Lib.o还依赖于其他目标文件，系统会按照这种方法将它们全部加载至内存。<br>所有需要的目标文件加载完牛之后，如果依赖关系满足，即所有依赖的目标文件都存在于磁<br>盘，系统开始进行链接工作。这个链接王作的原理与静态链接非常相似，包括符号解析、地<br>址重定位等，我们在前面己经很详细地介绍过了。完成这些步骤之后，系统开始把控制权交<br>给 Programl.∞ 的程序入口处，程序开始运行。这时如果我们需要运行 Program2，那么系统<br>只需要加载 Program2.0，布不需要重新加载 Lib.0，因为内存中己经存在了一份 Lib.o 的副本<br>（见图7-2），系统要做的只是将 Program2.0和Lib.o链接起来。</p>
<p>优点</p>
<p>很明显，上面的这种做法解决了共享的目杯文件多个副本浪费磁盘和内存空间的问题，<br>可以看到，磁盘和内存中只存在一份 Lib.0，而不是两份。另外在内存中共享一个目标文件</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b73d7f5394f452b82bd5dae1f99b2f2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>模块的好处不仅仅是节省内存，它还可以减少物理页面的换入换出，也可以增加 CPU 缓存<br>的命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上。<br>上面的动态链接方案也可以使程序的升级变得更加容易，当我们要升级程序库或程序共<br>享的某个模块时，理论上只要简单地将旧的目标文件覆盖掉，而无须将所有的程序再重新链<br>接一遍。当程序下一次运行的时候，新版本的目标文件会被自动装载到内存并且链接起来，<br>程序就完成了升级的目标。<br>当一个程序产品的规模很大的时候，往往会分割成多个子系统及多个模块，每个模块都<br>由独立的小组开发，甚至会使用不同的编程语言。动态链接的方式使得开发过程中各个模块<br>更加独立，男合度更小，便于不同的开发者和开发组织之间独立进行开发和测试。</p>
<p>程序可扩展性和莱容性</p>
<p>动态链接还有一个特点就是程序在运行时可以动态地选择加载各种程序模块，这个优点<br>就是后来被人们用来制作程序的插件 (plug-in)。<br>比如某个公司开发完成了菜个产品，它按照一定的规则制定好程序的接口，其他公司或<br>开发者可以按照这种接口来编写符合要求的动态链接文件。该产品程序可以动态地载入各种<br>由第三方开发的模块，在程序运行时动态地链接，实现程序功能的扩展。<br>动态链接还可以加强程序的兼容性。一个程序在不同的平台运行时可以动态地链接到由</p>
<p>操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间增加了一个中间<br>层，从市消除了程序对不同平台之间依赖的差异性。比如操作系统 A 和操作系统 B对于<br>printfO的实现机制不同，如果我们的程序是静态链接的，那么程序需要分别链接成能够在A<br>运行和在 B运行的两个版本并且分开发布；但是如果是动态链接，只要操作系统 A 和操作<br>系统B都能提供一个动态链接库包含printf0，并且这个printfo使用相同的接口，那么程序<br>只需要有一个版本，就可以在两个操作系统上运行，动态地选择相应的printfo的实现版本。<br>当然这只是理论上的可能性，实际上还存在不少问题，我们会在后面继续探讨关于动态链接<br>模块之间兼容性的问题.<br>从上面的描述来看，动态链接是不是一种 “万能音药”，包治百病呢？很遗憾，动态链<br>接也有诸多的问题及令人烦恼和费解的地方。很常见的一个问题是，当程序所依赖的某个模<br>块更新后，由于新的模块与旧的模块之间接口不兼容，导致了原有的程序无法运行。这个问<br>题在早期的 Windows 版本中尤为亚重，因为它们缺少一种有效的共享库版本管理机制，使<br>得用户经常出现新程序安装完之后，其他某个程序无法正常工作的现象，这个问题也经常被<br>称为“DLL Hell”.</p>
<p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p>
<p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 <strong>动态共享对象（DSO，Dynamic Shared Objects）</strong> ，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为 <strong>动态链接库（Dynamic Linking Library）</strong> ，一般以<code>.dll</code>为后缀。</p>
<p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 <code>/lib</code>目录下，文件名为 <code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p>
<p>动态链接缺点和解决方法</p>
<p>程序与 iibc.so 之间真正的链接工作是由动态链接器完成的，而不是由我们前面看到过<br>的静态链接器 1d 完成的。也就是说，动态链接是把链接这个过程从本来的程序装载前被推<br>迟到了装载的时候。可能有人会问，这样的做法的确很灵活，但是程序每次被装载时都要进<br>行重新进行链接，是不是很慢？的确，动态链接会导致程序在性能的一些损失，但是对动态<br>链接的链接过程可 以进行优化，比如我们后面要介绍的延迟鄉定 (Lazy Binding） 等方法，<br>可以使得动态链接的性能损失尽可能地滅小。据估算，动态链接与静态链接相比，性能损失<br>大约在 5%以下。当然经过实践的证明，这点性能损失用来换取程序在空间上的节省和程序<br>构建和升级时的灵活性，是相当值得的。</p>
<p>举例</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97cd9f5226c74da79818fbedf7f06000~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2babb13fe0c46e8863d55e3e908055c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae2e58954504f18b262f28f6620e2b9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>Lib.c 被编译成 Lib.so共享对象文件，Programlc 被编译成 Programl.0之后，链接成为<br>可执行程序 Programl。图7-3 中有一个步骤与静态链接不一样，那就是 Programl.。被连接<br>成可执行文件的这一步。在静态链接中，这一步链接过程会把 Programl.o 和Lib.o 链接到<br>起，并且产生输出可执行文件 Programl。但是在这里，Lib.。 没有被链接进来，链接的输入<br>目标文件只有 Program1.。〔当然还有C语言运行库，我们这里暂时忽略）。但是从前面的命<br>令行中我们看到，Lib.so 也参与了链接过程。这是怎么回事呢？<br>关于模块：&lt;Module）×<br>在静态链接时，整个程序最终只有一个可执行文件，它是一个不可以分割的整体；但<br>是在动态链接下，一个程序被分成了若千个文件，有程序的主要部分，即可执行文件<br>1Program1〕和程序所依赖的共享对象（Lib.so)，很多时候我们也把这些部分称为模<br>块，即动态链接下的可执行文件和共享对象都可以看作是程序的一个模块。<br>让我们再回到动态链接的机制上米，当程序模块 Programl.c 被编译成为 Programl.0 时，<br>编详器还不不知道foobar0西数的地址，这个内容我们己在静态链接中解释过了。当链接器<br>将Program 1.0链接成可执行文件时，这时候链接器必须确定 Program1.0 中所引用的 foobar0<br>函数的性质。如果foobar0是一个定义与其他静态目标模块中的函数，那么链接器将会按照<br>静态链接的规则，将Program1.0 中的foobar 地址引用重定位：如果 foobar0是<br>一个定义在某<br>个动态共享对象中的函数，那么链接器就会将这个符号的引用标记为一个动态链接的符号，<br>不对它进行地址重定位，把这个过程留到装载时再进行。<br>那么这里就有个问题，链接器如何知道foobar 的引用是<br>一个静态符号还是一个动态符<br>号？这实际上就是我们要用到 Lib.so的原因。Lib.so中保存了完整的符号信息(因为运行时<br>进行动态链接还须使用符号信息），把Lib.so 也作为链接的输入文件之一，链接器在解析符<br>号时就可以知道：foobar 是一个定义在Lib.so 的动态符号。这样键接器就可以对 foobar 的引<br>用做特殊的处理，使它成为一个对动态符号的引用。</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><h3 id="地址空间分配"><a href="#地址空间分配" class="headerlink" title="地址空间分配"></a>地址空间分配</h3><p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p>
<p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p>
<ul>
<li><strong>静态共享库（Static Shared Library）</strong> （地址固定）</li>
<li><strong>动态共享库（Dynamic Shared Libary）</strong> （地址不固定）</li>
</ul>
<h3 id="装载重定位"><a href="#装载重定位" class="headerlink" title="装载重定位"></a>装载重定位</h3><p>我们前面在静态链接时提到过重定位，那时的重定位叫做链接时重定位 ( Link Time<br>Relocation），而现在这种情况经常被称为装载时重定位 (Load Time Relocation )，在<br>Windows 中，这种装载时重定位又被叫做基址重置 (Rebasing），我们在后面将会有专门章<br>节分析基址重置。<br>这种情况与我们碰到的问题很相似，都是程序模块在编详时目标地址不确定而需要在装<br>裁时将模块蛋定位，但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的<br>问题。可以想象，动态链接模块被装载映射至康拟空间后，指今部分是在名个讲程之间北享<br>的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，<br>因为指令被重定位后对于每个进程来讲是不同的。当然，动态连接库中的可修改数据部分对<br>手不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。</p>
<p>具体是怎么做到的</p>
<h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p>
</blockquote>
<p><strong>地址无关代码（PIC，Position-independent Code）</strong>  技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型：</p>
<ul>
<li><strong>类型1：模块内部的函数调用。</strong></li>
<li><strong>类型2：模块内部的数据访问，如模块中定义的全局变量、静态变量。</strong></li>
<li><strong>类型3：模块外部的函数调用。</strong></li>
<li><strong>类型4：模块外部的数据访问，如其他模块中定义的全局变量。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">extern int b;</span><br><span class="line">extern void ext();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    a = 1;      // 类型2：模块内部数据访问</span><br><span class="line">    b = 2;      // 类型4：模块外部数据访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    bar();      // 类型1：模块内部函数调用</span><br><span class="line">    ext();      // 类型4：模块外部函数调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类型1-模块内部函数调用"><a href="#类型1-模块内部函数调用" class="headerlink" title="类型1 模块内部函数调用"></a>类型1 模块内部函数调用</h5><p>由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。</p>
<p>类型2 模块内部数据访问</p>
<p>一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97dd173f71d47e7b397e2e34288e8f6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>“类型3 模块间数据访问”)类型3 模块间数据访问</p>
<p>模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF的实现方法是：在数据段中建立一个<strong>指向这些变量的指针数组</strong>，也称为<strong>全局偏移表（Global Offset Table，GOT）</strong> ，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。过程示意图如下所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/817fa9363ab9436d988434e0f917739c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h5 id="类型4-模块间函数调用"><a href="#类型4-模块间函数调用" class="headerlink" title="类型4 模块间函数调用"></a>类型4 模块间函数调用</h5><p>对于模块间函数调用，同样可以采用类型3的方法来解决。与上面的类型有所不同的是，GOT中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9a3ef4266d481b9d0f2311f9d28c6d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>延迟绑定（PLT）</strong><br>动态链接的确有很多优势，比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。<br>据统计 ELF 程序在静态链接下要比动态库稍微快点，大约为 1%~5%，当然这取决于程序<br>本身的特性及运行环境等。我们知道动态链接比静态链接慢的主要原因是动态链接下对于全<br>局和静态的数搭访问都要进行复东的 GOT 定位，然后问接寻址；对于模块间的调用也要先<br>定位 GOT，然后再进行间接跳转，如此一来，程序的运行速度必定会减慢。另外一个减慢<br>运行速度的原因是动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要<br>进行一次链接工作，正如我们上面提到的，动态链接器会寻找并装载所需要的共享对象，然<br>后进行符号查找地址重定位等工作，这些工作势必减慢程序的启动速度。这是影响动态链接<br>性能的两个主要问题，我们将在这一节介绍优化动态链接性能的-<br>一些方法。<br>延迟绑定实现<br>在动态链接下，程序模块之间包含了大最的西数引用（全局变量往往比较少，因为大量<br>的全局变量会导致模块之间糯合度变大），所以在程序开始执行前，动态链接会耗费不少时<br>问用于解决模块之间的函数引用的符号查找以及重定位，这也是我们上面提到的减慢动态链<br>接性能的第二个原因。不过可以想象，在-<br>-个程序运行过程中，可能很名两数在程序执行完<br>时都不会被用到，比如一些错误处理两数或者是<br>一些用户很少用到的功能模块等，如果一开<br>始就把所有函数都链接好实际上是<br>一种浪费。所以 ELF 采用了一种叫做延迟绑定(Lazy<br>Binding）的做法，基本的思想就是当西数第一次被用到时才进行鄉定（符号香找、重定位<br>等)，如果没有用到则不进行鄉定。所以程序开始执行时，模块间的函数调用都没有进行绑<br>定,而是需要用到时才由动态链接器水负责都定。这样的做法可以大大加快程序的启动速度，<br>特别有利于一此有大量函数引用和大量模块的程序。</p>
<p>动态链接的例子可以看苹果的动态连接器 </p>
<h1 id="5-苹果的动态链接器"><a href="#5-苹果的动态链接器" class="headerlink" title="5.苹果的动态链接器"></a>5.苹果的动态链接器</h1><p>dyld</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_8392210/3750204">https://blog.51cto.com/u_8392210/3750204</a></p>
<p><a target="_blank" rel="noopener" href="https://www.dllhook.com/post/238.html">https://www.dllhook.com/post/238.html</a></p>
<h1 id="6-应用"><a href="#6-应用" class="headerlink" title="6.应用"></a>6.应用</h1><p>启动优化<br>静态分析</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/07/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">iOS 组件化探究</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-07T00:00:00+08:00">2022-06-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>iOS 组件化的背景是为了解决单一应用日益庞大、复杂度不断提高导致开发效率低下、维护成本高等问题，项目如果单纯的只是为了开发功能而忽略了模块复用以及架构相关的细节那么可能会造成以下问题。</p>
<ol>
<li>降低了开发效率和代码质量，增加了开发和维护的成本。</li>
<li>导致项目体积过大、启动时间增长等性能问题。</li>
<li>出现组件版本兼容性问题和稳定性问题，影响了整个应用的稳定运行。</li>
<li>增加了多人协作的困难度，影响了团队协作效率。</li>
<li>降低了应用的整体测试覆盖率和质量，增加了上线风险。</li>
<li>功能代码之间的依赖复杂，可维护性差</li>
<li>协同开发过程中，并行开发存在阻塞情况</li>
<li>功能界限不清晰，基础功能模块变动，会导致上层业务受到影响</li>
<li>各团队负责功能模块，在主工程中有耦合代码</li>
<li>上层业务会出现反向提供功能给底层情况</li>
<li>代码分析优化，随代码增加变得困难</li>
</ol>
<p>为了解决这些问题就出现了组件化的方案，组件化可以将一个大型应用拆分成多个小模块，每个模块都是独立的组件，具有明确的职责和功能，可以独立开发、测试和部署。这样可以提高开发效率和协作效率，同时也方便了代码的维护和升级。</p>
<h1 id="组件化的优势"><a href="#组件化的优势" class="headerlink" title="组件化的优势"></a>组件化的优势</h1><ol>
<li>开发效率提高：通过组件化，可以将开发任务分解成多个小模块，每个团队或者开发者只需负责自己的组件开发和迭代，不需要关心整个应用的其他部分。这样可以减少沟通成本、加快迭代速度，提高开发效率。</li>
<li>维护成本降低：随着应用规模的增大，代码维护难度也会逐渐增加。通过组件化，可以将应用拆分成多个小模块，每个模块都是独立的组件，有清晰的职责和功能。这样可以减少代码耦合度，降低代码修改的风险，同时也方便了代码的维护和升级。</li>
<li>协作效率提高：在一个大型的项目中，多个团队或者开发者可能同时进行开发工作。通过组件化，可以将应用拆分成多个小模块，每个模块都是独立的组件，可以独立开发、测试和部署。这样可以避免多人同时修改同一份代码文件的冲突，提高协作效率。</li>
<li>代码复用性增强：在组件化架构中，每个组件都是独立的，可以被其他应用或者项目所复用。这样可以减少代码的重复编写，提高代码的复用性和可维护性。</li>
<li>功能模块化：通过组件化，可以将一个大型应用拆分成多个小模块，每个模块都是独立的组件，具有明确的职责和功能。这样可以使应用的功能更加模块化、清晰、易于扩展和维护。</li>
</ol>
<h1 id="问题挑战"><a href="#问题挑战" class="headerlink" title="问题挑战"></a>问题挑战</h1><p>虽然 iOS 组件化已经有了一定的发展，但是在实际应用中还存在以下问题或挑战：</p>
<ol>
<li>代码冗余：组件化架构中，每个组件都是独立的，具有独立的代码库。当多个组件需要使用同一个功能时，可能会出现代码冗余的情况，导致项目体积过大、编译时间增长等问题。</li>
<li>模块间通信复杂：不同模块之间可能需要进行数据传递和事件交互，这就需要引入通信机制。但是不同的组件之间通信复杂度不同，需要根据实际情况选择合适的通信方式。</li>
<li>组件版本管理：在一个大型应用中，不同的组件可能由不同的开发者或团队维护，并且会存在不同的版本。如何管理各个组件的版本与依赖关系，确保组件的兼容性和稳定性，是一个比较大的问题。</li>
<li>多人协作困难：在组件化开发中，不同组件的开发负责人可能分布在不同的地区，加上组件之间的依赖关系，多人协作会变得非常困难。</li>
<li>单元测试问题：组件化架构下，不同的组件具有独立性，可以进行单独的单元测试。但是在整个应用集成测试时，可能会出现不同组件之间的依赖关系问题，导致测试结果不准确。</li>
</ol>
<p>以上问题或挑战都需要在实践中逐步解决和优化，以提高组件化架构的效率和稳定性。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>iOS 组件化常用方案</p>
<p>两个关键点问题：</p>
<h2 id="1-中间件"><a href="#1-中间件" class="headerlink" title="1.中间件"></a>1.中间件</h2><h2 id="2-整体app设计"><a href="#2-整体app设计" class="headerlink" title="2.整体app设计"></a>2.整体app设计</h2><h3 id="关于App-整体架构"><a href="#关于App-整体架构" class="headerlink" title="关于App 整体架构"></a>关于App 整体架构</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/885438316b704cf99499ccca694107a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以按照三层结构划分</p>
<p>1.业务模块</p>
<p>2.通用的业务模块</p>
<p>3.独立于app的模块</p>
<p>4.中间件模块（此模块主要是贯穿整个组件模块调用）</p>
<h3 id="关于中间件"><a href="#关于中间件" class="headerlink" title="关于中间件"></a>关于中间件</h3><h4 id="1-URL-路由："><a href="#1-URL-路由：" class="headerlink" title="1.  URL 路由："></a>1.  URL 路由：</h4><p>通过定义一系列 URL scheme，不同的组件对应不同的 URL，然后在应用中注册路由表，在接收到特定 URL 时，根据路由表将请求转发到相应的组件中。</p>
<h4 id="2-Target-Action："><a href="#2-Target-Action：" class="headerlink" title="2.  Target-Action："></a>2.  Target-Action：</h4><p>通过在编译期间生成各个组件之间的依赖关系，然后再通过 Runtime 动态加载组件，实现模块之间解耦。</p>
<h4 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3. 依赖注入"></a>3. 依赖注入</h4><p>  依赖注入（Dependency Injection，简称 DI）是一种常见的解决组件化中依赖关系管理问题的方案。在 iOS 组件化场景下，常见的 DI 方案有以下几种：</p>
<p>  a.通过协议和遵循者实现依赖注入：将各个组件之间需要使用的接口抽象出来，定义成协议，然后在应用启动时，通过注册表将不同的实例与相应的协议对应起来。这样，当组件需要使用其他组件提供的服务时，只需要通过协议获得对应的实例即可。</p>
<p>   b.使用属性注入：将需要注入的对象定义成类的属性，然后在外部创建实例时，将需要注入的对象作为参数传入，或者在初始化方法中进行注入。</p>
<p> c. 使用构造函数注入：将需要注入的对象作为构造函数的参数，当外部调用构造函数创建实例时，将需要注入的对象作为参数传入即可。</p>
<p>  d.  使用框架：一些流行的框架，如 Swinject、Dagger 等，提供了更加便捷的依赖注入功能，并且可以结合反射机制、代码生成等技术，自动生成注入代码，大大提高了开发效率。</p>
<p>  e. 比较具有通用性的方法是使用「协议」 &lt;-&gt; 「类」绑定的方式，对于要注入的对象会有对应的 Protocol 进行约束，会经常看到一些RegisterClass:ForProtocol：和classFromProtocol的代码。在需要使用注入对象时，用框架提供的接口以协议作为入参从容器中获得初始化后的所需对象。也可以在 Register 的时候直接注册一段 Block-Code，这个代码块用来初始化自己，作为id类型的返回值返回，可以支持一些编译检查来确保对应代码被编译。</p>
<p>  <strong>可以将一些运行时加载的操作前移至编译时</strong>，比如将各项注册从 +load 改为在编译期使用__attribute((used,section(“__DATA,key”))) 写入 mach-O 文件 Data 的 Segment 中来减少冷启动的时间消耗。下图参考BeeHive思路</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9bc345a2844414d9dfa5e1f80fd287c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>以上都是比较常见的 DI 方案，选择哪种方案取决于具体的项目需求和开发团队的技术栈。需要注意的是，DI 可以解决组件之间依赖关系的问题，但过度依赖 DI 也会增加代码复杂度和维护成本。</p>
<p>以上方式都可以实现 iOS 组件化中间件，选择哪种方式取决于具体的需求和项目情况</p>
<h3 id="3-库文件管理"><a href="#3-库文件管理" class="headerlink" title="3.库文件管理"></a>3.库文件管理</h3><ol>
<li>CocoaPods：使用 CocoaPods 进行库依赖管理，并且将每个组件封装成一个独立的 Pod。这样当需要使用某个组件时，只需在 Podfile 中添加对应的 Pod 即可。</li>
<li>Framework：将每个组件封装成独立的 Framework，然后在应用中动态链接需要使用的 Framework，避免了组件之间的直接引用。</li>
</ol>
<h2 id="3-中间件优缺点"><a href="#3-中间件优缺点" class="headerlink" title="3.中间件优缺点"></a>3.中间件优缺点</h2><h3 id="1-URL-路由"><a href="#1-URL-路由" class="headerlink" title="1.  URL 路由"></a>1.  URL 路由</h3><p>优点：</p>
<ul>
<li>实现简单，易于理解和使用；</li>
<li>可以根据 URL 的特定格式来管理组件之间的依赖关系。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要手动维护路由表，容易出现冗余和错误；</li>
<li>依赖于 URL scheme，存在命名空间冲突的风险。</li>
</ul>
<h3 id="2-Target-Action"><a href="#2-Target-Action" class="headerlink" title="2.  Target-Action"></a>2.  Target-Action</h3><p>优点：</p>
<ul>
<li>编译期生成依赖关系，保证了类型安全；</li>
<li>可以使用反射机制进行运行时注入。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码量较大，需要手动处理每个模块间的依赖关系；</li>
<li>对于多层嵌套的依赖关系，使用起来比较繁琐。</li>
</ul>
<h3 id="3-依赖注入-1"><a href="#3-依赖注入-1" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h3><p>优点:</p>
<ul>
<li>面向协议接口编程，可以传递任何类型参数。</li>
<li>模块依赖只需要依赖接口头文件即可。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码块存取的性能消耗较大。</li>
<li>并且协议与类的绑定关系的维护需要花费更多的时间成本。</li>
</ul>
<h2 id="4-工具优缺点"><a href="#4-工具优缺点" class="headerlink" title="4.工具优缺点"></a>4.工具优缺点</h2><h3 id="1-CocoaPods"><a href="#1-CocoaPods" class="headerlink" title="1.  CocoaPods"></a>1.  CocoaPods</h3><p>优点：</p>
<ul>
<li>管理依赖关系简单，易于维护；</li>
<li>可以将每个组件封装成 Pod，方便其他应用或项目复用。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能在应用内动态加载组件，需要重新编译整个应用；</li>
<li>需要引入外部依赖库，增加了应用的大小和启动时间。</li>
</ul>
<h3 id="2-Framework"><a href="#2-Framework" class="headerlink" title="2.  Framework"></a>2.  Framework</h3><p>优点：</p>
<ul>
<li>集成方便，只需要动态链接需要使用的 Framework 即可；</li>
<li>可以将每个组件封装成独立的 Framework，降低了耦合度。</li>
</ul>
<p>缺点：</p>
<ul>
<li>维护多个 Framework 需要一定的技术水平；</li>
<li>不能动态加载和卸载组件，需要重新编译整个应用。</li>
</ul>
<p>总的来说，每种方案都有其优劣，选择哪种方案取决于具体的项目需求和开发团队的技术栈。需要权衡各种因素，选择最适合自己的方案。</p>
<h2 id="5-业内组件化中间件方案细节"><a href="#5-业内组件化中间件方案细节" class="headerlink" title="5.业内组件化中间件方案细节"></a>5.业内组件化中间件方案细节</h2><h3 id="1-URL-Router"><a href="#1-URL-Router" class="headerlink" title="1.URL-Router"></a>1.URL-Router</h3><p><a target="_blank" rel="noopener" href="https://github.com/lightory/HHRouter">https://github.com/lightory/HHRouter</a></p>
<p>URL Router 是一种常用的 iOS 开发模式，用于实现基于 URL 的页面跳转、参数传递等功能。其大致实现流程可以概括如下：</p>
<ol>
<li>定义每个页面对应的 URL 地址，并在 URL Router 中注册这些地址和对应的控制器类。</li>
<li>当用户点击某个链接或执行某个跳转操作时，将对应的 URL 传递给 URL Router。</li>
<li>URL Router 根据注册的 URL 与控制器类的映射关系，找到对应的控制器类，并创建该控制器类的实例对象。</li>
<li>URL Router 将该实例对象返回给调用者，调用者可以通过该实例对象来操作对应的页面。</li>
</ol>
<p>以下是 URL Router 实现流程的简单示意图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3749890c100f4ebf8de282b7644f634a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上述流程图说明了 URL Router 的基本实现流程。需要注意的是，URL Router 可以根据传递的 URL 参数进行页面跳转和参数传递等操作，因此在设计和实现 URL Router 时需要考虑参数的安全性和可靠性。</p>
<h3 id="2-Target-Action-1"><a href="#2-Target-Action-1" class="headerlink" title="2.Target-Action"></a>2.Target-Action</h3><p><a target="_blank" rel="noopener" href="https://github.com/casatwy/CTMediator">https://github.com/casatwy/CTMediator</a></p>
<p>CTMediator 是一种常用的 iOS 开发模式，用于实现组件化架构中的组件间通信。其大致实现流程可以概括如下：</p>
<ol>
<li>创建一个 CTMediator 对象，并在该对象中定义需要暴露给其他组件使用的方法。</li>
<li>在其他组件中引入 CTMediator 头文件，并通过 CTMediator 对象调用相应的方法。</li>
<li>CTMediator 对象根据方法名和参数信息，在运行时动态地创建对应的控制器或执行对应的操作。</li>
<li>CTMediator 将创建出来的控制器或执行结果返回给调用者。</li>
</ol>
<p>以下是 URL Router 实现流程的简单示意图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b1e67e893487ab6bcb1c16404d415~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上述流程图说明了 CTMediator 的基本实现流程，其中组件 A 和组件 B 都可以通过 CTMediator 对象调用相应的方法，而 CTMediator 对象会根据方法名和参数信息，在运行时动态地创建对应的控制器或执行对应的操作，并将创建出来的控制器或执行结果返回给调用者。</p>
<h3 id="3-依赖注入-2"><a href="#3-依赖注入-2" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h3><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/BeeHive">https://github.com/alibaba/BeeHive</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d2f707b95b45909a3a8581c3a4fee4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>Beehive是由阿里巴巴开源的一款基于组件化的框架，用于解决大型复杂应用程序的可维护性、可扩展性和代码复用等问题。Beehive的核心概念是Module（模块），每个Module都包含了一个或多个协议（Protocol）和相应的实现（Implementation），并且在运行时通过Beehive容器对Module进行管理和调用。</p>
<ol>
<li>创建Module：创建一个或多个Module，每个Module包含一个或多个Protocol（协议）。</li>
<li>实现Module：实现Module中所定义的Protocol。</li>
<li>注册Module：在App启动时将Module注册到Beehive容器中或者推迟到使用时候创建。</li>
<li>获取Module：需要使用Module时，从Beehive容器中获取该Module的实例。</li>
<li>使用Module：使用Module提供的接口完成相应的功能。</li>
</ol>
<p>总之，使用Beehive实现流程图需要先安装Beehive，然后创建、实现、注册Module并在需要使用Module时从Beehive容器中获取实例。</p>
<p>在Beehive中，模块（Module）被定义为一组协议（Protocol）和实现（Implementation），Beehive容器则用来管理各个模块的注册、查找和调用等操作。通过Beehive提供的API，应用程序可以方便地获取其他模块提供的服务，并且无需关心具体的实现细节，BeeHive框架实现思路不仅仅有依赖注入还有appdelegate 模块的一些启发，这里不在讲解，有兴趣可以去看源码实现，附上BeeHive的几个模块注册方法和AppDelegate解耦的思路</p>
<p>注册方案:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24ef8867d170459e968353b60c0b4098~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc2aef62be214ac19578f792b4e80232~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76aa435cce764c118432e04f870e0012~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>AppDelegate解耦方案:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9553123dcbc34106921042e1054a6bd8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="6-实现细节"><a href="#6-实现细节" class="headerlink" title="6.实现细节"></a>6.实现细节</h2><p>  细节不在讲，有兴趣可以看源码实现。</p>
<h2 id="7-性能对比"><a href="#7-性能对比" class="headerlink" title="7.性能对比"></a>7.性能对比</h2><h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><p>CTMediator 是用 runtime msgsend 实现的执行效率最优。<br>URL-Router 多了一层解析逻辑因此效率略低于 依赖注入。</p>
<h3 id="对比排序"><a href="#对比排序" class="headerlink" title="对比排序"></a>对比排序</h3><p>CTMediator&gt;依赖注入&gt;URL-Router</p>
<h2 id="8-我的理解"><a href="#8-我的理解" class="headerlink" title="8.我的理解"></a>8.我的理解</h2><p>URL Router、Target-Action 和依赖注入都是 iOS 组件化的常见方案。</p>
<p>URL Router 是一种通过定义一系列 URL Scheme，将各个组件对应到不同的 URL 上，然后在应用中注册路由表，在接收到特定 URL 时，根据路由表将请求转发到相应的组件中的方案。这种方案实现简单，易于理解和使用，但需要手动维护路由表，存在冗余和错误的风险。</p>
<p>Target-Action 是一种通过在编译期间生成各个组件之间的依赖关系，然后再通过 Runtime 动态加载组件，实现模块之间解耦的方案。这种方案可以保证类型安全，并且可以使用反射机制进行运行时注入，但需要手动处理每个模块之间的依赖关系，对于多层嵌套的依赖关系使用起来比较繁琐。</p>
<p>依赖注入是一种通过协议和遵循者实现依赖注入的方案。将各个组件之间需要使用的接口抽象出来，定义成协议，然后在应用启动时，通过注册表将不同的实例与相应的协议对应起来。这种方案可以解决组件之间依赖关系的问题，但过度依赖 DI 也会增加代码复杂度和维护成本。</p>
<p>从性能，可读性，功能性，代码量，规范约束 几个维度综合考虑我建议</p>
<p>CTMediator &gt; 依赖注入 &gt; URL-Router</p>
<p>*当然选择哪种方案取决于具体的项目需求和开发团队的技术栈，需要权衡各种因素，选择最适合自己的方案，以上仅代表个人观点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kyan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
