<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Next">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Next">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="kyan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Next</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Next</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">kyan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/29/iOS-UI%E8%A7%86%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/29/iOS-UI%E8%A7%86%E5%9B%BE/" class="post-title-link" itemprop="url">iOS UI视图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-29 10:56:34 / Modified: 10:57:15" itemprop="dateCreated datePublished" datetime="2023-04-29T10:56:34+08:00">2023-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c9c15cc932b4f6ab1a20e2d80698d31~tplv-k3u1fbpfcp-watermark.image" alt="u=361136753,1329746390&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG.webp"></p>
<p>本文主要梳理iOS UI 核心知识</p>
<ul>
<li><ol>
<li>UITableView 相关</li>
</ol>
</li>
<li><ol start="2">
<li>事件传递&amp;视图响应</li>
</ol>
</li>
<li><ol start="3">
<li>图像显示原理</li>
</ol>
</li>
<li><ol start="4">
<li>卡顿&amp;掉帧原因方案</li>
</ol>
</li>
<li><ol start="5">
<li>绘制原理&amp;异步绘制</li>
</ol>
</li>
<li><ol start="6">
<li>离屏渲染触发时机&amp;为什么要避免离屏渲染</li>
</ol>
</li>
</ul>
<h2 id="1-UITableView-相关"><a href="#1-UITableView-相关" class="headerlink" title="1.UITableView 相关"></a>1.UITableView 相关</h2><p>UITableView核心主要在于 重用机制和数据源同步</p>
<h3 id="重用机制"><a href="#重用机制" class="headerlink" title="重用机制"></a><strong>重用机制</strong></h3><p>如图列表会维持一个重用池子，当cell从列表消失的时候会放到重用池里边，后续使用如果重用池里边有直接取出来，否则重新alloc 创建。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0749ef1438ad4ec99f3b8316f00f63ee~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="数据源同步"><a href="#数据源同步" class="headerlink" title="数据源同步"></a>数据源同步</h3><p>对于多线程情况需要注意的是数据源同步的问题，一般在新闻，咨询类app中，主要考虑问题，如何在tableview解决多线程情况下，数据的处理。</p>
<h5 id="并发访问，数据拷贝"><a href="#并发访问，数据拷贝" class="headerlink" title="并发访问，数据拷贝"></a><strong>并发访问，数据拷贝</strong></h5><p>对于并发访问，一般在子线程处理数据，如请求网络，在此之前需要先copy原始列表数据，当子线程处理完数据后，再copy回到主任务线程，刷新ui，保证数据完整性。</p>
<h5 id="串行访问"><a href="#串行访问" class="headerlink" title="串行访问"></a><strong>串行访问</strong></h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>对于串行访问，保证数据请求完成后，再去刷新ui。</p>
<h2 id="2-事件传递-amp-视图响应"><a href="#2-事件传递-amp-视图响应" class="headerlink" title="2.事件传递&amp;视图响应"></a>2.事件传递&amp;视图响应</h2><h4 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h4><p>事件传递核心在于 事件的传递链和响应链</p>
<p>两个方法</p>
<ul>
<li><p>(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {<br>}</p>
</li>
<li><p>(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {<br>}</p>
</li>
</ul>
<p>事件传递从uiapplication-&gt;uiwindow-&gt;uiview </p>
<p>hitTest 返回命中的目标视图，最佳响应者，如果是uiview的子视图，会递归倒序遍历子视图里边的 hitTest（hitTest会判断 alpha &gt; 0.1 ,userInteractionEnabled &#x3D; true , opaque &#x3D; 1），如果有命中，会通过pointInside 判断当前点击区域是否在视图内，如果在就响应事件, 通过 pointInside还可以自定义响应区域。</p>
<p><strong>需要注意如果点击的一个子视图超出了父试图，那么传递链 在判断父试图的时候已经被中断，因为点击区域不在父试图里边，从而最终丢弃了事件传递。</strong></p>
<h4 id="视图响应"><a href="#视图响应" class="headerlink" title="视图响应"></a>视图响应</h4><p>响应链从 first view -&gt; super view -&gt; … -&gt; view controller -&gt; window -&gt; Application -&gt; AppDelegate</p>
<p>简单总结，事件链包含传递链和响应链，事件通过传递链传递上去，通过响应链找到相应的 <code>UIResponse</code>。</p>
<p><strong>完整流程</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c26ec4bc74e4499a058ba858c24b150~tplv-k3u1fbpfcp-watermark.image" alt="3704739-b9721e05e0cda6b2.png"></p>
<p>主要有uiview和calayer</p>
<p>uiview 为calayer 提供内容，以及负责处理触摸等事件，参与响应链</p>
<p>calyer 负责显示内容 contents </p>
<p>符合单一职责模式</p>
<p><strong>响应链顺序</strong></p>
<p>是从当前最上层的view -&gt; superview -&gt; uiviewcontroller -&gt;uiwindow -&gt;uiapplication </p>
<p><strong>继承关系</strong></p>
<p>uibutton -&gt;uicontrol-&gt;uiview -&gt;uireponder</p>
<h2 id="3-图像显示原理"><a href="#3-图像显示原理" class="headerlink" title="3.图像显示原理"></a>3.图像显示原理</h2><p>通过cpu计算 gpu渲染 最终提交到帧缓冲区，通过视图控制器显示到屏幕上。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8e0e8c031d24c2ba69077ecd065407c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-卡顿-amp-掉帧原因"><a href="#4-卡顿-amp-掉帧原因" class="headerlink" title="4.卡顿&amp;掉帧原因"></a>4.卡顿&amp;掉帧原因</h2><p><strong>卡顿原因</strong></p>
<p>在规定的16.7ms之内，下-帧VSync信号到来之前，并没有cpu和gpu共同完成下一帧画面的合成，于是就造成了卡顿和掉帧。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-ZMCk0_Mc1xKth32GI_mPA">https://mp.weixin.qq.com/s/-ZMCk0_Mc1xKth32GI_mPA</a></p>
<p><strong>滑动优化方案</strong></p>
<p>从cpu 和 gpu</p>
<p>cpu<br>1.对象创建，调整，销毁<br>2.预排班（布局计算，文本计算）<br>3.预渲染（文本等异步绘制，图片编解码等）</p>
<p>gpu<br>1.纹理渲染<br>2.视图混合</p>
<p><strong>通用渲染流水线</strong></p>
<p> <strong>应用阶段</strong></p>
<p> <strong>几何阶段</strong></p>
<p> <strong>光栅化阶段</strong></p>
<p> <strong>像素处理阶段</strong></p>
<h2 id="5-绘制原理-amp-异步绘制"><a href="#5-绘制原理-amp-异步绘制" class="headerlink" title="5.绘制原理&amp;异步绘制"></a>5.绘制原理&amp;异步绘制</h2><p>[layer.delegate displayLayer:]</p>
<p>代理负责生成对应的bitmap ，设置该bitmap作为layer.contents属性的值</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e0774861d54376840a8ea0b9967995~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>异步绘制：</strong><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NzM0NzkxMQ==&mid=2655379516&idx=3&sn=8748f40b2b835a91f11315b321755d10&chksm=84e22d14b395a402eaf9eebde59df55df85988d2b1db09ae471546a07d7a12b432e6d389e5db&scene=27">https://mp.weixin.qq.com/s?__biz=MzA3NzM0NzkxMQ==&amp;mid=2655379516&amp;idx=3&amp;sn=8748f40b2b835a91f11315b321755d10&amp;chksm=84e22d14b395a402eaf9eebde59df55df85988d2b1db09ae471546a07d7a12b432e6d389e5db&amp;scene=27</a></p>
<h2 id="6-离屏渲染触发时机-amp-为什么要避免离屏渲染"><a href="#6-离屏渲染触发时机-amp-为什么要避免离屏渲染" class="headerlink" title="6.离屏渲染触发时机&amp;为什么要避免离屏渲染"></a><strong>6.离屏渲染触发时机&amp;为什么要避免离屏渲染</strong></h2><p>当我们处理图层的属性在被指定为未被预合成之前不能直接在屏幕上显示，就触发了离屏渲染。离屏渲染的概念起源于gpu层面，指的是gpu在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<p>何时触发</p>
<ul>
<li>圆角 </li>
<li>图层蒙版</li>
<li>阴影</li>
<li>光栏化</li>
</ul>
<p>为何要避免</p>
<p>上下文切换，GPU额外的开销<br>创建新的渲染缓冲区，内存损耗<br>最优回答： 触发离屏渲染会增加GPU的工作量，而增加GPU的工作量很有可能导致GPU和CPU的工作总耗时超过了16.67ms，有可能导致UI的卡顿和掉帧。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/29/Pod-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/29/Pod-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Pod 二进制实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-29 10:26:52" itemprop="dateCreated datePublished" datetime="2023-04-29T10:26:52+08:00">2023-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="pod二进制详细步骤"><a href="#pod二进制详细步骤" class="headerlink" title="pod二进制详细步骤"></a>pod二进制详细步骤</h2><h3 id="使用步骤流程"><a href="#使用步骤流程" class="headerlink" title="使用步骤流程"></a>使用步骤流程</h3><p>这个流程适用于所有符合条件的工程 包括主工程 或者 能独立运行的pod私有库</p>
<p>源码地址：</p>
<p><a href="mailto:git@git.zuoyebang.cc">git@git.xxx.cc</a>:native&#x2F;XXSpecs.git</p>
<p>二进制私有源地址：</p>
<p><a href="mailto:git@git.zuoyebang.cc">git@git.xxx.cc</a>:XXX_all_lib&#x2F;XXBinarySpecs.git</p>
<p>二进制服务器地址：</p>
<p><a target="_blank" rel="noopener" href="http://10.254.12.244:9090/frameworks/%25s/%25s/zip">http://10.254.12.244:9090/frameworks/%s/%s/zip</a>   (打包机配置的环境)</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/321afe3ddbf747708146f007ae4f5187~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="一-环境配置"><a href="#一-环境配置" class="headerlink" title="一.环境配置"></a>一.环境配置</h2><p>二进制服务器搭建</p>
<h3 id="1-mongodb"><a href="#1-mongodb" class="headerlink" title="1.mongodb"></a>1.mongodb</h3><h4 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580478a0d813480caec2bcd62aa2134b~tplv-k3u1fbpfcp-watermark.image" alt="舞入 usrlocal.png"></p>
<p>当创建&#x2F;data&#x2F;db 可能会遇到权限问题，直接手动在该目录下新建data和db文件加解决</p>
<h4 id="启动monogo"><a href="#启动monogo" class="headerlink" title="启动monogo"></a>启动monogo</h4><p>sudo mongod –dbpath&#x3D;&#x2F;Users&#x2F;xxx&#x2F;data&#x2F;db(这个路径为数据库存储的目录，你在哪里创建就指向哪里) 来启动mongod</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4636b78584ee46ce8adfd57bd985a903~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="开启-node-js-服务"><a href="#开启-node-js-服务" class="headerlink" title="开启 node.js 服务"></a>开启 node.js 服务</h4><p>开启 node.js 服务，保证mongo服务已经开启(最终保存静态库资源)</p>
<p>1.进入binary-server 目录 执行npm install 成功后 npm start 启动服务器(app.js 为入口文件，可以设置ip地址和端口号)</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f07129ba891d48dbaee917575248a790~tplv-k3u1fbpfcp-watermark.image" alt="YYModel.png"></p>
<p>2.如果遇到端口被占用就先关闭占用的端口</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3707f0a3a2c486db58772675397b15f~tplv-k3u1fbpfcp-watermark.image" alt="binary-server - -zsh - 80x24.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d1584742e6e4f3aa76fe80e9f71122b~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 9.png"></p>
<p>3.再次启动，打开浏览器访问对应端口地址，验证是否成功开启，页面访问正常为启动成功</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b93fb2e3f59f4792b02043798e8a6182~tplv-k3u1fbpfcp-watermark.image" alt="conplete 1op of this run can be found 1n.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec92a54ad9574254970960419dade165~tplv-k3u1fbpfcp-watermark.image" alt="© localhost8081frameworks.png"></p>
<h3 id="2-创建一个二进制私有源"><a href="#2-创建一个二进制私有源" class="headerlink" title="2.创建一个二进制私有源"></a>2.创建一个二进制私有源</h3><p><a target="_blank" rel="noopener" href="https://git.zuoyebang.cc/yike_all_lib/YKBinarySpecs">https://git.zuoyebang.cc/yike_all_lib/YKBinarySpecs</a></p>
<p>主要保存二进制资源的版本信息和对应的资源地址  (如zip包的获取地址)</p>
<h4 id="本地私有源"><a href="#本地私有源" class="headerlink" title="本地私有源"></a>本地私有源</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/858651bda2ba43059165c4cd1e3f9af4~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 13.png"></p>
<p>私有源json数据，里边对应私有源的静态库zip下载地址和一些信息</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1f58886e0e349358324600748387946~tplv-k3u1fbpfcp-watermark.image" alt="nane“Brotl1”,.png"></p>
<h3 id="3-安装打包插件"><a href="#3-安装打包插件" class="headerlink" title="3.安装打包插件"></a>3.安装打包插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods-imy-bin</span><br></pre></td></tr></table></figure>

<h3 id="4-工程需要的一些配置文件"><a href="#4-工程需要的一些配置文件" class="headerlink" title="4.工程需要的一些配置文件"></a>4.工程需要的一些配置文件</h3><p>目前为了简化流程通过主工程制作，最优的情况应该是 在每个pod库里边这样配置，但是由于目前大部分pod库不能独立编译，所以此插件是支持只 要主工程通过podspec生成 依赖模块，就可以生成podspec里边所有依赖的二进制文件</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbace522a3564e128d0b1c55ce0554d4~tplv-k3u1fbpfcp-watermark.image" alt="000.png"></p>
<h4 id="1-BinArchive-json"><a href="#1-BinArchive-json" class="headerlink" title="(1)BinArchive.json"></a>(1)BinArchive.json</h4><p>为制作二进制的白名单配置，可以忽略那些库不制作白名单，或者那些库不支持也可以放进去</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a83254b24b4457a15b0f0058caf5a1~tplv-k3u1fbpfcp-watermark.image" alt="archive-wnite-pod-11st 制作二週期自名筆®.png"></p>
<h4 id="2-podfile-local"><a href="#2-podfile-local" class="headerlink" title="(2)podfile_local"></a>(2)podfile_local</h4><p>此文件只是改插件为了区分本地依赖的库，实际情况可以不用</p>
<p>声明插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin &#x27;cocoapods-imy-bin&#x27;</span><br></pre></td></tr></table></figure>
<p>使用二进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_binaries!</span><br></pre></td></tr></table></figure>
<p>设置使用源码的库白名单(可选)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_use_source_pods</span><br></pre></td></tr></table></figure>


<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/500bfd87c46b48b4b59ff3eb729421bb~tplv-k3u1fbpfcp-watermark.image" alt="Podfilelocal.png"></p>
<h4 id="3-主工程-podspec"><a href="#3-主工程-podspec" class="headerlink" title="(3)主工程.podspec"></a>(3)主工程.podspec</h4><p>哪些需要打成二进制的库，就添加进去，真实情况生成二进制最好一个一个打，因为多个同时生成可能会出错，具体需要看错误信息，以下为目前 能制作二进制的库文件</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f754938aac4ea982b37bebd65607ce~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="二-开始使用"><a href="#二-开始使用" class="headerlink" title="二.开始使用"></a>二.开始使用</h2><h3 id="1-添加私有库到本地"><a href="#1-添加私有库到本地" class="headerlink" title="1.添加私有库到本地"></a>1.添加私有库到本地</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add xxBinarySpecs  https://git.xxBinarySpecs.git</span><br></pre></td></tr></table></figure>
<h3 id="2-配置打包变量"><a href="#2-配置打包变量" class="headerlink" title="2.配置打包变量"></a>2.配置打包变量</h3><p>如果是m1 电脑 pod 命令 需要加上arch -x86_64</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arch -x86_64)pod bin init</span><br></pre></td></tr></table></figure>
<ol>
<li> 配置私有库地址</li>
<li> 配置二进制私有源地址</li>
<li> 配置二进制服务器地址</li>
<li> 配置打包二进制的格式 目前就验证了zip，其他格式未验证</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620f246e88b14d9f8b5a9e89766ef0e8~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 19.png"></p>
<h3 id="3-开始制作二进制"><a href="#3-开始制作二进制" class="headerlink" title="3.开始制作二进制"></a>3.开始制作二进制</h3><p>注意项目根目录的homework.spec文件为需要生成二进制的库，最好一个一个打，因为把所有的库同时打会出现依赖问题，不好查找原因，此外某些 库最好指定版本号，不然生成的二进制对应不上工程podfile指定的版本</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d815f5daca94a509842e7d93a438d43~tplv-k3u1fbpfcp-watermark.image" alt="s.dependency.png"></p>
<p>(1)(arch -x86_64)pod bin auto –all-make</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ba271193db9431e883dfc9c1f2381ca~tplv-k3u1fbpfcp-watermark.image" alt="wit. Tre priottne aiseBteere weesle.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/946ee37142954f37a2b9f3c1c011f396~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 22.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9669da8d4ae8491384ea10de2758ca03~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 24.png"></p>
<p>(2)最终会自动编译完成转换成zip，同时生成对应版本的spec文件上传到二进制私有源和二进制服务器</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c17e7ce0e84c3791f9bab177d5f7b2~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 25.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2e0434001b847f69f6fcb94e636fd8b~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 26.png"></p>
<p>(3)同步二进制到工程中</p>
<p> 把xxx.spec中的注释的库都放开，目前测试发现如果不放开可能有些库同步不过来(此步骤可选)</p>
<p> 需要update 不然二进制库更新不过来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arch -x86_64)pod bin update --no-repo-update</span><br></pre></td></tr></table></figure>
<p>(4)最终如下生成.a</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f15a2ff3dd0d4b6185ed45ce51eebb91~tplv-k3u1fbpfcp-watermark.image" alt="252.png"></p>
<h2 id="三-结果对比"><a href="#三-结果对比" class="headerlink" title="三.结果对比"></a>三.结果对比</h2><p>目前只是把基础库和第三方库大部分库生成了.a ,业务库由于依赖过多，加上不能独立编译，因此目前无法生成</p>
<p>通过对比,编译耗时优化了20s左右(之前测试是190s)</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c96ef44e7cd44bd694458dfc52f7e632~tplv-k3u1fbpfcp-watermark.image" alt="Succeeded I 178.659s.png"></p>
<p>TODO:</p>
<p>此插件目前也存在一些问题，可能使用过程会遇到一些问题，大部分在pod bin auto 的时候出现，具体问题需要看具体原因了。   此库的源码默认应该安装在目录  &#x2F;Library&#x2F;Ruby&#x2F;Gems&#x2F;2.6.0&#x2F;gems&#x2F;cocoapods-imy-bin-0.3.1.3 有熟悉ruby的可以看看具体实现。</p>
<p><strong>问题list</strong></p>
<p>1.不支持spec声明FrameWork ，lipo合并静态库不支持FrameWork会出现问题</p>
<p>2.遇到执行pod bin auto 生成.a 出现搜索源码spec错误，如源码tag版本过多，超出搜索限制 json被截取导致出错</p>
<p><a target="_blank" rel="noopener" href="https://docs.github.com/cn/rest/search">https://docs.github.com/cn/rest/search</a></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a42bda23d92445cba6600958389f4bb~tplv-k3u1fbpfcp-watermark.image" alt="1E FTOr.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/139894c3622e4dc091dfcb130737b561~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 30.png"><br>3.遇到编译错误就搜索 关键字 1 error 看看是否是依赖某些库没有声明打成二进制，如果有就在xxx.podspec 里边添加对应库的依赖，前提 是此库支持打成二进制</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c3dccbf719d430480ecef8a256b783d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/29/iOS%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/29/iOS%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">iOS编译速度优化实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-29 10:26:52 / Modified: 10:52:37" itemprop="dateCreated datePublished" datetime="2023-04-29T10:26:52+08:00">2023-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h1><p>随着业务的发展免不了带来工程代码的飞速增加，程的业务代码数量超过10w行的非常普遍，使用的的二方&#x2F;三方 Pod 库的数量也会持续增加，工程的急速膨胀给我们的日常开发中带来了诸多痛点，在项目体量越来越大的情况下，编译速度也随之增长，工程编译速度降低，clean-build 一次需要 10-15min 左右，目前在大部分项目中xcode全部编译一次少则5分钟，多则10多分钟，甚至更久，严重影响开发效率。有时候一个小的改动也需要等待长达好几分钟的编译时间，打包速度降低，在打包提测窗口增加了等待的时长，在硬件资源有限的情况下，并且在不影响业务方开发习惯的前提下，如何解决这些摆在团队面前的难题，便成了我们迫在眉睫的迫切需求。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>针对这个问题，做了多方面的探究，从业界方案参考来看大概有以下几种策略去解决。</p>
<ol>
<li>xcode 编译选项优化</li>
<li>编译生成中间产物CCache优化</li>
<li>直接生成二进制编译</li>
</ol>
<h1 id="一-Xcode-编译选项优化"><a href="#一-Xcode-编译选项优化" class="headerlink" title="一. Xcode 编译选项优化"></a>一. Xcode 编译选项优化</h1><h2 id="1-Xcode配置"><a href="#1-Xcode配置" class="headerlink" title="1.Xcode配置"></a>1.Xcode配置</h2><h3 id="1-1-Enable-build-duration-setting-in-Xcode"><a href="#1-1-Enable-build-duration-setting-in-Xcode" class="headerlink" title="1.1. Enable build duration setting in Xcode"></a>1.1. Enable build duration setting in Xcode</h3><p>你可以直接在 Xcode 的 UI 中启用计时器。默认情况下此计时器不可见，但如果在命令行中运行以下命令，则每次构建应用程序时都会显示一个时间。</p>
<p>启用计时器后，您将在 Xcode 的构建状态栏中看到编译应用程序所需的时间。</p>
<p>终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</span><br></pre></td></tr></table></figure>

<p>启用计时器后，重启xcode ，您将在 Xcode 的构建状态栏中看到编译应用程序所需的时间。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf31cd81c5e443bbb9997874645966eb~tplv-k3u1fbpfcp-watermark.image" alt="Bulld Succeededl 17.3785.png"></p>
<h3 id="1-2使用新的构建系统"><a href="#1-2使用新的构建系统" class="headerlink" title="1.2使用新的构建系统"></a>1.2使用新的构建系统</h3><p>Apple 在 Xcode 9 中推出了一个新的构建系统，但默认情况下并未激活。Apple 的“New Build System”完全用 Swift 编写，旨在提高整体性能和依赖管理。但是，对于 Xcode 10，新的构建设置已默认激活并从<strong>Xcode Files-&gt; Project&#x2F;Workspace Settings启用</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4137ce399c00429e96a221bcf57eb4f9~tplv-k3u1fbpfcp-watermark.image" alt="Shared Workspace Settinas.png"><br>您可以在工作区设置中或通过调用以下方式启用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -UseNewBuildSystem=YES.</span><br></pre></td></tr></table></figure>



<h3 id="1-3-添加警告以查看函数或表达式是否导致编译时间变长"><a href="#1-3-添加警告以查看函数或表达式是否导致编译时间变长" class="headerlink" title="1.3. 添加警告以查看函数或表达式是否导致编译时间变长"></a>1.3. 添加警告以查看函数或表达式是否导致编译时间变长</h3><p>Xcode 具有内置功能，可让您识别导致编译时间变长的函数和表达式。您可以指定编译时间限制并确定代码库中超出此限制的区域。</p>
<p>在项目构建设置“其他 Swift 标志”中添加以下行</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xfrontend -warn-long-function-bodies=300 </span><br><span class="line"></span><br><span class="line">-Xfrontend -warn-long-expression-type-checking=300</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48d5ed1e058f43ec80bb85e9aac9b7a1~tplv-k3u1fbpfcp-watermark.image" alt="0_-IHHautFe768XJpz.webp"></p>
<p>300 整数表示您对函数和表达式设置的编译时限制。它以毫秒为单位。</p>
<p>如果函数或表达式花费的时间超过您指定的时间，这些标志将警告您。这意味着您必须优化您的函数或表达式。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95fe13a6447248da9f7808a0a51e4bc0~tplv-k3u1fbpfcp-watermark.image" alt="0N9qavcIVkF05XZ29.png"></p>
<h3 id="1-4-增加-Xcode-线程数"><a href="#1-4-增加-Xcode-线程数" class="headerlink" title="1.4. 增加 Xcode 线程数"></a>1.4. 增加 Xcode 线程数</h3><p>默认情况下，Xcode 将使用与 CPU 内核数相同的线程数。增加 Xcode 使用的线程数可以显着提高编译性能。这利用了一些处理器的多线程或模拟额外内核的能力。请记住，您可能需要进行试验以确定使用代码库进行并行构建的收益是否递减，然后相应地调整线程数。让我们尝试将 Xcode 配置为使用 3、4 或 8 个线程，看看哪一个为您的用例提供最佳性能。</p>
<p>您可以设置 Xcode 从终端使用的进程数，如下所示：</p>
<p><code>$defaults write com.apple.Xcode PBXNumberOfParallelBuildSubtasks 4 </code></p>
<h3 id="1-5-增加为-Swift-项目运行的并发构建任务的数量"><a href="#1-5-增加为-Swift-项目运行的并发构建任务的数量" class="headerlink" title="1.5. 增加为 Swift 项目运行的并发构建任务的数量"></a>1.5. 增加为 Swift 项目运行的并发构建任务的数量</h3><p>在 Xcode 9.2 中，Apple 引入了一项实验性功能，允许 Xcode 并行运行 Swift 构建任务。默认情况下，此功能未启用，您需要从命令行自行打开它。</p>
<p>默认写入 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively -bool YES</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-6-调整-iOS-模拟器（当然可以选择使用真机）"><a href="#1-6-调整-iOS-模拟器（当然可以选择使用真机）" class="headerlink" title="1.6. 调整 iOS 模拟器（当然可以选择使用真机）"></a>1.6. 调整 iOS 模拟器（当然可以选择使用真机）</h3><p>Apple iOS 测试模拟器让您可以跨不同的软件和硬件组合进行测试。通过使用 Physical Size 或 Pixel Accurate 窗口大小，您可以减少测试的大小和完成测试所需的时间。最终，这些配置更改使用的资源更少，有助于防止测试速度变慢，可以选择并拖动模拟器的任何角落以调整其大小并根据您的要求进行设置。另外，您可以按 CMD+1、CMD+2 或 CMD+3</p>
<h3 id="1-7-并行构建"><a href="#1-7-并行构建" class="headerlink" title="1.7. 并行构建"></a>1.7. 并行构建</h3><p>此选项允许 Xcode 通过同时构建不相互依赖的目标来加快总构建时间。对于具有许多可以轻松并行运行的较小依赖项的项目，这可以节省时间。</p>
<p>在 Xcode 10 中打开项目时，构建并行化应该已经启用。要检查或更改此选项，请打开方案编辑器，在边栏中选择“Build”并确保在顶部选中“Parallelize Build”。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24de558688d42b286fb70d7cd8d2bf5~tplv-k3u1fbpfcp-watermark.image" alt="2 Shared.png"></p>
<h3 id="1-8-仅构建活动架构"><a href="#1-8-仅构建活动架构" class="headerlink" title="1.8. 仅构建活动架构"></a>1.8. 仅构建活动架构</h3><p>当您的调试配置被选中时，您的项目应该只构建活动架构。默认情况下，此设置应处于活动状态，但值得检查以防万一。</p>
<p>导航到Build Active Architecture Only项目的构建设置中。确保 Debug 设置为Yes并且 release 设置为No。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f37af8023474e8c861ef6559396f053~tplv-k3u1fbpfcp-watermark.image" alt="Bulld Active Architecture Only.png"></p>
<p>确保为您的调试配置将 Build Active Architecture Only 设置为 Yes</p>
<h2 id="2-适当的构建设置"><a href="#2-适当的构建设置" class="headerlink" title="2.适当的构建设置"></a>2.适当的构建设置</h2><h3 id="2-1-优化-dSYM-生成"><a href="#2-1-优化-dSYM-生成" class="headerlink" title="2.1. 优化 dSYM 生成"></a>2.1. 优化 dSYM 生成</h3><p><strong>DWARF：</strong> 是一种广泛使用的标准化调试数据格式。DWARF 最初是与可执行和可链接格式 (ELF) 一起设计的，尽管它独立于目标文件格式。</p>
<p><strong>调试符号 (dSYM)：</strong> 默认情况下，应用程序的调试版本将调试符号存储在已编译的二进制文件中，而应用程序的发布版本将调试符号存储在配套的 dSYM 文件中以减小二进制文件的大小。</p>
<p><em>DWARF</em> 和带有 <em>dSYM</em> 文件的 <em>DWARF</em> 有什么区别？</p>
<p>不同之处在于，对于带有 dSYM 文件的 DWARF，您的存档 app.xcarchive（用于 AdHoc 分发）还包含在崩溃报告中对代码进行反向符号化所需的 dSYM 文件。因此，如果您需要它在归档您的应用程序以进行分发时对崩溃报告进行外部分析，您应该将 DWARF 与 dSYM 文件一起使用。在 OSX 的早期阶段，Apple 不想经历在其链接器中引入<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/DWARF">DWARF</a>支持的麻烦。他们为此目的创建了一个单独的链接器 (dsymutil)，它从目标文件中获取调试信息并将其放在一个普通的地方：一个 dSYM 包。</p>
<p>虽然 dSYM 捆绑包对发布构建很有用，但在开发过程中不需要它们。调试器可以从构建后仍然存在的中间目标文件中获取调试信息。</p>
<p>在 XCode 中，我们可以将构建的“调试信息格式”设置为“DWARF”而不是“DWARF with dSYM File”。</p>
<p>确保您设置Debug Information Format为始终为您的发布版本和未在模拟器上运行的调试版本创建 dSYM 文件。在 iOS 模拟器上运行时不需要创建它们。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0e87fa618eb4c8199c04f747020761f~tplv-k3u1fbpfcp-watermark.image" alt="Debug informatlon Format.png"></p>
<p>在 iOS 模拟器上运行时不应生成 dSYM 文件，但应为所有其他实例生成</p>
<h3 id="2-2-全模块优化-WMO"><a href="#2-2-全模块优化-WMO" class="headerlink" title="2.2. 全模块优化 (WMO)"></a>2.2. 全模块优化 (WMO)</h3><p>在 Xcode 中，我们可以选择三个优化级别：<em>None</em>、<em>Fast</em> 和 <em>Fast</em>、<em>Whole Module Optimization</em>。</p>
<p>使用 Whole Module Optimization 使编译速度非常快。但是选择快速或快速，整个模块优化将不允许开发人员调试应用程序。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269f1b2bab4d40b9b88a2b1091918f74~tplv-k3u1fbpfcp-watermark.image" alt="Faet, Whale.png"></p>
<h3 id="2-3-优化级别"><a href="#2-3-优化级别" class="headerlink" title="2.3 优化级别"></a>2.3 优化级别</h3><p>优化级别有两个不同的部分</p>
<p>1.Apple LLVM 9.0 Code Generation -&gt; Optimization Level -&gt; Debug <strong>GCC_OPTIMIZATION_LEVEL</strong><br>有6个优化级别。</p>
<p>GCC_OPTIMIZATION_LEVEL &#x3D;<br>fast（最快和积极的优化）<br>s（最快和最小）<br>3（最快）<br>2（更快）<br>1（快）<br>0（无）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e028956565440c904685d114381d00~tplv-k3u1fbpfcp-watermark.image" alt="0xyvuOAWqdaJKE5_l.png"></p>
<p>2.Swift Compiler Code Generation -&gt; Optimization Level -&gt; Debug <strong>SWIFT_OPTIMIZATION_LEVEL</strong></p>
<p>有3个优化级别SWIFT_OPTIMIZATION_LEVEL &#x3D;-Onone-O (Fast Single File Optimization)-Owholemodule (Fast, Whole Module Optimization)</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef603635d5db4b9491e1b7b32cecafbf~tplv-k3u1fbpfcp-watermark.image" alt="Optimization Leval.png"></p>
<p>使用<em>Whole Module Optimization</em>使编译速度非常快。但是选择快速或快速，整个模块优化将不允许开发人员调试应用程序。</p>
<h2 id="3-代码优化"><a href="#3-代码优化" class="headerlink" title="3.代码优化"></a>3.代码优化</h2><h3 id="3-1-优化代码"><a href="#3-1-优化代码" class="headerlink" title="3.1 优化代码"></a>3.1 优化代码</h3><p> 我们可以优化代码，这将有助于我们缩短编译时间。我们添加了其他链接器标志-warn-long-function-bodies &amp; -warn-long-expression-type-checking来识别编译时间过长的函数和表达式，现在我们需要手动优化这些表达式或函数.</p>
<ul>
<li>对类本身中扩展 v 的方法中的方法进行基准测试。</li>
<li>添加类型注释，以便编译器不需要推断类型。</li>
<li>避免三元运算符， <strong>?:</strong> 。</li>
<li>通过手动解包来避免使用 nil 合并运算符<strong>if let</strong>。</li>
<li>使用字符串插值而不是连接。</li>
</ul>
<h3 id="3-2-第三方依赖"><a href="#3-2-第三方依赖" class="headerlink" title="3.2 第三方依赖"></a>3.2 第三方依赖</h3><p>有一些非常流行的依赖管理技术&#x2F;工具：Cocoa Pod、Carthage、Swift Package Manager、git Submodule。</p>
<p>在 iOS 项目中处理 3rd 方依赖项的最常见方法是使用 CocoaPods。它使用简单，但如果您关心构建时间，则它不是最佳选择。</p>
<p>您可以使用的一种替代方法是<a target="_blank" rel="noopener" href="https://github.com/Carthage/Carthage">Carthage</a>。它比 CocoaPods 更难使用，但它会缩短您的构建时间。</p>
<h3 id="3-3-优化-CocoaPods"><a href="#3-3-优化-CocoaPods" class="headerlink" title="3.3 优化 CocoaPods"></a>3.3 优化 CocoaPods</h3><p>如果您使用 CocoaPods，您可以通过将以下内容添加到 Podfile 的末尾来优化所有依赖项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">post_install 执行 |installer| </span><br><span class="line"></span><br><span class="line">  installer.pods_project.targets.each 做|目标| </span><br><span class="line"></span><br><span class="line">    target.build_configurations.each 做 |config| </span><br><span class="line"></span><br><span class="line">      如果 config.name == &#x27;Debug&#x27; </span><br><span class="line"></span><br><span class="line">        config.build_settings[&#x27;OTHER_SWIFT_FLAGS&#x27;] = [&#x27;$(inherited)&#x27;, &#x27;-Onone&#x27;] </span><br><span class="line"></span><br><span class="line">        config.build_settings[&#x27;SWIFT_OPTIMIZATION_LEVEL&#x27;] = &#x27;-Owholemodule&#x27; </span><br><span class="line"></span><br><span class="line">      end </span><br><span class="line"></span><br><span class="line">    end </span><br><span class="line"></span><br><span class="line">  end </span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-对代码的小改动"><a href="#3-4-对代码的小改动" class="headerlink" title="3.4 对代码的小改动"></a>3.4 对代码的小改动</h3><ul>
<li>当您知道不需要覆盖声明时，请使用“final”。关键字final是对类、方法或属性的声明的限制，使得声明不能被覆盖。这意味着编译器可以发出直接函数调用而不是间接调用。</li>
<li>当不需要在文件外部访问声明时，使用“private”和“fileprivate”。将private或fileprivate关键字应用于声明会将声明的可见性限制在声明它的文件中。这允许编译器能够确定所有其他可能覆盖的声明。</li>
<li>在数组中使用值类型：在 Swift 中，类型可以分为两个不同的类别：值类型（结构、枚举、元组）和引用类型（类）。一个关键的区别是值类型不能包含在 NSArray 中。因此，当使用值类型时，优化器可以消除 Array 中的大部分开销，这些开销是处理数组支持 NSArray 的可能性所必需的。</li>
<li>其他…</li>
</ul>
<h1 id="二-编译生成中间产物CCache优化"><a href="#二-编译生成中间产物CCache优化" class="headerlink" title="二. 编译生成中间产物CCache优化"></a>二. 编译生成中间产物CCache优化</h1><p><a target="_blank" rel="noopener" href="https://github.com/ccache/ccache"><strong>https://github.com/ccache/ccache</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://ccache.dev/performance.html"><strong>https://ccache.dev/performance.html</strong></a></p>
<p>Ccache 是一个编译器缓存。它通过缓存以前的编译并检测何时再次进行相同的编译来<a target="_blank" rel="noopener" href="https://ccache.dev/performance.html">加速重新编译。</a></p>
<p>cache 的性能取决于很多因素，这使得很难预测给定用例的改进。如果预期命中率较低，则由于缓存未命中的开销（通常为 5%-20%，但启用依赖模式时仅为 1%-3%），使用 ccache 时可能会出现净性能损失). 此外，如果与构建工具（编译器、链接器等）使用的内存量相比构建机器的内存不足，则使用 ccache 可能会降低性能，因为 ccache 的缓存文件可能会刷新操作系统磁盘中的其他文件缓存。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5dfac365c1d4e90b1b94e9566e601c3~tplv-k3u1fbpfcp-watermark.image" alt="CCache流程.png"></p>
<p>优点：</p>
<ol>
<li>无侵入、无影响现有的业务的要求，无入侵、开发人员无感知。</li>
<li>在某些情况下能大幅度地提升编译速度。</li>
<li>不需要对项目作出大调整，只需部署相关环境和一些脚本支持。</li>
<li>不需要改变开发工具链。</li>
<li>同一个目录下，CCache 的缓存命中率相对稳定。</li>
</ol>
<p>存在些某问题：</p>
<ol>
<li>在未有缓存的情况下，首次打包编译的时间比原来的翻近一倍，原来20+min，首次将近40+min，在资源紧张的情况下，甚至是更多。</li>
<li>修改一些引用较多的文件（如公共库、底层库改动），容易造成大范围的缓存失效，速度会变得比原来未使用ccache时更慢。</li>
<li>多个项目相同的组件不支持缓存共享，有多个分支打包的需求，修改目录名称后，缓存即失效。</li>
<li>机器的Ccache有最大的缓存上限，且Debug&#x2F;Release区别缓存，多个项目、多个分支很容易超出上限，一台Ci机器同时支持多个项目会触发CCache清缓存。</li>
<li>对机器硬盘读写要求高，如不是全部固态硬盘，速度影响大。</li>
<li>CCache 不支持 Clang Modules，系统框架例如 AVFoundation、CoreLocation等， Xcode 不会再帮你自动引入，会导致编译失败。</li>
<li>CCache 不支持 PCH 文件</li>
<li>CCache 目前不支持 Swift</li>
</ol>
<h1 id="三-直接生成二进制编译"><a href="#三-直接生成二进制编译" class="headerlink" title="三. 直接生成二进制编译"></a>三. 直接生成二进制编译</h1><p>先看下编译流程，我们每次编译工程大概如下，那么如果能直接省略前边从预处理到生成二进制文件的过程，不就解决了编译时间的问题么。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51d7b2d4f216432d90ee99a13f596a3d~tplv-k3u1fbpfcp-watermark.image" alt="AST.png"></p>
<h2 id="1-cocoapods-binary"><a href="#1-cocoapods-binary" class="headerlink" title="1.cocoapods-binary"></a>1.cocoapods-binary</h2><p>cocoapods-binary 通过开关，在 pod insatll 的过程中进行 library 的预编译，生成 framework，并自动集成到项目中</p>
<p>整个预编译工作分成了三个阶段来完成：</p>
<ul>
<li>binary pod 的安装</li>
<li>binary pod 的预编译</li>
<li>binary pod 的集成</li>
</ul>
<p><strong>Binary Pod 的安装</strong></p>
<p>Binary Pod 的安装作是以 pre_install hook 作为入口，开始插件的运作。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6edd7df942a045278c08a021b230e0e6~tplv-k3u1fbpfcp-watermark.image" alt="pod install.webp"></p>
<p><strong>Binary Pod 的预编译</strong></p>
<p>cocoapods-binary 在下载 binary pod 源码前会先检查是否已经有预编译好的二进制包，如果没有缓存才会开始binary pod 的下载和预编译。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca440e32686345f7b40187e2978d91bf~tplv-k3u1fbpfcp-watermark.image" alt="oodinstall.webp"></p>
<p><strong>binary pod 的集成</strong></p>
<p>具体可以看 <a target="_blank" rel="noopener" href="https://github.com/leavez/cocoapods-binary">https://github.com/leavez/cocoapods-binary</a></p>
<p><strong>存在很多限制</strong></p>
<p>1.CocoaPods 在 1.7 以上版本修改了 framework 生成逻辑，不会把 bundle copy 至 framework，因此需要将 Pod 环境固定到 1.6.2；</p>
<p>2.pod 要支持 binary，header ref 需要变更为 #import &lt;&gt; 或者 @import 以符合 moduler 标准；</p>
<p>3.需要统一开发环境。如果项目支持 Swift，不同 compiler 编译产物有 Swift 版本兼容问题；</p>
<p>4.最终的 binary 体积比使用源码的时候大一点，不建议最终上传 Store</p>
<p>5.如果需要 debug 就需要切换回源码，或者通过 dSYM 映射来完成方法对定位。</p>
<p>6.适用于人数不多的中小型项目。一旦项目依赖库较多，可能就不太适用了，限制太多，同时对开发的要求和环境的一致性要求比较高。</p>
<h2 id="2-cocoapods-imy-bin（前提需要先实现组件化）"><a href="#2-cocoapods-imy-bin（前提需要先实现组件化）" class="headerlink" title="2.  cocoapods-imy-bin（前提需要先实现组件化）"></a>2.  cocoapods-imy-bin（前提需要先实现组件化）</h2><p><strong>优点：</strong></p>
<ol>
<li>无侵入、无影响现有的业务。</li>
<li>不影响未接入二进制化方案的业务团队，提供配置文件。 </li>
<li>只要项目能编译通过就制作，即使独立组件编译失败。</li>
<li>支持无二进制版本时，自动采用源码版本。</li>
<li>支持只需项目能编译通过就能制作二进制组件，无需再关心pod lint等。</li>
<li>支持pod bin local 命令一键自动化制作、上传、存储项目本地已经存在的二进制组件，可配合ci打包的编译产物使用。</li>
<li>支持指定依赖分支、支持:podspec &#x3D;&gt;’’, :git 方式的引用</li>
<li>支持同时 .a、Framework 静态库产出</li>
<li>支持archive时，根据Podfile自动获取podsepc依赖的库，无需强制去spec仓库拉取。</li>
<li>支持多套隔离环境，如Debug&#x2F;Release&#x2F;Dev配置，方便为Debug&#x2F;Release&#x2F;Dev各种环境提供专用二进制组件。</li>
<li>支持输出.a二进制组件制作binary.podsepc无需模板。</li>
<li>支持稳定的二进制组件，在上传二进制组件的binary.podsepc跳过pod lint验证，加快速度。</li>
<li>支持pod bin auto 命令一键自动化制作、上传、存储单个二进制组件</li>
<li>支持pod bin auto –all-make 命令一键自动化制作、上传、存储该项目下所有组件的二进制组件</li>
<li>支持 是否使用二进制文件、是否制作二进制文件和二进制&#x2F;源码调试功能的白名单设置</li>
<li>支持pod install&#x2F;update 多线程模式，加快pod过程，<strong>Pod速度提升80%+</strong> 。</li>
<li>支持pod bin install&#x2F;update 命令，实现无入侵修改Podfile内容，避免直接修改工程的Podfile文件而导致提交冲突、误提交。</li>
<li>支持pod bin code命令，实现二进制库不切换源码库、程序无需重新运行的调试能力</li>
</ol>
<p><strong>缺点：</strong></p>
<p><strong>这个方案的前提是实现组件化</strong></p>
<p>在实施组件私有化后，就真正实现了代码仓库隔离，各业务线同学都会在自己的业务组件内开发，需求开发完成后将 podspec 提交到私有源，壳工程执行 pod update 即可将新开发的业务组件更新下来，就可以直接打包提测了。其实组件拆分算得上是体力活，但这是二进制的基础，这个结构搭不好二进制将无从谈起。</p>
<h3 id="单私有源方案"><a href="#单私有源方案" class="headerlink" title="单私有源方案"></a>单私有源方案</h3><p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/373beffcc7b3467b82fb61b8d5723349~tplv-k3u1fbpfcp-watermark.image" alt="pod 私有库.png"></p>
<p>二进制目前市场上有单私有源、双私有源两种可行方案，下面对这两种方案进行下简单的说明：</p>
<p>单私有源指的是只有一个装 podspec 的私有仓库，也就是上面图中的 PrivateRepo 仓库。那么一个仓库怎么实现源码与二进制的切换呢？其实也很简单，通过在 podspec 配置环境变量即可，总结有如下几步：</p>
<ol>
<li>在 Class 同级目录下创建 Lib 文件夹，将二进制 framework 拷贝其中，并推送至远程仓库</li>
</ol>
<p> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">**├── Assets**</span><br><span class="line"></span><br><span class="line">**│   └── Media.xcassets**</span><br><span class="line"></span><br><span class="line">**│       ├── Contents.json**</span><br><span class="line"></span><br><span class="line">**│       └── cb_fx.imageset**</span><br><span class="line"></span><br><span class="line">**│           ├── Contents.json**</span><br><span class="line"></span><br><span class="line">**├── Classes**</span><br><span class="line"></span><br><span class="line">**│   ├── HelloWorld.h**</span><br><span class="line"></span><br><span class="line">**│   └── HelloWorld.m**</span><br><span class="line"></span><br><span class="line">**└── Lib**</span><br><span class="line"></span><br><span class="line">**└── HelloWorld.framework**</span><br><span class="line"></span><br><span class="line">**├── Headers -&gt; Versions/Current/Headers**</span><br><span class="line"></span><br><span class="line">**├── HelloWorld -&gt; Versions/Current/HelloWorld**</span><br><span class="line"></span><br><span class="line">**├── Resources -&gt; Versions/Current/Resources**</span><br><span class="line"></span><br><span class="line">**└── Versions**</span><br><span class="line"></span><br><span class="line">**├── A**</span><br><span class="line"></span><br><span class="line">**│   ├── Headers**</span><br><span class="line"></span><br><span class="line">**│   │   ├── HelloWorld.h**</span><br><span class="line"></span><br><span class="line">**│   │   ├── ClassA.h**</span><br><span class="line"></span><br><span class="line">**│   │   ├── ClassB.h**</span><br><span class="line"></span><br><span class="line">**│   │   └── ClassC.h**</span><br><span class="line"></span><br><span class="line">**│   ├── HelloWorld**</span><br><span class="line"></span><br><span class="line">**│   └── Resources**</span><br><span class="line"></span><br><span class="line">**│       └── HelloWorld.bundle**</span><br><span class="line"></span><br><span class="line">**│           ├── Assets.car**</span><br><span class="line"></span><br><span class="line">**│           └── Info.plist**</span><br><span class="line"></span><br><span class="line">**└── Current -&gt; A**</span><br></pre></td></tr></table></figure>

<ol>
<li>通过环境变量，修改 podspec 的 sourcefile 指向：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**if ENV[&#x27;IS_SOURCE&#x27;] || ENV[&quot;#&#123;s.name&#125;_SOURCE&quot;]**</span><br><span class="line"></span><br><span class="line">**s.source_files = &quot;#&#123;s.name&#125;/Classes/**/*&quot;**</span><br><span class="line"></span><br><span class="line">**else**</span><br><span class="line"></span><br><span class="line">**s.ios.vendored_frameworks = &quot;#&#123;s.name&#125;/Lib/#&#123;s.name&#125;.framework&quot;**</span><br><span class="line"></span><br><span class="line">**end**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>设置 preserve_paths</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**s.preserve_paths = &quot;#&#123;s.name&#125;/Lib/**/*.framework&quot;,&quot;#&#123;s.name&#125;/Classes/**/*&quot;**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>podspec 中配置 preserve_paths，确保缓存中同时存在源码和二进制的资源及文件，因为 pod 的缓存机制，如果不设置的话在源码和二进制切换时会产生文件的丢失，导致切换时会产生不可预知的问题。</p>
<ol start="3">
<li>将 podspec 发布到 PrivateRepo 即可。</li>
</ol>
<p>完成上面的配置，通过在终端输入：IS_SOURCE pod install 和 pod install 来安装源码和二进制 。如果想要某个库是源码，其他的库为二进制形式，以上图 HelloWorld 为例子，通过输入 HelloWorld_SOURCE pod install 即可让 HelloWorldrepo 为源码形式，其他的组件库为二进制形式。</p>
<p>虽然单私有源单版本的方案可以实现源码与二进制的转换，但是我们觉得这个方案存在以下不妥：</p>
<ol>
<li>如果想要对多个组件进行二进制源码的切换将会非常繁琐，pod 命令因为要在终端输入 SOURCE 的缘故也会变得非常长。</li>
<li>破坏了 pod 的缓存机制，pod 的缓存流程可以简单理解如下：</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5324d71671aa4fdfa9ecb77715efc63b~tplv-k3u1fbpfcp-watermark.image" alt="pod instal.png"></p>
<p>通过上面读取缓存的流程可以看出，如果组件本地只有源码的形式存在，会无法安装二进制，因为本地已经存在了就不会再去 git 上拉取二进制了。这个问题也可以解决，按照上图的思路，将一级和二级缓存删除掉，这样 pod 会直接去下载 git 上的组件进行安装。</p>
<p>考虑到团队内不可能每个人都对这些流程很熟悉的缘故，这会对大家日常工作影响较大，毕竟它对 Cocoapods 的缓存机制有所入侵，另外随着二进制版本增多，git 仓库也会越来越庞大，最终就有了双私有源方案。</p>
<h3 id="双私有源方案"><a href="#双私有源方案" class="headerlink" title="双私有源方案"></a>双私有源方案</h3><p>双私有源的方案是本篇的重点，cocoapods-bin 正是采用的这种方案，它指的是有两个装 podspec 的仓库，一个装源码的 podspec，例如前面说到的 PrivateRepo 仓库，另一个装二进制版本的 podspec，暂时将它起名叫 PrivateRepo_Bin，另外还需要一个静态服务器，用来存储二进制的 zip 包，供别人安装。</p>
<p>双私有源的方案相对单私有源来说稍复杂些，额外需要将二进制包上传到 zip 服务器中，再生成一个二进制版本的 podspec，将其发布到二进制私有源 。让团队的所有同学都来维护二进制版本的 podspec 和二进制 zip 包无疑会严重拖累大家的工作效率，cocoapods-bin 这类插件正是为了解决这些问题，后面会通过 cocoapods-core 源码和 cocoapods-bin 源码来分析二进制插件的背后原理。</p>
<p>源码 podspec 和二进制 podspec 的大致区别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;git&quot;: &quot;https://github.com/xxx/xxx.git&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;tag&quot;: &quot;0.1.0&quot;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;resource_bundles&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;xxx&quot;: [</span><br><span class="line"></span><br><span class="line">      &quot;xxx/Assets/**/*.xcassets&quot;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;source_files&quot;: &quot;xxx/Classes/**/*&quot;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;http&quot;: &quot;http://localhost:8080/frameworks/xxx/0.1.0/zip&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;type&quot;: &quot;zip&quot;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;resources&quot;: [</span><br><span class="line"></span><br><span class="line">    &quot;xxx.framework/Versions/A/Resources/*.bundle&quot;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;ios&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;vendored_frameworks&quot;: &quot;xxx.framework&quot;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>它们主要区别在 source_files 和 vendored_frameworks，将源码的 podspec 修改一下，通过 pod repo push PrivateRepo_Bin HelloMoto.podspec 命令将其发布到 PrivateRepo_Bin 仓库。双私有源的架构图如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d022f76261f34084ad636750576aad5a~tplv-k3u1fbpfcp-watermark.image" alt="pod  二进制.png"></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>iOS 有两种类型的静态库，一种是 .a 后缀，另一种是 .framework 后缀结尾，其实它们本质没有什么区别，都是被多个 .o 打包而成，只不过 .a 是一个纯二进制文件，需要配合 .h 和资源文件一起使用，.framework 内包含头文件和资源文件可以直接使用。但是引用 .framework 需要使用 &lt;&gt; 方式，.a 库可直接使用 “” ，具体使用那种格式可以酌情而定。</p>
<h3 id="二进制打包"><a href="#二进制打包" class="headerlink" title="二进制打包"></a>二进制打包</h3><p><a href="https://link.juejin.cn/?target=https://github.com/square/cocoapods-generate">cocoapods-generate</a></p>
<p>cocoapods-generate 是 cocoapods-packager 作者的另一个插件，它提供了构建工程的能力，和 cocoapods-packager 相比缺失了构建 framework 功能。但它有个好处，不依赖 git，可以直接根据提供的 podspec 文件在本地生成对应的工程。生成工程后，可以自定义打包脚本，使用 xcodebuild 相关命令构建对应二进制。开发 Cocoapods Plugin 的时候，配置上 Gemfile 依赖即可使用 cocoapods-generate：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">group :debug do</span><br><span class="line"></span><br><span class="line">    gem &#x27;ruby-debug-ide&#x27;</span><br><span class="line"></span><br><span class="line">    gem &#x27;debase&#x27;,&#x27;0.2.5.beta1&#x27;</span><br><span class="line"></span><br><span class="line">    gem &#x27;rake&#x27;,&#x27;13.0.0&#x27;</span><br><span class="line"></span><br><span class="line">    gem &quot;cocoapods&quot;, &#x27;1.9.3&#x27;</span><br><span class="line"></span><br><span class="line">    gem &quot;cocoapods-generate&quot;,&#x27;2.0.0&#x27;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行 bundle install 后，就可以直接在插件脚本内使用了：</p>
<h3 id="二进制上传"><a href="#二进制上传" class="headerlink" title="二进制上传"></a>二进制上传</h3><p>二进制上传主要是配置环境：</p>
<ol>
<li>二进制文件上传前需要先搭建 mongodb 数据库，用来存储二进制相关信息，例如包名、版本等。可以直接通过 Homebrew 执行 brew install <a href="mailto:&#109;&#x6f;&#110;&#103;&#111;&#100;&#98;&#x2d;&#x63;&#x6f;&#109;&#109;&#117;&#x6e;&#105;&#116;&#x79;&#x40;&#52;&#x2e;&#50;">&#109;&#x6f;&#110;&#103;&#111;&#100;&#98;&#x2d;&#x63;&#x6f;&#109;&#109;&#117;&#x6e;&#105;&#116;&#x79;&#x40;&#52;&#x2e;&#50;</a> 安装，推荐一个 mongodb 的可视化工具：<a href="https://link.juejin.cn/?target=https://robomongo.org/download?inappupdate">Robo 3T</a>。</li>
<li>下载 <a href="https://link.juejin.cn/?target=https://github.com/tripleCC/binary-server">binary-server</a> 代码，在 mongodb 跑起来之后，cd 到 binary-server 下，执行 npm install 和 npm start。</li>
<li>终端执行上传命令（详细参考 <a href="https://link.juejin.cn/?target=https://github.com/tripleCC/binary-server/blob/master/README.md">binary-server&#x2F;README.md</a>）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;上传url&#x27; -F &quot;name=#&#123;@spec.name&#125;&quot; -F &quot;version=#&#123;@spec.version&#125;&quot; -F &quot;annotate=#&#123;@spec.name&#125;_#&#123;@spec.version&#125;_log&quot; -F &quot;file=@#&#123;zip_file&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建二进制-podspec"><a href="#创建二进制-podspec" class="headerlink" title="创建二进制 podspec"></a>创建二进制 podspec</h3><p>了解二进制 podspec 生成之前，需要先了解 Cocoapods 是如何读取 podspec 文件的。在执行 pod install 后，Cocoapods 在解析依赖的过程中，根据 podfile.lock 指定的版本，构建 Specification（定义在 cocoapod-core 中用来描述 podspec 的对象） 对象。</p>
<p>cocoapods-core&#x2F;specification.rb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def self.from_file(path, subspec_name = nil)</span><br><span class="line"></span><br><span class="line">  #目标 .podspec 的本地路径</span><br><span class="line"></span><br><span class="line">  path = Pathname.new(path)</span><br><span class="line"></span><br><span class="line">  #校验 podspec 是否存在</span><br><span class="line"></span><br><span class="line">  unless path.exist?</span><br><span class="line"></span><br><span class="line">    raise Informative, &quot;No podspec exists at path `#&#123;path&#125;`.&quot;</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  #文件转为 utf-8 格式字符串</span><br><span class="line"></span><br><span class="line">  string = File.open(path, &#x27;r:utf-8&#x27;, &amp;:read)</span><br><span class="line"></span><br><span class="line">  # Work around for Rubinius incomplete encoding in 1.9 mode</span><br><span class="line"></span><br><span class="line">  if string.respond_to?(:encoding) &amp;&amp; string.encoding.name != &#x27;UTF-8&#x27;</span><br><span class="line"></span><br><span class="line">    string.encode!(&#x27;UTF-8&#x27;)</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  #执行或解析string</span><br><span class="line"></span><br><span class="line">  from_string(string, path, subspec_name)</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>cocoapods-core&#x2F;specification.rb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def self.from_string(spec_contents, path, subspec_name = nil)</span><br><span class="line"></span><br><span class="line">  path = Pathname.new(path).expand_path</span><br><span class="line"></span><br><span class="line">  spec = nil</span><br><span class="line"></span><br><span class="line">  case path.extname</span><br><span class="line"></span><br><span class="line">  #解析 .podspec</span><br><span class="line"></span><br><span class="line">  when &#x27;.podspec&#x27;</span><br><span class="line"></span><br><span class="line">    Dir.chdir(path.parent.directory? ? path.parent : Dir.pwd) do</span><br><span class="line"></span><br><span class="line">      #通过 eval 执行 Pod::Specification::DSL 内定义的方法</span><br><span class="line"></span><br><span class="line">      spec = ::Pod._eval_podspec(spec_contents, path)</span><br><span class="line"></span><br><span class="line">      unless spec.is_a?(Specification)</span><br><span class="line"></span><br><span class="line">        raise Informative, &quot;Invalid podspec file at path `#&#123;path&#125;`.&quot;</span><br><span class="line"></span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">   #解析 .json</span><br><span class="line"></span><br><span class="line">  when &#x27;.json&#x27;</span><br><span class="line"></span><br><span class="line">    #string 转为 hash 存储到 Specification 中</span><br><span class="line"></span><br><span class="line">    spec = Specification.from_json(spec_contents)</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">    raise Informative, &quot;Unsupported specification format `#&#123;path.extname&#125;` for spec at `#&#123;path&#125;`.&quot;</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  spec.defined_in_file = path</span><br><span class="line"></span><br><span class="line">  spec.subspec_by_name(subspec_name, true)</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此可以看出，podspec 文件支持两种扩展名，podspec 和 json，分别以不同的方式处理。</p>
<h3 id="关于二进制源码切换（美团方案）"><a href="#关于二进制源码切换（美团方案）" class="headerlink" title="关于二进制源码切换（美团方案）"></a>关于二进制源码切换（美团方案）</h3><p> <a href="https://link.juejin.cn/?target=https://github.com/MeetYouDevs/cocoapods-imy-bin">cocoapods-imy-bin</a>支持源码切换和调试，具体实现原理应该和美团<strong>zsource</strong>类似</p>
<p>Xcode 在编译 Debug 版本的二进制过程中，在二进制中某个字段存储了该二进制所对应的源码的文件地址。当我们在 Xcode 中打断点进行调试的时候，Xcode 会根据二进制中这个字段中存储的源码文件地址，打开对应的源码文件，并在 UI 上展示该源码文件</p>
<p>我们都知道苹果的 Mach-O 二进制文件使用的是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> 这种格式来存放调试相关的数据的。但因为我们很难从这个问题中提炼几个精确的关键词在搜索引擎中检索，所以很难通过简单的几次检索就获取到我们想要的答案：二进制这个字段的名称，在初期甚至无法确定这个字段应该是从 Mach-O 的资料中检索还是从 DWARF 的资料中检索。</p>
<p>通过实验，确定了二进制中源码文件的路径确实是用普通的字符来存储的；紧接着，我们用 MachOViewer 来查看二进制文件，以获取到更友好的二进制信息。利用 MachOViewer，我们可以发现这些信息都存在了二进制的 “__debug_str” Section 中。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202ac433d0d04db79a84ad1bc86e7611~tplv-k3u1fbpfcp-watermark.image" alt="foo.m.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/126540df2b7c46019c8edf1cca596925~tplv-k3u1fbpfcp-watermark.image" alt="d916cfe6bcbcd140837d44932a1a9d0c566355.jpg"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e70329f4c184683ae1a77ff035d5479~tplv-k3u1fbpfcp-watermark.image" alt="AT-nane(userscang3teorkspaceMeftuanZSourcezscVfewController.n.jpg"></p>
<p>AT_name</p>
<p>AT_comp_dir</p>
<p>通过实验，以及找到的这两个字段的描述，我们基本可以确定，即便工程是使用二进制构建，只要二进制 AT_name 字段中的路径存在对应的源码文件，App 一样可以使用源码进行断点调试。这种调试方式除了修改源码再次构建不能生效以外，其他的调试场景都和直接使用源码构建无异。考虑到我们日常的调试场景绝大多数都只需要查看其他组件的源码，并不需要修改，把这个功能工程化还是非常有意义的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>以上功能  <a href="https://link.juejin.cn/?target=https://github.com/MeetYouDevs/cocoapods-imy-bin">cocoapods-imy-bin</a> 基本上都已实现，自己也在项目中运用过，但是遇到了部分库 依赖的问题，导致业务库有些无法生成成功，最后只是尝试在三方库实现了如上流程，也算是一个探索过程。也希望能给大家带来一定的思路和启发。，有兴趣可以去研究下 <a href="https://link.juejin.cn/?target=https://github.com/MeetYouDevs/cocoapods-imy-bin">cocoapods-imy-bin</a> 源码实现。</p>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://ricardo-castellanos-herreros.medium.com/speeding-up-xcode-builds-97173cb1adba">https://ricardo-castellanos-herreros.medium.com/speeding-up-xcode-builds-97173cb1adba</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html">https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6903407900006449160">https://juejin.cn/post/6903407900006449160</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/23/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">iOS 组件化探究</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-23 23:45:07 / Modified: 23:45:34" itemprop="dateCreated datePublished" datetime="2023-04-23T23:45:07+08:00">2023-04-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>iOS 组件化的背景是为了解决单一应用日益庞大、复杂度不断提高导致开发效率低下、维护成本高等问题，项目如果单纯的只是为了开发功能而忽略了模块复用以及架构相关的细节那么可能会造成以下问题。</p>
<ol>
<li>降低了开发效率和代码质量，增加了开发和维护的成本。</li>
<li>导致项目体积过大、启动时间增长等性能问题。</li>
<li>出现组件版本兼容性问题和稳定性问题，影响了整个应用的稳定运行。</li>
<li>增加了多人协作的困难度，影响了团队协作效率。</li>
<li>降低了应用的整体测试覆盖率和质量，增加了上线风险。</li>
<li>功能代码之间的依赖复杂，可维护性差</li>
<li>协同开发过程中，并行开发存在阻塞情况</li>
<li>功能界限不清晰，基础功能模块变动，会导致上层业务受到影响</li>
<li>各团队负责功能模块，在主工程中有耦合代码</li>
<li>上层业务会出现反向提供功能给底层情况</li>
<li>代码分析优化，随代码增加变得困难</li>
</ol>
<p>为了解决这些问题就出现了组件化的方案，组件化可以将一个大型应用拆分成多个小模块，每个模块都是独立的组件，具有明确的职责和功能，可以独立开发、测试和部署。这样可以提高开发效率和协作效率，同时也方便了代码的维护和升级。</p>
<h1 id="组件化的优势"><a href="#组件化的优势" class="headerlink" title="组件化的优势"></a>组件化的优势</h1><ol>
<li>开发效率提高：通过组件化，可以将开发任务分解成多个小模块，每个团队或者开发者只需负责自己的组件开发和迭代，不需要关心整个应用的其他部分。这样可以减少沟通成本、加快迭代速度，提高开发效率。</li>
<li>维护成本降低：随着应用规模的增大，代码维护难度也会逐渐增加。通过组件化，可以将应用拆分成多个小模块，每个模块都是独立的组件，有清晰的职责和功能。这样可以减少代码耦合度，降低代码修改的风险，同时也方便了代码的维护和升级。</li>
<li>协作效率提高：在一个大型的项目中，多个团队或者开发者可能同时进行开发工作。通过组件化，可以将应用拆分成多个小模块，每个模块都是独立的组件，可以独立开发、测试和部署。这样可以避免多人同时修改同一份代码文件的冲突，提高协作效率。</li>
<li>代码复用性增强：在组件化架构中，每个组件都是独立的，可以被其他应用或者项目所复用。这样可以减少代码的重复编写，提高代码的复用性和可维护性。</li>
<li>功能模块化：通过组件化，可以将一个大型应用拆分成多个小模块，每个模块都是独立的组件，具有明确的职责和功能。这样可以使应用的功能更加模块化、清晰、易于扩展和维护。</li>
</ol>
<h1 id="问题挑战"><a href="#问题挑战" class="headerlink" title="问题挑战"></a>问题挑战</h1><p>虽然 iOS 组件化已经有了一定的发展，但是在实际应用中还存在以下问题或挑战：</p>
<ol>
<li>代码冗余：组件化架构中，每个组件都是独立的，具有独立的代码库。当多个组件需要使用同一个功能时，可能会出现代码冗余的情况，导致项目体积过大、编译时间增长等问题。</li>
<li>模块间通信复杂：不同模块之间可能需要进行数据传递和事件交互，这就需要引入通信机制。但是不同的组件之间通信复杂度不同，需要根据实际情况选择合适的通信方式。</li>
<li>组件版本管理：在一个大型应用中，不同的组件可能由不同的开发者或团队维护，并且会存在不同的版本。如何管理各个组件的版本与依赖关系，确保组件的兼容性和稳定性，是一个比较大的问题。</li>
<li>多人协作困难：在组件化开发中，不同组件的开发负责人可能分布在不同的地区，加上组件之间的依赖关系，多人协作会变得非常困难。</li>
<li>单元测试问题：组件化架构下，不同的组件具有独立性，可以进行单独的单元测试。但是在整个应用集成测试时，可能会出现不同组件之间的依赖关系问题，导致测试结果不准确。</li>
</ol>
<p>以上问题或挑战都需要在实践中逐步解决和优化，以提高组件化架构的效率和稳定性。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>iOS 组件化常用方案</p>
<p>两个关键点问题：</p>
<h2 id="1-中间件"><a href="#1-中间件" class="headerlink" title="1.中间件"></a>1.中间件</h2><h2 id="2-整体app设计"><a href="#2-整体app设计" class="headerlink" title="2.整体app设计"></a>2.整体app设计</h2><h3 id="关于App-整体架构"><a href="#关于App-整体架构" class="headerlink" title="关于App 整体架构"></a>关于App 整体架构</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/885438316b704cf99499ccca694107a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以按照三层结构划分</p>
<p>1.业务模块</p>
<p>2.通用的业务模块</p>
<p>3.独立于app的模块</p>
<p>4.中间件模块（此模块主要是贯穿整个组件模块调用）</p>
<h3 id="关于中间件"><a href="#关于中间件" class="headerlink" title="关于中间件"></a>关于中间件</h3><h4 id="1-URL-路由："><a href="#1-URL-路由：" class="headerlink" title="1.  URL 路由："></a>1.  URL 路由：</h4><p>通过定义一系列 URL scheme，不同的组件对应不同的 URL，然后在应用中注册路由表，在接收到特定 URL 时，根据路由表将请求转发到相应的组件中。</p>
<h4 id="2-Target-Action："><a href="#2-Target-Action：" class="headerlink" title="2.  Target-Action："></a>2.  Target-Action：</h4><p>通过在编译期间生成各个组件之间的依赖关系，然后再通过 Runtime 动态加载组件，实现模块之间解耦。</p>
<h4 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3. 依赖注入"></a>3. 依赖注入</h4><p>  依赖注入（Dependency Injection，简称 DI）是一种常见的解决组件化中依赖关系管理问题的方案。在 iOS 组件化场景下，常见的 DI 方案有以下几种：</p>
<p>  a.通过协议和遵循者实现依赖注入：将各个组件之间需要使用的接口抽象出来，定义成协议，然后在应用启动时，通过注册表将不同的实例与相应的协议对应起来。这样，当组件需要使用其他组件提供的服务时，只需要通过协议获得对应的实例即可。</p>
<p>   b.使用属性注入：将需要注入的对象定义成类的属性，然后在外部创建实例时，将需要注入的对象作为参数传入，或者在初始化方法中进行注入。</p>
<p> c. 使用构造函数注入：将需要注入的对象作为构造函数的参数，当外部调用构造函数创建实例时，将需要注入的对象作为参数传入即可。</p>
<p>  d.  使用框架：一些流行的框架，如 Swinject、Dagger 等，提供了更加便捷的依赖注入功能，并且可以结合反射机制、代码生成等技术，自动生成注入代码，大大提高了开发效率。</p>
<p>  e. 比较具有通用性的方法是使用「协议」 &lt;-&gt; 「类」绑定的方式，对于要注入的对象会有对应的 Protocol 进行约束，会经常看到一些RegisterClass:ForProtocol：和classFromProtocol的代码。在需要使用注入对象时，用框架提供的接口以协议作为入参从容器中获得初始化后的所需对象。也可以在 Register 的时候直接注册一段 Block-Code，这个代码块用来初始化自己，作为id类型的返回值返回，可以支持一些编译检查来确保对应代码被编译。</p>
<p>  <strong>可以将一些运行时加载的操作前移至编译时</strong>，比如将各项注册从 +load 改为在编译期使用__attribute((used,section(“__DATA,key”))) 写入 mach-O 文件 Data 的 Segment 中来减少冷启动的时间消耗。下图参考BeeHive思路</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9bc345a2844414d9dfa5e1f80fd287c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>以上都是比较常见的 DI 方案，选择哪种方案取决于具体的项目需求和开发团队的技术栈。需要注意的是，DI 可以解决组件之间依赖关系的问题，但过度依赖 DI 也会增加代码复杂度和维护成本。</p>
<p>以上方式都可以实现 iOS 组件化中间件，选择哪种方式取决于具体的需求和项目情况</p>
<h3 id="3-库文件管理"><a href="#3-库文件管理" class="headerlink" title="3.库文件管理"></a>3.库文件管理</h3><ol>
<li>CocoaPods：使用 CocoaPods 进行库依赖管理，并且将每个组件封装成一个独立的 Pod。这样当需要使用某个组件时，只需在 Podfile 中添加对应的 Pod 即可。</li>
<li>Framework：将每个组件封装成独立的 Framework，然后在应用中动态链接需要使用的 Framework，避免了组件之间的直接引用。</li>
</ol>
<h2 id="3-中间件优缺点"><a href="#3-中间件优缺点" class="headerlink" title="3.中间件优缺点"></a>3.中间件优缺点</h2><h3 id="1-URL-路由"><a href="#1-URL-路由" class="headerlink" title="1.  URL 路由"></a>1.  URL 路由</h3><p>优点：</p>
<ul>
<li>实现简单，易于理解和使用；</li>
<li>可以根据 URL 的特定格式来管理组件之间的依赖关系。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要手动维护路由表，容易出现冗余和错误；</li>
<li>依赖于 URL scheme，存在命名空间冲突的风险。</li>
</ul>
<h3 id="2-Target-Action"><a href="#2-Target-Action" class="headerlink" title="2.  Target-Action"></a>2.  Target-Action</h3><p>优点：</p>
<ul>
<li>编译期生成依赖关系，保证了类型安全；</li>
<li>可以使用反射机制进行运行时注入。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码量较大，需要手动处理每个模块间的依赖关系；</li>
<li>对于多层嵌套的依赖关系，使用起来比较繁琐。</li>
</ul>
<h3 id="3-依赖注入-1"><a href="#3-依赖注入-1" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h3><p>优点:</p>
<ul>
<li>面向协议接口编程，可以传递任何类型参数。</li>
<li>模块依赖只需要依赖接口头文件即可。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码块存取的性能消耗较大。</li>
<li>并且协议与类的绑定关系的维护需要花费更多的时间成本。</li>
</ul>
<h2 id="4-工具优缺点"><a href="#4-工具优缺点" class="headerlink" title="4.工具优缺点"></a>4.工具优缺点</h2><h3 id="1-CocoaPods"><a href="#1-CocoaPods" class="headerlink" title="1.  CocoaPods"></a>1.  CocoaPods</h3><p>优点：</p>
<ul>
<li>管理依赖关系简单，易于维护；</li>
<li>可以将每个组件封装成 Pod，方便其他应用或项目复用。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能在应用内动态加载组件，需要重新编译整个应用；</li>
<li>需要引入外部依赖库，增加了应用的大小和启动时间。</li>
</ul>
<h3 id="2-Framework"><a href="#2-Framework" class="headerlink" title="2.  Framework"></a>2.  Framework</h3><p>优点：</p>
<ul>
<li>集成方便，只需要动态链接需要使用的 Framework 即可；</li>
<li>可以将每个组件封装成独立的 Framework，降低了耦合度。</li>
</ul>
<p>缺点：</p>
<ul>
<li>维护多个 Framework 需要一定的技术水平；</li>
<li>不能动态加载和卸载组件，需要重新编译整个应用。</li>
</ul>
<p>总的来说，每种方案都有其优劣，选择哪种方案取决于具体的项目需求和开发团队的技术栈。需要权衡各种因素，选择最适合自己的方案。</p>
<h2 id="5-业内组件化中间件方案细节"><a href="#5-业内组件化中间件方案细节" class="headerlink" title="5.业内组件化中间件方案细节"></a>5.业内组件化中间件方案细节</h2><h3 id="1-URL-Router"><a href="#1-URL-Router" class="headerlink" title="1.URL-Router"></a>1.URL-Router</h3><p><a target="_blank" rel="noopener" href="https://github.com/lightory/HHRouter">https://github.com/lightory/HHRouter</a></p>
<p>URL Router 是一种常用的 iOS 开发模式，用于实现基于 URL 的页面跳转、参数传递等功能。其大致实现流程可以概括如下：</p>
<ol>
<li>定义每个页面对应的 URL 地址，并在 URL Router 中注册这些地址和对应的控制器类。</li>
<li>当用户点击某个链接或执行某个跳转操作时，将对应的 URL 传递给 URL Router。</li>
<li>URL Router 根据注册的 URL 与控制器类的映射关系，找到对应的控制器类，并创建该控制器类的实例对象。</li>
<li>URL Router 将该实例对象返回给调用者，调用者可以通过该实例对象来操作对应的页面。</li>
</ol>
<p>以下是 URL Router 实现流程的简单示意图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3749890c100f4ebf8de282b7644f634a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上述流程图说明了 URL Router 的基本实现流程。需要注意的是，URL Router 可以根据传递的 URL 参数进行页面跳转和参数传递等操作，因此在设计和实现 URL Router 时需要考虑参数的安全性和可靠性。</p>
<h3 id="2-Target-Action-1"><a href="#2-Target-Action-1" class="headerlink" title="2.Target-Action"></a>2.Target-Action</h3><p><a target="_blank" rel="noopener" href="https://github.com/casatwy/CTMediator">https://github.com/casatwy/CTMediator</a></p>
<p>CTMediator 是一种常用的 iOS 开发模式，用于实现组件化架构中的组件间通信。其大致实现流程可以概括如下：</p>
<ol>
<li>创建一个 CTMediator 对象，并在该对象中定义需要暴露给其他组件使用的方法。</li>
<li>在其他组件中引入 CTMediator 头文件，并通过 CTMediator 对象调用相应的方法。</li>
<li>CTMediator 对象根据方法名和参数信息，在运行时动态地创建对应的控制器或执行对应的操作。</li>
<li>CTMediator 将创建出来的控制器或执行结果返回给调用者。</li>
</ol>
<p>以下是 URL Router 实现流程的简单示意图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40b1e67e893487ab6bcb1c16404d415~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上述流程图说明了 CTMediator 的基本实现流程，其中组件 A 和组件 B 都可以通过 CTMediator 对象调用相应的方法，而 CTMediator 对象会根据方法名和参数信息，在运行时动态地创建对应的控制器或执行对应的操作，并将创建出来的控制器或执行结果返回给调用者。</p>
<h3 id="3-依赖注入-2"><a href="#3-依赖注入-2" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h3><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/BeeHive">https://github.com/alibaba/BeeHive</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d2f707b95b45909a3a8581c3a4fee4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>Beehive是由阿里巴巴开源的一款基于组件化的框架，用于解决大型复杂应用程序的可维护性、可扩展性和代码复用等问题。Beehive的核心概念是Module（模块），每个Module都包含了一个或多个协议（Protocol）和相应的实现（Implementation），并且在运行时通过Beehive容器对Module进行管理和调用。</p>
<ol>
<li>创建Module：创建一个或多个Module，每个Module包含一个或多个Protocol（协议）。</li>
<li>实现Module：实现Module中所定义的Protocol。</li>
<li>注册Module：在App启动时将Module注册到Beehive容器中或者推迟到使用时候创建。</li>
<li>获取Module：需要使用Module时，从Beehive容器中获取该Module的实例。</li>
<li>使用Module：使用Module提供的接口完成相应的功能。</li>
</ol>
<p>总之，使用Beehive实现流程图需要先安装Beehive，然后创建、实现、注册Module并在需要使用Module时从Beehive容器中获取实例。</p>
<p>在Beehive中，模块（Module）被定义为一组协议（Protocol）和实现（Implementation），Beehive容器则用来管理各个模块的注册、查找和调用等操作。通过Beehive提供的API，应用程序可以方便地获取其他模块提供的服务，并且无需关心具体的实现细节，BeeHive框架实现思路不仅仅有依赖注入还有appdelegate 模块的一些启发，这里不在讲解，有兴趣可以去看源码实现，附上BeeHive的几个模块注册方法和AppDelegate解耦的思路</p>
<p>注册方案:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24ef8867d170459e968353b60c0b4098~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc2aef62be214ac19578f792b4e80232~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76aa435cce764c118432e04f870e0012~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>AppDelegate解耦方案:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9553123dcbc34106921042e1054a6bd8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="6-实现细节"><a href="#6-实现细节" class="headerlink" title="6.实现细节"></a>6.实现细节</h2><p>  细节不在讲，有兴趣可以看源码实现。</p>
<h2 id="7-性能对比"><a href="#7-性能对比" class="headerlink" title="7.性能对比"></a>7.性能对比</h2><h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><p>CTMediator 是用 runtime msgsend 实现的执行效率最优。<br>URL-Router 多了一层解析逻辑因此效率略低于 依赖注入。</p>
<h3 id="对比排序"><a href="#对比排序" class="headerlink" title="对比排序"></a>对比排序</h3><p>CTMediator&gt;依赖注入&gt;URL-Router</p>
<h2 id="8-我的理解"><a href="#8-我的理解" class="headerlink" title="8.我的理解"></a>8.我的理解</h2><p>URL Router、Target-Action 和依赖注入都是 iOS 组件化的常见方案。</p>
<p>URL Router 是一种通过定义一系列 URL Scheme，将各个组件对应到不同的 URL 上，然后在应用中注册路由表，在接收到特定 URL 时，根据路由表将请求转发到相应的组件中的方案。这种方案实现简单，易于理解和使用，但需要手动维护路由表，存在冗余和错误的风险。</p>
<p>Target-Action 是一种通过在编译期间生成各个组件之间的依赖关系，然后再通过 Runtime 动态加载组件，实现模块之间解耦的方案。这种方案可以保证类型安全，并且可以使用反射机制进行运行时注入，但需要手动处理每个模块之间的依赖关系，对于多层嵌套的依赖关系使用起来比较繁琐。</p>
<p>依赖注入是一种通过协议和遵循者实现依赖注入的方案。将各个组件之间需要使用的接口抽象出来，定义成协议，然后在应用启动时，通过注册表将不同的实例与相应的协议对应起来。这种方案可以解决组件之间依赖关系的问题，但过度依赖 DI 也会增加代码复杂度和维护成本。</p>
<p>从性能，可读性，功能性，代码量，规范约束 几个维度综合考虑我建议</p>
<p>CTMediator &gt; 依赖注入 &gt; URL-Router</p>
<p>*当然选择哪种方案取决于具体的项目需求和开发团队的技术栈，需要权衡各种因素，选择最适合自己的方案，以上仅代表个人观点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/22/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/22/flutter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">flutter 生命周期详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-22 11:22:43 / Modified: 11:23:01" itemprop="dateCreated datePublished" datetime="2023-04-22T11:22:43+08:00">2023-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们在学习某个新技术的时候，首先至关重要的是要去了解他的一个整体流程如生命周期等，这样我们在学习和使用的过程才能对技术细节把控，以下主要讲解生命周期相关细节。</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><strong>先看图</strong>:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee71979562404a89aceeaecbbfa3eaf5~tplv-k3u1fbpfcp-watermark.image" alt="2-5.a59bef97.jpg"></p>
<p>Flutter的生命周期主要包含以下内容：</p>
<h2 id="1-initState-：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。"><a href="#1-initState-：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。" class="headerlink" title="1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。"></a>1.  initState()：此方法仅在小部件插入到树中时调用一次，可以在此处执行小部件初始化操作。</h2><p>initState：当 widget 第一次插入到 widget 树时会被调用，对于每一个State对象，Flutter 框架只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用BuildContext.dependOnInheritedWidgetOfExactType（该方法用于在 widget 树上获取离当前 widget 最近的一个父级InheritedWidget，关于InheritedWidget我们将在后面章节介绍），原因是在初始化完成后， widget 树中的InheritFrom widget也可能会发生变化，所以正确的做法应该在在build（）方法或didChangeDependencies()中调用它</p>
<h2 id="2-didChangeDependencies-：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。"><a href="#2-didChangeDependencies-：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。" class="headerlink" title="2.  didChangeDependencies()：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。"></a>2.  didChangeDependencies()：此方法仅在小部件首次构建时被调用。如果该小部件依赖于父级小部件，则当父级更改时，将再次调用此方法。</h2><p>当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget ，然后在之后的build() 中Inherited widget发生了变化，那么此时InheritedWidget的子 widget 的didChangeDependencies()回调都会被调用。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter 框架会通知 widget 调用此回调。需要注意，组件第一次被创建后挂载的时候（包括重创建）对应的didChangeDependencies也会被调用</p>
<h2 id="3-build-：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。"><a href="#3-build-：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。" class="headerlink" title="3.  build()：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。"></a>3.  build()：此方法是构建小部件本身的地方，并且是必需的。每当需要更改UI时，系统会自动调用此方法。</h2><p> build()：此回调读它主要是用于构建 widget 子树的，会在如下场景被调用：</p>
<ul>
<li><ol>
<li>在调用initState()之后。</li>
</ol>
</li>
<li><ol start="2">
<li>在调用didUpdateWidget()之后。</li>
</ol>
</li>
<li><ol start="3">
<li>在调用setState()之后。</li>
</ol>
</li>
<li><ol start="4">
<li>在调用didChangeDependencies()之后。</li>
</ol>
</li>
<li><ol start="5">
<li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其他位置之后。</li>
</ol>
</li>
</ul>
<h2 id="4-didUpdateWidget-：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。"><a href="#4-didUpdateWidget-：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。" class="headerlink" title="4.  didUpdateWidget()：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。"></a>4.  didUpdateWidget()：如果同一个小部件多次插入到树中，则会调用此方法。您可以在此方法中检查前后小部件属性的变化，并相应地更新小部件状态。</h2><p>在 widget 重新构建时，Flutter 框架会调用widget.canUpdate来检测 widget 树中同一位置的新旧节点，然后决定是否需要更新，如果widget.canUpdate返回true则会调用此回调。正如之前所述，widget.canUpdate会在新旧 widget 的 key 和 runtimeType 同时相等时会返回true，也就是说在在新旧 widget 的key和runtimeType同时相等时didUpdateWidget()就会被调用。</p>
<h2 id="5-setState-：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。"><a href="#5-setState-：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。" class="headerlink" title="5.  setState()：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。"></a>5.  setState()：如果您需要更改小部件状态并使其重新生成UI，则可以调用此方法。它会通知框架重建小部件的UI。</h2><p>setState 在使用过程中可能会引起有些不必要的渲染可以使用</p>
<p><strong>ValueListenableBuilder</strong> 做优化</p>
<h2 id="6-deactivate-：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。"><a href="#6-deactivate-：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。" class="headerlink" title="6.  deactivate()：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。"></a>6.  deactivate()：当小部件从树中删除时，将调用此方法。此时，小部件被视为“停用”。</h2><p>当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter 框架会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。</p>
<h2 id="7-dispose-：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。"><a href="#7-dispose-：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。" class="headerlink" title="7.  dispose()：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。"></a>7.  dispose()：该方法仅在小部件永久从树中删除时调用，可以在此处执行资源清理或释放操作。</h2><p>当 State 对象从树中被永久移除时调用；通常在此回调中释放资源。</p>
<h2 id="其他-reassemble"><a href="#其他-reassemble" class="headerlink" title="其他 reassemble()"></a>其他 reassemble()</h2><p>reassemble()：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</p>
<p>以上主要为整个生命周期的过程方法。</p>
<h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><p>布局过程4步骤</p>
<ol>
<li>父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。</li>
<li>子节点根据约束信息确定自己的大小（size）。</li>
<li>父节点根据特定布局规则（不同布局组件会有不同的布局算法）确定每一个子节点在父节点布局空间中的位置，用偏移 offset 表示。</li>
<li>递归整个过程，确定出每一个节点的大小和位置。</li>
</ol>
<p>可以看到，组件的大小是由自身决定的，而组件的位置是由父组件决定的。</p>
<p>Flutter 中的布局类组件很多，根据孩子数量可以分为单子组件和多子组件，下面我们先通过分别自定义一个单子组件和多子组件来直观理解一下Flutter的布局过程，之后会介绍一下布局更新过程和 Flutter 中的 Constraints（约束）。</p>
<h1 id="flutter-布局更新"><a href="#flutter-布局更新" class="headerlink" title="flutter 布局更新"></a>flutter 布局更新</h1><p><strong>对于更新边界是一个非常重要的知识点，对于我们实现高性能刷新绘制有很大的作用。</strong></p>
<h2 id="1-布局边界"><a href="#1-布局边界" class="headerlink" title="1.布局边界"></a>1.布局边界</h2><p>理论上，某个组件的布局变化后，就可能会影响其他组件的布局，所以当有组件布局发生变化后，最笨的办法是对整棵组件树 relayout（重新布局）！但是对所有组件进行 relayout 的成本还是太大，所以我们需要探索一下降低 relayout 成本的方案。实际上，在一些特定场景下，组件发生变化后我们只需要对部分组件进行重新布局即可（而无需对整棵树 relayout ）。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ebbdfb10924caaa2fd01207a0e4cad~tplv-k3u1fbpfcp-watermark.image" alt="Rondorview.png"></p>
<p><strong>上图</strong> 假如 Text3 的文本长度发生变化，则会导致 Text4 的位置和 Column2 的大小也会变化；又因为 Column2 的父组件 SizedBox 已经限定了大小，所以 SizedBox 的大小和位置都不会变化。所以最终我们需要进行 relayout 的组件是：Text3、Column2，这里需要注意：</p>
<ol>
<li>Text4 是不需要重新布局的，因为 Text4 的大小没有发生变化，只是位置发生变化，而它的位置是在父组件 Column2 布局时确定的。</li>
<li>很容易发现：假如 Text3 和 Column2 之间还有其他组件，则这些组件也都是需要 relayout 的。</li>
</ol>
<p>在本例中，Column2 就是 Text3 的 relayoutBoundary （重新布局的边界节点）。每个组件的 renderObject 中都有一个 _relayoutBoundary 属性指向自身的布局边界节点，如果当前节点布局发生变化后，自身到其布局边界节点路径上的所有的节点都需要 relayout。</p>
<p>那么，一个组件是否是 relayoutBoundary 的条件是什么呢？这里有一个原则和四个场景，原则是“组件自身的大小变化不会影响父组件”，如果一个组件满足以下四种情况之一，则它便是 relayoutBoundary ：</p>
<h3 id="1-当前组件父组件的大小不依赖当前组件大小时；"><a href="#1-当前组件父组件的大小不依赖当前组件大小时；" class="headerlink" title="1.  当前组件父组件的大小不依赖当前组件大小时；"></a>1.  当前组件父组件的大小不依赖当前组件大小时；</h3><p> 这种情况下父组件在布局时会调用子组件布局函数时并会给子组件传递一个 parentUsesSize 参数，该参数为 false 时表示父组件的布局算法不会依赖子组件的大小。</p>
<h3 id="2-组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。"><a href="#2-组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。" class="headerlink" title="2.  组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。"></a>2.  组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。</h3><p> 这样的话后代组件的大小变化就不会影响自身的大小了，这种情况组件的 sizedByParent 属性必须为 true。</p>
<h3 id="3-父组件传递给自身的约束是一个严格约束（固定宽高）；"><a href="#3-父组件传递给自身的约束是一个严格约束（固定宽高）；" class="headerlink" title="3.  父组件传递给自身的约束是一个严格约束（固定宽高）；"></a>3.  父组件传递给自身的约束是一个严格约束（固定宽高）；</h3><p> 这种情况下即使自身的大小依赖后代元素，但也不会影响父组件。</p>
<h3 id="4-组件为根组件；"><a href="#4-组件为根组件；" class="headerlink" title="4.  组件为根组件；"></a>4.  组件为根组件；</h3><p> Flutter 应用的根组件是 RenderView，它的默认大小是当前设备屏幕大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line">  _relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-markNeedsLayout"><a href="#2-markNeedsLayout" class="headerlink" title="2. markNeedsLayout"></a>2. markNeedsLayout</h2><p>当组件布局发生变化时，它需要调用 markNeedsLayout 方法来更新布局，它的功能主要有两个：</p>
<ol>
<li>将自身到其 relayoutBoundary 路径上的所有节点标记为 “需要布局” 。</li>
<li>请求新的 frame；在新的 frame 中会对标记为“需要布局”的节点重新布局。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void markNeedsLayout() &#123;</span><br><span class="line"></span><br><span class="line">   _needsLayout = true;</span><br><span class="line"></span><br><span class="line">  if (_relayoutBoundary != this) &#123; // 如果不是布局边界节点</span><br><span class="line"></span><br><span class="line">    markParentNeedsLayout(); // 递归调用前节点到其布局边界节点路径上所有节点的方法 markNeedsLayout</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;// 如果是布局边界节点 </span><br><span class="line"></span><br><span class="line">    if (owner != null) &#123;</span><br><span class="line"></span><br><span class="line">      // 将布局边界节点加入到 pipelineOwner._nodesNeedingLayout 列表中</span><br><span class="line"></span><br><span class="line">      owner!._nodesNeedingLayout.add(this); </span><br><span class="line"></span><br><span class="line">      owner!.requestVisualUpdate();//该函数最终会请求新的 frame</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="3-flushLayout"><a href="#3-flushLayout" class="headerlink" title="3. flushLayout()"></a>3. flushLayout()</h2><p>markNeedsLayout 执行完毕后，就会将其 relayoutBoundary 节点添加到 pipelineOwner._nodesNeedingLayout 列表中，然后请求新的 frame，新的 frame 到来时就会执行 drawFrame 方法（</p>
<p>flushLayout() 中会对之前添加到 _nodesNeedingLayout 中的节点重新布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void flushLayout() &#123;</span><br><span class="line"></span><br><span class="line">  while (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line"></span><br><span class="line">    final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line"></span><br><span class="line">    _nodesNeedingLayout = &lt;RenderObject&gt;[]; </span><br><span class="line"></span><br><span class="line">    //按照节点在树中的深度从小到大排序后再重新layout</span><br><span class="line"></span><br><span class="line">    for (final RenderObject node in dirtyNodes..sort((a,b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line"></span><br><span class="line">      if (node._needsLayout &amp;&amp; node.owner == this)</span><br><span class="line"></span><br><span class="line">        node._layoutWithoutResize(); //重新布局</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 flushLayout() 中刷新布局时要先对dirtyNodes 根据在树中的深度按照从小到大排序？从大到小不行吗？</p>
<ul>
<li>因为节点更新是从父节点到子节点以此跟新，如果颠倒了顺序会带来不必要的更新操作，大大影响了性能。</li>
</ul>
<h2 id="4-Layout流程"><a href="#4-Layout流程" class="headerlink" title="4. Layout流程"></a>4. Layout流程</h2><p>如果组件有子组件，则在 performLayout 中需要调用子组件的 layout 方法先对子组件进行布局， layout 的核心流程如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123;</span><br><span class="line"></span><br><span class="line">  RenderObject? relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  // 先确定当前组件的布局边界</span><br><span class="line"></span><br><span class="line">  if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line"></span><br><span class="line">    relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // _needsLayout 表示当前组件是否被标记为需要布局</span><br><span class="line"></span><br><span class="line">  // _constraints 是上次布局时父组件传递给当前组件的约束</span><br><span class="line"></span><br><span class="line">  // _relayoutBoundary 为上次布局时当前组件的布局边界</span><br><span class="line"></span><br><span class="line">  // 所以，当当前组件没有被标记为需要重新布局，且父组件传递的约束没有发生变化，</span><br><span class="line"></span><br><span class="line">  // 且布局边界也没有发生变化时则不需要重新布局，直接返回即可。</span><br><span class="line"></span><br><span class="line">  if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果需要布局，缓存约束和布局边界</span><br><span class="line"></span><br><span class="line">  _constraints = constraints;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 后面解释</span><br><span class="line"></span><br><span class="line">  if (sizedByParent) &#123;</span><br><span class="line"></span><br><span class="line">    performResize();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 执行布局</span><br><span class="line"></span><br><span class="line">  performLayout();</span><br><span class="line"></span><br><span class="line">  // 布局结束后将 _needsLayout 置为 false</span><br><span class="line"></span><br><span class="line">  _needsLayout = false;</span><br><span class="line"></span><br><span class="line">  // 将当前组件标记为需要重绘（因为布局发生变化后，需要重新绘制）</span><br><span class="line"></span><br><span class="line">  markNeedsPaint();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>简单来讲布局过程分以下几步：</p>
<ol>
<li>确定当前组件的布局边界。</li>
<li>判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局时需要同时满足三个条件：</li>
</ol>
<ul>
<li>当前组件没有被标记为需要重新布局。</li>
<li>父组件传递的约束没有发生变化。</li>
<li>当前组件的布局边界也没有发生变化时。</li>
</ul>
<ol start="3">
<li>调用 performLayout() 进行布局，因为 performLayout() 中又会调用子组件的 layout 方法，所以这时一个递归的过程，递归结束后整个组件树的布局也就完成了。</li>
<li>请求重绘。</li>
</ol>
<h3 id="sizedByParent"><a href="#sizedByParent" class="headerlink" title="sizedByParent"></a>sizedByParent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (sizedByParent) &#123;</span><br><span class="line"></span><br><span class="line">  performResize(); //重新确定组件大小</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sizedByParent 为 true 时表示：当前组件的大小只取决于父组件传递的约束，而不会依赖后代组件的大小。前面我们说过，performLayout 中确定当前组件的大小时通常会依赖子组件的大小，如果 sizedByParent 为 true，则当前组件的大小就不依赖子组件大小了，为了逻辑清晰，Flutter 框架中约定，当sizedByParent 为 true 时，确定当前组件大小的逻辑应抽离到 performResize() 中，这种情况下 performLayout 主要的任务便只有两个：对子组件进行布局和确定子组件在当前组件中的布局起始位置偏移</p>
<p>通过一个 AccurateSizedBox 示例来演示一下 sizedByParent 为 true 时我们应该如何布局：</p>
<h3 id="AccurateSizedBox"><a href="#AccurateSizedBox" class="headerlink" title="AccurateSizedBox"></a>AccurateSizedBox</h3><p>Flutter 中的 SizedBox 组件会将其父组件的约束传递给其子组件，这也就意味着，如果父组件限制了最小宽度为100，即使我们通过 SizedBox 指定宽度为50，那也是没用的，<strong>因为 SizedBox的实现中会让 SizedBox 的子组件先满足 SizedBox 父组件的约束</strong>。还记得之前我们想在 AppBar 中限制 loading 组件大小的例子吗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AppBar(</span><br><span class="line"></span><br><span class="line">    title: Text(title),</span><br><span class="line"></span><br><span class="line">    actions: &lt;Widget&gt;[</span><br><span class="line"></span><br><span class="line">      SizedBox( // 尝试使用SizedBox定制loading 宽高</span><br><span class="line"></span><br><span class="line">        width: 20, </span><br><span class="line"></span><br><span class="line">        height: 20,</span><br><span class="line"></span><br><span class="line">        child: CircularProgressIndicator(</span><br><span class="line"></span><br><span class="line">          strokeWidth: 3,</span><br><span class="line"></span><br><span class="line">          valueColor: AlwaysStoppedAnimation(Colors.white70),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a97e15eff5244ee39741947dd5b2918a~tplv-k3u1fbpfcp-watermark.image" alt="尺寸限制类容器.png"></p>
<p>之所以不生效，是因为父组件限制了最小高度，当然我们也可以使用 UnconstrainedBox + SizedBox 来实现我们想要的效果，但是这里我们希望通过一个组件就能搞定，为此我们自定义一个 AccurateSizedBox 组件，它和 SizedBox 的主要区别是 AccurateSizedBox 自身会遵守其父组件传递的约束<strong>而不是让其子组件去满足AccurateSizedBox 父组件的约束</strong>，具体：</p>
<ol>
<li>AccurateSizedBox 自身大小只取决于父组件的约束和用户指定的宽高。</li>
<li>AccurateSizedBox 确定自身大小后，限制其子组件大小。</li>
</ol>
<p>根据上边的几个规则找到解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = this;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  _relayoutBoundary = (parent! as RenderObject)._relayoutBoundary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AccurateSizedBox extends SingleChildRenderObjectWidget &#123;</span><br><span class="line"></span><br><span class="line">  const AccurateSizedBox(&#123;</span><br><span class="line"></span><br><span class="line">    Key? key,</span><br><span class="line"></span><br><span class="line">    this.width = 0,</span><br><span class="line"></span><br><span class="line">    this.height = 0,</span><br><span class="line"></span><br><span class="line">    required Widget child,</span><br><span class="line"></span><br><span class="line">  &#125;) : super(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  final double width;</span><br><span class="line"></span><br><span class="line">  final double height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    return RenderAccurateSizedBox(width, height);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void updateRenderObject(context, RenderAccurateSizedBox renderObject) &#123;</span><br><span class="line"></span><br><span class="line">    renderObject</span><br><span class="line"></span><br><span class="line">      ..width = width</span><br><span class="line"></span><br><span class="line">      ..height = height;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RenderAccurateSizedBox extends RenderProxyBoxWithHitTestBehavior &#123;</span><br><span class="line"></span><br><span class="line">  RenderAccurateSizedBox(this.width, this.height);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  double width;</span><br><span class="line"></span><br><span class="line">  double height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 当前组件的大小只取决于父组件传递的约束</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  bool get sizedByParent =&gt; true;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // performResize 中会调用</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Size computeDryLayout(BoxConstraints constraints) &#123;</span><br><span class="line"></span><br><span class="line">    //设置当前元素宽高，遵守父组件的约束</span><br><span class="line"></span><br><span class="line">    return constraints.constrain(Size(width, height));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // @override</span><br><span class="line"></span><br><span class="line">  // void performResize() &#123;</span><br><span class="line"></span><br><span class="line">  //   // default behavior for subclasses that have sizedByParent = true</span><br><span class="line"></span><br><span class="line">  //   size = computeDryLayout(constraints);</span><br><span class="line"></span><br><span class="line">  //   assert(size.isFinite);</span><br><span class="line"></span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">    child!.layout(</span><br><span class="line"></span><br><span class="line">      BoxConstraints.tight(</span><br><span class="line"></span><br><span class="line">          Size(min(size.width, width), min(size.height, height))),</span><br><span class="line"></span><br><span class="line">      // 父容器是固定大小，子元素大小改变时不影响父元素</span><br><span class="line"></span><br><span class="line">      // parentUseSize为false时，子组件的布局边界会是它自身，子组件布局发生变化后不会影响当前组件</span><br><span class="line"></span><br><span class="line">      parentUsesSize: false,</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>上面代码有三点需要注意：</p>
<ol>
<li>我们的 RenderAccurateSizedBox 不再直接继承自 RenderBox，而是继承自 RenderProxyBoxWithHitTestBehavior，RenderProxyBoxWithHitTestBehavior 是间接继承自 RenderBox的，它里面包含了默认的命中测试和绘制相关逻辑，继承自它后就不用我们再手动实现了。</li>
<li>我们将确定当前组件大小的逻辑挪到了computeDryLayout 方法中，因为RenderBox 的 performResize 方法会调用 computeDryLayout ，并将返回结果作为当前组件的大小。按照Flutter 框架约定，我们应该重写computeDryLayout 方法而不是 performResize 方法，就像在布局时我们应该重写 performLayout 方法而不是 layout 方法；不过，这只是一个约定，并非强制，但我们应该尽可能遵守这个约定，除非你清楚的知道自己在干什么并且能确保之后维护你代码的人也清楚。</li>
<li>RenderAccurateSizedBox 在调用子组件 layout 时，将 parentUsesSize 置为 false，这样的话子组件就会变成一个布局边界。</li>
</ol>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AccurateSizedBoxRoute extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  const AccurateSizedBoxRoute(&#123;Key? key&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    final child = GestureDetector(</span><br><span class="line"></span><br><span class="line">      onTap: () =&gt; print(&quot;tap&quot;),</span><br><span class="line"></span><br><span class="line">      child: Container(width: 300, height: 300, color: Colors.red),</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return Row(</span><br><span class="line"></span><br><span class="line">      children: [</span><br><span class="line"></span><br><span class="line">        ConstrainedBox(</span><br><span class="line"></span><br><span class="line">          constraints: BoxConstraints.tight(Size(100, 100)),</span><br><span class="line"></span><br><span class="line">          child: SizedBox(</span><br><span class="line"></span><br><span class="line">            width: 50,</span><br><span class="line"></span><br><span class="line">            height: 50,</span><br><span class="line"></span><br><span class="line">            child: child,</span><br><span class="line"></span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        Padding(</span><br><span class="line"></span><br><span class="line">          padding: const EdgeInsets.only(left: 8),</span><br><span class="line"></span><br><span class="line">          child: ConstrainedBox(</span><br><span class="line"></span><br><span class="line">            constraints: BoxConstraints.tight(Size(100, 100)),</span><br><span class="line"></span><br><span class="line">            child: AccurateSizedBox(</span><br><span class="line"></span><br><span class="line">              width: 50,</span><br><span class="line"></span><br><span class="line">              height: 50,</span><br><span class="line"></span><br><span class="line">              child: child,</span><br><span class="line"></span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600937b6eb75418d8d88dfaf888aa15a~tplv-k3u1fbpfcp-watermark.image" alt="306.png"></p>
<p>可以发现，当父组件约束子组件大小宽高是100时，我们通过 SizedBox 指定 Container 大小是为 50×50 是不能成功的， 而通过 AccurateSized 时成功了。</p>
<p>这里需要提醒一下读者，如果一个组件的的 sizedByParent 为 true，那它在布局子组件时也是能将 parentUsesSize 置为 true 的，sizedByParent 为 true 表示自己是布局边界，而将 parentUsesSize 置为 true 或 false 决定的是子组件是否是布局边界，两者并不矛盾，这个不要混淆了。顺便提一点 Flutter 自带的 OverflowBox 组件的实现中，它的 sizedByParent 为 true，在调用子组件layout 方法时，parentUsesSize 传的是 true，具体通过OverflowBox 的实现源码可以找到原因。</p>
<h3 id="AfterLayout"><a href="#AfterLayout" class="headerlink" title="AfterLayout"></a>AfterLayout</h3><p>AfterLayout 可以在布局结束后拿到子组件的代理渲染对象 （RenderAfterLayout）， RenderAfterLayout 对象会代理子组件渲染对象 ，因此，通过RenderAfterLayout 对象也就可以获取到子组件渲染对象上的属性，比如件大小、位置等。</p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AfterLayout extends SingleChildRenderObjectWidget &#123;</span><br><span class="line"></span><br><span class="line">  AfterLayout(&#123;</span><br><span class="line"></span><br><span class="line">    Key? key,</span><br><span class="line"></span><br><span class="line">    required this.callback,</span><br><span class="line"></span><br><span class="line">    Widget? child,</span><br><span class="line"></span><br><span class="line">  &#125;) : super(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    return RenderAfterLayout(callback);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void updateRenderObject(</span><br><span class="line"></span><br><span class="line">      BuildContext context, RenderAfterLayout renderObject) &#123;</span><br><span class="line"></span><br><span class="line">    renderObject..callback = callback;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///组件树布局结束后会被触发，注意，并不是当前组件布局结束后触发</span><br><span class="line"></span><br><span class="line">  final ValueSetter&lt;RenderAfterLayout&gt; callback;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RenderAfterLayout extends RenderProxyBox &#123;</span><br><span class="line"></span><br><span class="line">  RenderAfterLayout(this.callback);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ValueSetter&lt;RenderAfterLayout&gt; callback;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">    super.performLayout();</span><br><span class="line"></span><br><span class="line">    // 不能直接回调callback，原因是当前组件布局完成后可能还有其他组件未完成布局</span><br><span class="line"></span><br><span class="line">    // 如果callback中又触发了UI更新（比如调用了 setState）则会报错。因此，我们</span><br><span class="line"></span><br><span class="line">    // 在 frame 结束的时候再去触发回调。</span><br><span class="line"></span><br><span class="line">    SchedulerBinding.instance</span><br><span class="line"></span><br><span class="line">        .addPostFrameCallback((timeStamp) =&gt; callback(this));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /// 组件在屏幕坐标中的起始点坐标（偏移）</span><br><span class="line"></span><br><span class="line">  Offset get offset =&gt; localToGlobal(Offset.zero);</span><br><span class="line"></span><br><span class="line">  /// 组件在屏幕上占有的矩形空间区域</span><br><span class="line"></span><br><span class="line">  Rect get rect =&gt; offset &amp; size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码有三点需要注意：</p>
<ol>
<li>callback 调用时机不是在子组件完成布局后就立即调用，原因是子组件布局完成后可能还有其他组件未完成布局，如果此时调用callback，一旦 callback 中存在触发更新的代码（比如调用了 setState）则会报错。因此我们在 frame 结束的时候再去触发回调。</li>
<li>RenderAfterLayout 的 performLayout方法中直接调用了父类 RenderProxyBox 的 performLayout方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">  if (child != null) &#123;</span><br><span class="line"></span><br><span class="line">    child!.layout(constraints, parentUsesSize: true);</span><br><span class="line"></span><br><span class="line">    size = child!.size;</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    size = computeSizeForNoChild(constraints);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到是直接将父组件传给自身的约束传递给子组件，并将子组件的大小设置为自身大小。也就是说 RenderAfterLayout 的大小和其子组件大小是相同的</p>
<p>我们定义了 offset 和 rect 两个属性，它们是组件相对于屏幕的的位置偏移和占用的矩形空间范围。但是实战中，我们经常需要获取的是子组件相对于某个父级组件的坐标和矩形空间范围，这时候我们可以调用 RenderObject 的localToGlobal 方法，比如下面的的代码展示了Stack中某个子组件获取相对于Stack 的矩形空间范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget build(context)&#123;</span><br><span class="line"></span><br><span class="line">  return Stack(</span><br><span class="line"></span><br><span class="line">    alignment: AlignmentDirectional.topCenter,</span><br><span class="line"></span><br><span class="line">    children: [</span><br><span class="line"></span><br><span class="line">      AfterLayout(</span><br><span class="line"></span><br><span class="line">        callback: (renderAfterLayout)&#123;</span><br><span class="line"></span><br><span class="line">         //我们需要获取的是AfterLayout子组件相对于Stack的Rect</span><br><span class="line"></span><br><span class="line">         _rect = renderAfterLayout.localToGlobal(</span><br><span class="line"></span><br><span class="line">            Offset.zero,</span><br><span class="line"></span><br><span class="line">            //找到 Stack 对应的 RenderObject 对象</span><br><span class="line"></span><br><span class="line">            ancestor: context.findRenderObject(),</span><br><span class="line"></span><br><span class="line">          ) &amp; renderAfterLayout.size;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        child: Text(&#x27;Flutter@wendux&#x27;),</span><br><span class="line"></span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>Constraints（约束）主要描述了最小和最大宽高的限制，理解组件在布局过程中如何根据约束确定自身或子节点的大小对我们理解组件的布局行为有很大帮助，现在我们就通过一个实现 200*200 的红色 Container 的例子来说明。为了排除干扰，我们让根节点（RenderView）作为 Container 的父组件，我们的代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Container(width: 200, height: 200, color: Colors.red)</span><br></pre></td></tr></table></figure>

<p>但实际运行之后，你会发现整个屏幕都变成了红色！为什么呢？我们看看 RenderView 的布局实现：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line"></span><br><span class="line">void performLayout() &#123;</span><br><span class="line"></span><br><span class="line">  //configuration.size 为当前设备屏幕</span><br><span class="line"></span><br><span class="line">  _size = configuration.size; </span><br><span class="line"></span><br><span class="line">  if (child != null)</span><br><span class="line"></span><br><span class="line">    child!.layout(BoxConstraints.tight(_size)); //强制子组件和屏幕一样大</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要介绍一下两种常用的约束：</p>
<ol>
<li>宽松约束：不限制最小宽高（为0），只限制最大宽高，可以通过 BoxConstraints.loose(Size size) 来快速创建。</li>
<li>严格约束：限制为固定大小；即最小宽度等于最大宽度，最小高度等于最大高度，可以通过 BoxConstraints.tight(Size size) 来快速创建。</li>
</ol>
<p>可以发现，RenderView 中给子组件传递的是一个严格约束，即强制子组件大小等于屏幕大小，所以 Container 便撑满了屏幕。那我们怎么才能让指定的大小生效呢？标准答案就是<strong>引入一个中间组件，让这个中间组件遵守父组件的约束，然后对子组件传递新的约束</strong>。对于这个例子来讲，最简单的方式是用一个 Align 组件来包裹 Container：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@override</span><br><span class="line"></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">  var container = Container(width: 200, height: 200, color: Colors.red);</span><br><span class="line"></span><br><span class="line">  return Align(</span><br><span class="line"></span><br><span class="line">    child: container,</span><br><span class="line"></span><br><span class="line">    alignment: Alignment.topLeft,</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Align 会遵守 RenderView 的约束，让自身撑满屏幕，然后会给子组件传递一个宽松约束（最小宽高为0，最大宽高为200），这样 Container 就可以变成 200 * 200 了。</p>
<p>当然我们还可以使用其他组件来代替 Align，比如 UnconstrainedBox，但原理是相同的.</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> flutter 的布局流程</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce14d1a9b7b49c591722d6cefd68c93~tplv-k3u1fbpfcp-watermark.image" alt="saz&#39;s.png"></p>
<p><strong>在进行布局的时候，Flutter 会以 DFS（深度优先遍历）方式遍历渲染树，并 <strong>将限制以自上而下的方式</strong> 从父节点传递给子节点。子节点若要确定自己的大小，则 <strong>必须</strong> 遵循父节点传递的限制。子节点的响应方式是在父节点建立的约束内 <strong>将大小以自下而上的方式</strong> 传递给父节点。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BCrash%E6%94%B6%E9%9B%86%E4%B8%8E%E9%98%B2%E6%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BCrash%E6%94%B6%E9%9B%86%E4%B8%8E%E9%98%B2%E6%8A%A4/" class="post-title-link" itemprop="url">性能优化之Crash收集与防护</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-22 10:23:50" itemprop="dateCreated datePublished" datetime="2023-04-22T10:23:50+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>crash指标是项目稳定性的一个重要指标，本文主要针对crash崩溃原理以及防护做了总结和初步研究。</p>
</blockquote>
<h1 id="如何让crash变得可控"><a href="#如何让crash变得可控" class="headerlink" title="如何让crash变得可控"></a>如何让crash变得可控</h1><p>针对这个问题我们需要从以下几方面着手</p>
<ul>
<li>崩溃发生的原因有哪些</li>
<li>崩溃底层触发流程</li>
<li>崩溃的归类</li>
<li>怎么防护崩溃</li>
</ul>
<h2 id="一-崩溃发生的原因有哪些"><a href="#一-崩溃发生的原因有哪些" class="headerlink" title="一.崩溃发生的原因有哪些"></a>一.崩溃发生的原因有哪些</h2><h2 id="1-cpu无法执行的代码"><a href="#1-cpu无法执行的代码" class="headerlink" title="1.cpu无法执行的代码"></a>1.cpu无法执行的代码</h2><ul>
<li>执行了非法指令，通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号</li>
<li>无效指令或操作、访问无效地址及不具有权限的内存地址、除以0等 </li>
<li>僵尸对象，野指针导致的访问无效内存地址等等</li>
</ul>
<h2 id="2-被系统强杀"><a href="#2-被系统强杀" class="headerlink" title="2.被系统强杀"></a>2.被系统强杀</h2><p>  1.应用内存消耗过高 </p>
<p>  2.主线程长时间无法响应 </p>
<ul>
<li>操作系统采用看门狗来监控应用程序的响应能力。如果应用程序没有响应，看门狗会终止它，这会使用0x8badf00d终止原因中的代码创建崩溃报告</li>
</ul>
<p> 3.资源异常 </p>
<ul>
<li>1.线程频繁唤醒 ，Wakeups 是“资源异常”下的一个子类，指的是频繁唤醒线程，消耗cpu资源并增加 功耗，在超过阈值并处于 FATAL CONDITION 的条件下触发崩溃;如果300秒内的 总wakeup数超过45000(300 * 150)就会被判定为超出阈值;</li>
<li>2.进程中的线程过多的占用了cpu，限制为 50% ，时间不超过 180秒 ;</li>
<li>3.线程短时间过多的磁盘写入</li>
</ul>
<ol start="4">
<li>死锁</li>
<li>非法的应用签名<br> 6.后台执行超时</li>
</ol>
<p> </p>
<ul>
<li>1.App退至后台后若执行时间过⻓就会导致被系统被杀，比如 Backgroud Task 方式可以在后台 执行3min，若超过3min还未运行完成就会被系统强杀</li>
</ul>
<p>7.设备总内存吃紧</p>
<ul>
<li>因为Mac平台存在内存交换机制，而iOS平台没有，就导致整个设备内存吃紧的时候，系统就 会杀掉优先级不高且占用内存多大的应用</li>
</ul>
<p> </p>
<p>8.设备过热</p>
<ul>
<li>一般见于低端的设备</li>
</ul>
<h2 id="3-语言触发异常"><a href="#3-语言触发异常" class="headerlink" title="3.语言触发异常"></a>3.语言触发异常</h2><p>1.OC语言抛出异常 </p>
<ul>
<li>1.数组越界</li>
<li>2.未找到的方法或者 NSDictionary 添加 nil 对象等导致的非法参数异 常 NSInvalidArgumentException </li>
<li>3.KVC未找到相对应的 key 抛出 NSUnknownKeyException ）</li>
</ul>
<ol start="2">
<li>C++抛出异常</li>
</ol>
<ul>
<li>如图为c++环境下的一些异常类</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ce8112423b14a92b7025945a36f9467~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>语言异常抛出后最后都会调用到 abort 来终止应用，调用栈如下图所示</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/169908fe86b8438a8d499e57976f6005~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-开发者触发-（断言，-NSAssert-或者-asset-函数等-）"><a href="#4-开发者触发-（断言，-NSAssert-或者-asset-函数等-）" class="headerlink" title="4.开发者触发 （断言， NSAssert 或者 asset 函数等 ）"></a>4.开发者触发 （断言， NSAssert 或者 asset 函数等 ）</h2><h2 id="5-…（其他）"><a href="#5-…（其他）" class="headerlink" title="5 …（其他）"></a>5 …（其他）</h2><h2 id="二-崩溃如何发生"><a href="#二-崩溃如何发生" class="headerlink" title="二.崩溃如何发生"></a>二.崩溃如何发生</h2><p>大部分应用程序都可能崩溃，在Unix中崩溃和一个信号有关系，但是追究其根本原因，是来自于内核，内核发现进程无法继续执行时，生成这个信号作为最后的补救办法。</p>
<h3 id="系统是如何把异常转换成singnal呢"><a href="#系统是如何把异常转换成singnal呢" class="headerlink" title="系统是如何把异常转换成singnal呢"></a>系统是如何把异常转换成singnal呢</h3><p><strong>Mach-&gt;singnal-&gt;异常</strong></p>
<p>程序的崩溃都会转换为异常，被cpu通过中断向量表指定的异常类型捕获，进而触发异常处理程序处理， 比如cpu无效指令、无效的地址或者无权限的访问，这些都是<strong>硬件产生的异常</strong>;被系统强杀的崩溃最终 会调用到 kill 函数发送 SIGKILL 信号进而引发应用被强杀;语言及开发者触发崩溃最终会通过 abort 函数毅然会最终调用到 kill 函数发送 SIGABRT 信号引发应用被杀，这都是<strong>软件引发的异常</strong>。</p>
<p><strong>Mach层</strong></p>
<p>Mach在系统中处于最接近底层的模块，是XNU内核的内核，被BSD包裹。Mach内核作为系统一个底层的基础，仅与驱动操作系统所需的最低需要有关。 其他所有内容都由操作系统的更高层来实现，然后再利用Mach并以其认为合适的任何方式对其进行操作。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/545dcb36f3144e73bf8b60ca6f1e168c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6deaa5690e514bb5855d7ce12a5e8149~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>整个操作系统核心包括了 Mach 微内核、BSD层(大家熟悉的 POSIX 接口就在这一层)、I&#x2F;O Kit设备驱动框 架以及核心库，其中 Mach 微内核负责进程和线程抽象、虚拟内存管理、任务管理以及进程间通信和消息 传递机制，所以 Mach 微内核就是整个操作系统的核心。</p>
<p>如runloop mach port 的消息就是基于mach微内核的消息机制的体现 </p>
<p>Mach 异常是在已有的消息传递架构上实现的一种独有的异常处理方法，是一种轻量级的架构。</p>
<p><strong>信号处理流程图</strong></p>
<ul>
<li>异常封装、转换、发送。</li>
<li>异常消息接收处理。</li>
<li>异常消息转换为BSD信号。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/696143ddcb9d401c9767733bc559b228~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="三-崩溃的归类"><a href="#三-崩溃的归类" class="headerlink" title="三.崩溃的归类"></a>三.崩溃的归类</h2><p><strong>根据上图可以总结为以下几大类</strong></p>
<ul>
<li>1.mach exception</li>
<li>2.signal（BSD信号）</li>
<li>3.NSException</li>
<li>4.其他 如c++异常 和 主线程死锁</li>
</ul>
<p>最终不管是硬件异常还是语言异常及用户抛出异常都会产生信号，那信号与Mach异常有何关 系?首先来带大家了解下什么是 Mach 异常。</p>
<h3 id="1-mach-异常"><a href="#1-mach-异常" class="headerlink" title="1.mach 异常"></a>1.mach 异常</h3><ul>
<li><p>Mach 异常是指最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常</p>
</li>
<li><p>Mach异常由处理器陷阱引发，在异常发生后会被异常处理程序转换成Mach消息，接着依次投递到thread、task和host端口。如果没有一个端口处理这个异常并返回KERN_SUCCESS，那么应用将被终止。每个端口拥有一个异常端口数组，系统暴露了后缀为task_set_exception_ports的多个API让我们注册对应的异常处理到端口中。</p>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8df719508014be891bcd0c34fd15ca7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="Mach异常处理流程"><a href="#Mach异常处理流程" class="headerlink" title="Mach异常处理流程"></a>Mach异常处理流程</h3><p>针对mach 异常处理参考开源库有完整的crash处理流程。<br><a target="_blank" rel="noopener" href="https://github.com/kstenerud/KSCrash">https://github.com/kstenerud/KSCrash</a></p>
<h4 id="KSCrash处理流程"><a href="#KSCrash处理流程" class="headerlink" title="KSCrash处理流程"></a><strong>KSCrash处理流程</strong></h4><ul>
<li>备份当前异常端口</li>
<li>分配新的异常端口并设置给task作为新的接收异常的端口</li>
<li>创建两个线程用于监听异常端口</li>
<li>线程中监听并处理异常</li>
</ul>
<h5 id="1-备份当前异常端口"><a href="#1-备份当前异常端口" class="headerlink" title="1.备份当前异常端口"></a>1.备份当前异常端口</h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94f44faacb846e9a7a94db855990c52~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h5 id="2-分配新的异常端口并设置给task作为新的接收异常的端口"><a href="#2-分配新的异常端口并设置给task作为新的接收异常的端口" class="headerlink" title="2.分配新的异常端口并设置给task作为新的接收异常的端口"></a>2.分配新的异常端口并设置给task作为新的接收异常的端口</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53117766804443c9a6d752a9df0c5d9d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h5 id="3-创建两个线程用于监听异常端口，线程中监听并处理异常"><a href="#3-创建两个线程用于监听异常端口，线程中监听并处理异常" class="headerlink" title="3.创建两个线程用于监听异常端口，线程中监听并处理异常"></a>3.创建两个线程用于监听异常端口，线程中监听并处理异常</h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2820fb1b43b4403ea54ab34e031e5655~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f6a7441127941599ea52659388209d1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h5 id="4-所有Mach异常未处理，它将在host层被ux-exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。"><a href="#4-所有Mach异常未处理，它将在host层被ux-exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。" class="headerlink" title="4.所有Mach异常未处理，它将在host层被ux_exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。"></a>4.所有Mach异常未处理，它将在host层被ux_exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。</h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba911c392a36487687a5934ac1cf4d58~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="2-signal（UNIX信号）"><a href="#2-signal（UNIX信号）" class="headerlink" title="2.signal（UNIX信号）"></a>2.signal（UNIX信号）</h3><p>信号是什么?信号是一种异步处理的软中断，内核会发送给进程某些异步事件，这些异步事件可能 来自硬件，比如除0或者访问了非法地址;也可能来自其他进程或用户输入，比如 ctrl+c ，就会产 生 SIGINT 信号由内核发送至当前终端执行进程，若进程未处理该信号，就会导致进程退<br>出; ctrl+\ 就会产生 SIGQUIT 退出信号来终止进程执行，并且会产生崩溃日志报告，如下图所 示:</p>
<p>信号(signal)是一种POSIX标准通信方式。通常用于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix">Unix</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix-like">类 Unix</a>和其他<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix-like">符合</a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>的操作系统。信号是发送到<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Process_(computing)">进程</a>或同一进程内的特定<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_(computer_science)">线程</a>以通知其事件的<a target="_blank" rel="noopener" href="https://en.wiktionary.org/wiki/asynchronous">异步</a>通知。</p>
<p><strong>那最终信号如何处理呢?</strong> </p>
<p>上面我们讲到用户态进程若指定了信号处理函数(比如 SIGINT )则可以自己来处理，若未指定呢?比较有 意思的地方开始了，内核发现信号未存在异常处理函数，就会将其抛给崩溃报告守护进<br>程 ReportCrash </p>
<p>因此异常消息是通过 Mach 消息的形式发送出去的，那我们就可以截获这个消息</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/390f71e396714a46b11a83713d6d1a66~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-NSException-异常捕获（应用级别的异常）"><a href="#3-NSException-异常捕获（应用级别的异常）" class="headerlink" title="3.NSException 异常捕获（应用级别的异常）"></a>3.NSException 异常捕获（应用级别的异常）</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c57ffd4e3ca411f9acb4c97a4ecbccf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/182b6857cc8449b4a96263c4e0f43ec6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e635293da1f4aaea21c865bb5bee10e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-c-异常"><a href="#4-c-异常" class="headerlink" title="4.c++异常"></a>4.c++异常</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b64cd3d5f3ba4d3bb408469a3e4ef9fd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="5-主线程死锁"><a href="#5-主线程死锁" class="headerlink" title="5.主线程死锁"></a>5.主线程死锁</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/038582f01d7f4f7195825a854b43b8a5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4de7c1390d14fc5a4cb34a9a989f0df~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="四-怎么防护崩溃"><a href="#四-怎么防护崩溃" class="headerlink" title="四. 怎么防护崩溃?"></a>四. 怎么防护崩溃?</h2><ul>
<li>1.crash防护 增加程序的健壮性（代码规范，cr等等…）</li>
<li>2.crash拦截 尽可能多的拦截所有的crash类型</li>
<li>3.crash上报日志</li>
<li>4.crash 后续流程 优雅的crash 提升用户体验度</li>
</ul>
<h3 id="crash拦截"><a href="#crash拦截" class="headerlink" title="crash拦截"></a>crash拦截</h3><h4 id="主动防护"><a href="#主动防护" class="headerlink" title="主动防护"></a><strong>主动防护</strong></h4><ul>
<li>在将要执行的api前增加异常处理判断等（如通过扩展分类添加异常判断）</li>
<li>通过其他手段如中间类处理（如通过weakProxy 处理timer 强引用）</li>
<li>通过proxy类处理kvc 安全添加移除</li>
<li>……..</li>
</ul>
<h4 id="AOP拦截防护"><a href="#AOP拦截防护" class="headerlink" title="AOP拦截防护"></a><strong>AOP拦截防护</strong></h4><ul>
<li>通过拦截调用添加异常判断，之后再调用本身的Selector</li>
</ul>
<h3 id="AOP拦截调用"><a href="#AOP拦截调用" class="headerlink" title="AOP拦截调用"></a>AOP拦截调用</h3><p>1.Hook的类添加Category，在各个分类中通过Method Swizzling拦截容易造成崩溃的系统方法</p>
<p>2.将系统原有方法与添加的防护方法的selector（方法选择器）与IMP（函数实现指针）进行对调</p>
<p>3.然后在替换方法中添加防护操作，从而达到避免复崩溃的目的。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff798207f1a64c8cb8e3a887e4e863df~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="目前可以处理掉的crash类型"><a href="#目前可以处理掉的crash类型" class="headerlink" title="目前可以处理掉的crash类型"></a><strong>目前可以处理掉的crash类型</strong></h3><ul>
<li>1.unrecognized selector crash</li>
<li>2.KVO</li>
<li>3.NSNotification</li>
<li>4.NSTimer</li>
<li>5.Container crash（数组越界，插nil等）</li>
<li>6.NSString crash （字符串操作的crash）</li>
<li>7.Bad Access crash （野指针）</li>
</ul>
<h3 id="1-Unrecognized-Selector类型crash防护"><a href="#1-Unrecognized-Selector类型crash防护" class="headerlink" title="1.Unrecognized Selector类型crash防护"></a>1.Unrecognized Selector类型crash防护</h3><ul>
<li>原因: 通常是因为一个对象调用了一个不属于它方法的方法导致的是</li>
<li>方法的查找流程-&gt;runtime消息转发流程-&gt;最终未处理-&gt;程序报错crash</li>
<li>防护方案:在消息转发过程中拦截</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8e4f9a52a864b55ad00cbc0c2b91257~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>所以当函数找不到时，runtime提供了三种方式去补救：</p>
<p>1.调用resolveInstanceMethod给个机会让类添加这个实现这个函数。<br>2.调用forwardingTargetForSelector让别的对象去执行这个函数。</p>
<p>3.调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>resolveInstanceMethod需要在类的本身上动态添加它本身不存在的方法，这些方法对于该类本身来说冗余的。</li>
<li>forwardInvocation可以通过NSInvocation的形式将消息转发给多个对象，但是其开销较大，需要创建新的NSInvocation对象，并且forwardInvocation的函数经常被使用者调用，来做多层消息转发选择机制，不适合多次重写。</li>
<li>forwardingTargetForSelector可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c7d52b15e9d4529b6b7ae1f3d9b2586~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>动态创建一个桩类。  </p>
</li>
<li><p>动态为桩类添加对应的Selector，用一个通用的返回0的函数来实现该SEL的IMP。  </p>
</li>
<li><p>将消息直接转发到这个桩类对象上。</p>
</li>
</ul>
<p><strong>注意：如果对象的类本事如果重写了forwardInvocation方法的话，就不应该对forwardingTargetForSelector进行重写了，否则会影响到该类型的对象原本的消息转发流程。</strong></p>
<h3 id="2-KVO-crash"><a href="#2-KVO-crash" class="headerlink" title="2.KVO crash"></a>2.KVO crash</h3><p>  ** crash原因**</p>
<ul>
<li>1.添加KVO重复添加观察者或重复移除观察者。</li>
<li>2.KVO的被观察者dealloc时仍然注册着KVO导致的crash。</li>
<li>解决方法</li>
<li>通过中间delegate来进行管理，delegate通过建立一张map来维护KVO整个关系。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73016e20946f40eda4572c727c3b4db9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec1e0d2e55a04f66968e2fd811e931a0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>由于是分类会在多个地方使用，添加移除kvo 需要加线程锁。</li>
</ul>
<h3 id="3-KVC"><a href="#3-KVC" class="headerlink" title="3.KVC"></a>3.KVC</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b653935e35d3413989228fbb40db704c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>1.重写- (void)setValue:(id)value forUndefinedKey:(NSString *)key</li>
<li>2.重写- (nullable id)valueForUndefinedKey:(NSString *)key</li>
<li><ol start="3">
<li>key 为 nil 可以通过hook setValue:forKey:</li>
</ol>
</li>
<li>4.value 为nil重写setNilValueForKey:</li>
</ul>
<p> <em><strong>1和2可以解决key不是对象的属性和keyPath不正确情况</strong></em></p>
<h3 id="4-NSNotification-crash"><a href="#4-NSNotification-crash" class="headerlink" title="4.NSNotification crash"></a>4.NSNotification crash</h3><ul>
<li>原因:由于dealloc时候没有移除通知导致。</li>
<li>解决方法：保证dealloc移除通知。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd9fdaebef4469a8f46a470f3887696~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="5-NSTimer-crash"><a href="#5-NSTimer-crash" class="headerlink" title="5.NSTimer crash"></a>5.NSTimer crash</h3><p>1.NSTimer所产生的问题的主要原因是因为其没有再一个合适的时机invalidate。</p>
<p>2.同时还有NSTimer对target的强引用导致的内存泄漏问题。</p>
<p>解决方法一般通过中间对象 弱引用</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a88a3f4510fc49c286cd0821f38b244c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="6-Container类型-NSString-类型-crash"><a href="#6-Container类型-NSString-类型-crash" class="headerlink" title="6.Container类型,NSString 类型 crash"></a>6.Container类型,NSString 类型 crash</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li>Container 类型的crash 指的是容器类的crash，常见的有NSArray／NSMutableArray／NSDictionary／NSMutableDictionary／NSCache的crash。 一些常见的越界、插入nil等错误操作均会导致此类crash发生(容易排查 但是crash概率高)</li>
<li>Container crash 类型的防护方案也比较简单，针对于NSArray／NSMutableArray／NSDictionary／NSMutableDictionary／NSCache的一些常用的会导致崩溃的API进行method swizzling，然后在swizzle的新方法中加入一些条件限制和判断，(或者通过添加相关分类方法处理)从而让这些API变的安全。</li>
</ul>
<h3 id="7-野指针crash"><a href="#7-野指针crash" class="headerlink" title="7.野指针crash"></a>7.野指针crash</h3><p>如果一个指针先前指向一个对象，但这个对象随后被释放了，如果该指针没有做任何的修改，导致仍然指向着那块内存地址，则该指针已成为了野指针。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0dbdfa4b67c4ee8ba91f7b4b4b5b470~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9e61bb978494fa8a44cbee2a556a5c6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以利用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/nsobject/1571947-dealloc">dealloc</a>方法会自动实现父类的dealloc方法的特性，hook住NSObject和NSProxy两个oc的根类的dealloc方法，然后在调剂方法中将本来即将释放的对象的isa指针改为指向我们创建的一个新的僵尸类，然后外界对这个僵尸类发送任何消息(objc_msgSend)都会走方法调用流程，可以在此流程做处理。（需要考虑Zombie池子的释放）</p>
<p>参考 ：<a target="_blank" rel="noopener" href="http://sindrilin.com/2017/11/01/local_zombie.html">http://sindrilin.com/2017/11/01/local_zombie.html</a></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec20cbe686bc4c6d8c5d54c8b2bcc0db~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/22/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/22/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">编译和链接浅析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-22 10:23:50" itemprop="dateCreated datePublished" datetime="2023-04-22T10:23:50+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-解释语言和编译语言差别"><a href="#1-解释语言和编译语言差别" class="headerlink" title="1.解释语言和编译语言差别"></a>1.解释语言和编译语言差别</h1><h3 id="编译语言"><a href="#编译语言" class="headerlink" title="编译语言"></a>编译语言</h3><p>把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1ef403d063841e3a3ac3060483c2356~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="解释性语言"><a href="#解释性语言" class="headerlink" title="解释性语言"></a>解释性语言</h3><p>把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d055131b3d432cab78af4739363d79~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="2-程序是怎么运行起来的"><a href="#2-程序是怎么运行起来的" class="headerlink" title="2.程序是怎么运行起来的"></a>2.程序是怎么运行起来的</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux下，可以直接使用GCC来编译Hello World程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>上述过程分解如下</p>
<ul>
<li>预编译（预处理） </li>
<li>编译 </li>
<li>汇编 </li>
<li>链接</li>
</ul>
<p>GCC 编译过程分解<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50657750c10a4526836813b508355374~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="3-编译流程"><a href="#3-编译流程" class="headerlink" title="3.编译流程"></a>3.编译流程</h1><blockquote>
<p>3.1 预编译（预处理）编译 汇编 链接</p>
</blockquote>
<h2 id="1-预编译（预处理）"><a href="#1-预编译（预处理）" class="headerlink" title="1.预编译（预处理）"></a>1.预编译（预处理）</h2><p>预编译步骤将源代码文件<code>hello.c</code>以及相关头文件，如：<code>stdio.h</code>等预编译生成一个.i文件。对于C++程序，其源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，预编译生成.ii文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i  (-E 表示只进行预编译）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cpp hello.c &gt; hello.i </span><br></pre></td></tr></table></figure>

<p>过程如下</p>
<p><strong>预编译</strong>主要处理源代码中的以“#”开始的预编译指令，如：“#include”、“#define”等，其主要处理规则如下：</p>
<ul>
<li>将所有的“#define”删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，如：“#if”、“#ifdef”、“#else”、“#endif”。</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，因为被包含的文件可能还包含其他文件。</li>
<li>删除所有的注释“&#x2F;&#x2F;”和“&#x2F; **&#x2F;”。</li>
<li>添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的#pragma编译器指令，因为编译器须要试用他们。</li>
</ul>
<p>预编译生成的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p>
<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>编译</strong>就是把预处理生成的文件进行一系列词法分析、语法分析、语义分析、优化，生成相应的汇编代码文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一。</p>
<p>编译步骤相当于执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ gcc -S hello.i -o hello.s </span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. $ gcc -S hello.c -o hello.s </span><br></pre></td></tr></table></figure>


<p>现在版本的GCC把预编译和编译两个步骤合并成了一个步骤，使用一个叫cc1的程序来完成。该程序位于“<code>/usr/lib/gcc/x86_64-linux-gnu/4.8/</code>”，我们可以直接调用cc1来完成它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c</span><br></pre></td></tr></table></figure>

<p>事实上，对于不同的语言，预编译与编译的程序是不同的，如下所示：</p>
<ul>
<li>C：<strong>cc1</strong></li>
<li>C++：<strong>cc1plus</strong></li>
<li>Objective-C：<strong>cc1obj</strong></li>
<li>Fortran：<strong>f771</strong></li>
<li>Java：<strong>jc1</strong></li>
</ul>
<p>GCC是对这些后台程序的封装，它会根据不同的参数来调用预编译程序cc1、汇编器as、链接器ld。</p>
<h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3.汇编"></a>3.汇编</h2><p><strong>汇编</strong>就是将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。汇编过程相对于编译比较简单，其没有复杂的语法、语义，也无需做指令优化，只是根据汇编指令和机器指令的对照表进行翻译。</p>
<p>汇编步骤相当执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o </span><br></pre></td></tr></table></figure>

<p>或</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c -o hello.o </span><br></pre></td></tr></table></figure>

<p>GCC本质上是调用汇编器as来完成汇编步骤的，我们可以直接调用as来完成该步骤：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure>


<h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h2><p>最早的纸片机器 -&gt;汇编语言-&gt;高级语言</p>
<p>为了更好地理解计算机程序的编译和链接的过程，我们简单地回顾计算机程序开发的历<br>史<br>一定会非常有益。计算机的程序开发并非从一开始就有着这么复杂的白动化编译、链接过<br>程。原始的链接概念远在高级程序语言发明之前就已经存在了，在最开始的时候，程序员（当<br>时程序员的概念应该跟现在相差很大了，先把一个程序在纸上写好，当然当时没有很高级的<br>语言，用的都是机器语言，甚至连汇编诺言都没有。当程序须委被运行时，程序员人工将他<br>写的程序写入到存储设各上，最原始的存储设备之一就是纸带，即在纸岸上打相应的孔。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73083cd119fa4b02b3cebd8305d310b6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>现在问题来了，程序并不是一写好就永远不变化的，它可能会经常被修改。比如我们在<br>第1条指令之后、第5条指令之前插入了一条或多条指令，那么第5条指令及后面的指令的<br>位貴将会相应地往后移动，原先第一条指令的低4位的数字将需要相应地调整。在这个过程<br>中，程序员需要人工重新计算每个子程序或跳转的目标地址。当程序修改的时候，这此位置<br>都要重新计算，十分繁琐又耗时，并且很容易出错。这种重新计算各个目标的地址过程被叫<br>做重定位 (Relocation）。</p>
<p>如果我们有多条纸带的程序，这些程序之间可能会有类似的跨纸带之间的跳转，这种程<br>序经常修改导致跳转目标地址变化在程序拥有多个模块的时候更为严重。人工鄉定进行指令<br>的修正以确保所有的跳转目标地址都正确，在程序规模越水越人以后变得越来越复杂和繁琐。<br>没办法，这种黑暗的程序员生活是没有办法容忍的。先驱者发明了汇编语言，这相比机<br>器语言米说是个很大的进步。汇编语言使用接近人类的各种符号和标记来帮助记忆，比如指<br>令采用两个或三个字母的缩写，记佳“imp”比记住 0001xxxX 是跳转(iump）指令容易得<br>名了：汇编语言还可以使用符号来标记位置，比如一个符号“divide”表示一个除法子程序<br>的起始地址，比记住从某个位置开始的第几条指令是除法子程序方便得多。最重要的足，这<br>种符号的方法使得人们从具体的指令地址中逐步解放出来。比如前面纸带程序中，我们把刚<br>开始第5条指令开始的子程序命名为“foo”，那么第一条指令的汇编就是：<br>jmp foo<br>当然人们可以使用这种符号命名子程序或跳转目标以后，不管这个“foo”之前插入或<br>滅少了多少条指令导致 “f00”目标地址发生了什么变化，汇编器在每次汇编程序的时候会<br>重新计算“foo”这个符号的地址，然后把所有引用到“foo”的指令修正到这个正确的地址。<br>整个过程不需要人工参与，对于一个有成百上千个类似的符号的程序，程序员终于摆脱了这<br>种低级的繁琐的调整地址的工作，用一句政治口号来说叫做“极大地解放了生产力”。符号<br>(Svmbol）这个概念随着汇编话言的普及迅凍被伸用，它用来表示一个地址．这个协址可<br>能是一段子程序（后来发展成函数）的起始地址，<br>也可以是一个变量的起始地址。</p>
<p>有了汇编语言以后，生产力大大提高了，随之而来的是软件的规模也开始日渐庞大。这<br>时程序的代码量也已经开始快速地膨账，导致人们要开始考愁将不同功能的代码以一定的方<br>式组织起米，使得更加容易阅读和理解，以便于日后修改和重复使用。自然而然，人们开始<br>将代码按照功能或性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其<br>他结构米组织。这个在现代的软件源代码组织中很常见，比如在 C语言中，最小的单位是</p>
<p>变量和函数，若干个变量和两数组成一个模块，存放在一个“c”的源代码文件里，然后这<br>些源代码文件按照目录结构来组织。在比较高级的语言中，如Java 中，每个类是一个基本<br>的模块，若干个类模块组成一个包（Package），若干个包组合成一个程序。<br>在现代软件开发过程中，软件的规模往往都很大，动辄数百万行代码，如果都放在-<br>模块肯定无法想象。所以现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖<br>又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读<br>理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等，</p>
<p>在现代软件开发过程中，软件的规模往往都很大，动辄数百万行代码，如果都放在一个<br>模块肯定无法想象。所以现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖<br>又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、<br>理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。<br>在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是<br>须解决的问题。模块之问如何组合的问题可以归结为模块之间如何通信的问题，最常见的属<br>于静态语言的 C&#x2F;C++模块之间通信有两种方式，<br>一种是模块间的函数调用，另外一种是模块<br>间的变量访问。两数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以<br>这两种方式都可以归结为一种方式，那就是模块间符号的引用。模块问依靠符号来通信类似<br>于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者-<br>拼接刚好完美组合（见图2-7）。这个模块的拼接过程就是本书的一个主题：链接 (Linking )。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4926d4c703343608e08fbe317bae368~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>链接</strong>主要是将前面步骤生成多个目标文件进行重定位等复杂的操作，从而生成可执行文件。链接可分为静态链接和动态链接。</p>
<h1 id="3-2编译器做了什么"><a href="#3-2编译器做了什么" class="headerlink" title="3.2编译器做了什么"></a>3.2编译器做了什么</h1><p>背景 为什么出现了编译器</p>
<p>词法分析，语法分析，语义分析，中间语言生成，目标代码生成与优化</p>
<p>下面我们以一行简单的C语言代码为例，简单描述从<strong>源代码（Source Code）</strong> 到<strong>最终目标代码</strong>的过程。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)\</span><br></pre></td></tr></table></figure>



<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1.词法分析"></a>1.词法分析</h3><p>首先源代码被输入到<strong>扫描器（Scanner）</strong> ，扫描器的任务很简单，只是简单地进行词法分析，运用一种类似于<strong>有限状态机（Finite State Machine）</strong> 的算法将源代码的字符序列分割成一系列的<strong>记号（Token）</strong> 。</p>
<p>以上述代码为例，总共包含了28个非空字符，经过扫描后，产生了16个记号。</p>
<table>
<thead>
<tr>
<th>记号</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>标识符</td>
</tr>
<tr>
<td>[</td>
<td>左方括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>[</td>
<td>右方括号</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>赋值</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>4</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
<tr>
<td>*</td>
<td>乘号</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>2</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>6</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
</tbody></table>
<p>词法分析产生的记号一般可以分为一下几类：<strong>关键字</strong>、<strong>字面量</strong>（包含数字、字符串等）和<strong>特殊符号</strong>（如加号、等号）。</p>
<p>在识别记号的同时，扫描器也完成了其他工作。如：将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p>
<p>有一个名为lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。正因为有这样一个程序存在，编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则即可。</p>
<p>对于一些预处理的语言，c语言，他的宏替换和文件包含等工作一般不归编译器的范围，交给了一个独立的预处理器。</p>
<h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h3><p><strong>语法分析器（Grammar Parser）</strong> 将对由扫描器产生的记号进行语法分析。从而产生<strong>语法树（Syntax Tree）</strong> 。整个分析过程采用了<strong>上下文无关语法（Context-freeGrammar）</strong> 的分析手段。简单地讲，由语法分析器生成的语法树是以<strong>表达式（Expression）</strong> 为节点的树。</p>
<p>以上述代码为例，其中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句，下图所示为该语句经过语法分析器后生成的语法树。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d67137f8fb41e78ca2509a5069952e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。如：乘法表达式的优先级比加法高，圆括号表达式的优先级比乘法高，等等。另外，有些符号具有多重含义，如“*”在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，因此语法分析阶段必须对这些内容进行区分。如果出现了表达式不合法，如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。</p>
<p>有一个名为yacc（Yet Another Compiler Compiler）的工具可以实现语法分析。其根据用户给定的语法规则对输入的记号序列进行解析，从而构建出语法树。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器编写一个语法分析器。因此，其也称为“编译器编译器（Compiler Compiler）”</p>
<h3 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3.语义分析"></a>3.语义分析</h3><p>语法分析仅仅完成了对表达式的语法层面的分析，但它并不了解这个语句的真正含义，如：C语言里两个指针做乘法运算是没有意义的，但这个语句在语法上是合法的。编译器所能分析的语义是<strong>静态语义（Static Semantic）</strong> ，所谓静态语义是指在编译期间可以确定的语义，与之对应的<strong>动态语义（Dynamic Semantic）</strong> 就是只有在运行期才能确定的语义。</p>
<p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型的转换过程，语义分析过程中需要完成该步骤。比如讲一个浮点赋值给一个指针时，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般是指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。</p>
<p>经过语义分析阶段之后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。下图所示为标记语义后的语法树。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f3307b4861b4c68a8ad133e2a358b66~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-中间语言生成"><a href="#4-中间语言生成" class="headerlink" title="4.中间语言生成"></a>4.中间语言生成</h3><p>现代编译器有着很多层次的优化，<strong>源码优化器（Source Code Optimizer）</strong> 则是在源代码级别进行优化。上述例子中，（2 + 6）这个表达式可以被优化掉。因为它的值在编译期就可以被确定。下图所示为优化后的语法树。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf6515b9fa32489fa8789d25518abbaf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>事实上，直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong> ，它是语法树的顺序表示，其实它已经非常接近目标代码了。但它一般与目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器的名字等。</p>
<p>中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：<strong>三地址码（Three-address Code）</strong> 、<strong>P-代码（P-Code）</strong> 。以三地址码为例，最基本的三地址码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br><span class="line"># 表示将变量y和z进行op操作后，赋值给x。</span><br></pre></td></tr></table></figure>

<p>因此，可以将上述例子的代码翻译成三地址码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = 2 + 6</span><br><span class="line">t2 = index + 4</span><br><span class="line">t3 = t2 * t1</span><br><span class="line">array[index] = t3</span><br></pre></td></tr></table></figure>

<p>为了使所有的操作符合三地址码形式，这里使用了几个临时变量：t1、t2和t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1 &#x3D; 6。因此，进一步优化后可以得到如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t2 = index + 4</span><br><span class="line">t2 = t2 * 8</span><br><span class="line">array[index] = t2</span><br></pre></td></tr></table></figure>

<p>中间代码将编译器分为<strong>前端（Front End）</strong> 和<strong>后端（Back End）</strong> 。编译器前端负责产生机器无关的中间代码，编译器后端负责将中间代码转换成目标机器代码。这样，对于一些可跨平台的编译器，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。</p>
<p>比如clange就是一个前端工具，而LLVM则负责后端处理。GCC则是一个套装，包揽了前后端的所有任务。</p>
<h3 id="5-目标代码生成与优化"><a href="#5-目标代码生成与优化" class="headerlink" title="5.目标代码生成与优化"></a>5.目标代码生成与优化</h3><ol>
<li>目标代码生成</li>
</ol>
<p>目标代码生成主要由<strong>代码生成器（Code Generator）</strong> 完成。代码生成器将中间代码转换成目标机器代码，该过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。</p>
<p>上述例子的中间代码，经过代码生成器的处理之后可能会生成如下所示的代码序列（以x86汇编为例，假设index的类型为int型，array的类型为int型数组）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl index, %ecx            ; value of index to ecx</span><br><span class="line">addl $4, %ecx               ; ecx = ecx + 4</span><br><span class="line">mull $8, %ecx               ; ecx = ecx * 8</span><br><span class="line">movl index, %eax            ; value of index to eax</span><br><span class="line">movl %ecx, array(,%eax,4)    ; array[index] = ecx</span><br></pre></td></tr></table></figure>

<p>2.目标代码优化</p>
<p>目标代码生成后，由<strong>目标代码优化器（Target Code Optimizer）</strong> 来进行优化。比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</p>
<p>上述例子中，乘法由一条相对复杂的<strong>基址比例变址寻址（Base Index Scale Addressing）</strong> 的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。如下所示为优化后的目标代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(,%edx,8), %eax</span><br><span class="line">movl %eax, array(,%edx,4)</span><br></pre></td></tr></table></figure>

<p>经过扫描、语法分析、语义分析、源代码优化、目标代码生成、目标代码优化等一系列步骤之后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题：</p>
<blockquote>
<p>index和array的地址还没有确定</p>
</blockquote>
<p>如果我们把目标代码使用汇编器编译成真正能够在机器上运行的指令，那么index和array的地址来自哪里？</p>
<p>如果index和array定义在跟上面的源代码同一个编译单元里，那么编译器可以为index和array分配空间，确定地址；但如果是定义在其他的程序模块呢？</p>
<p>事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源文件编译成一个未链接的目标文件，然后由编译器最终将这些目标文件链接起来形成可执行文件。（<strong>引出链接器</strong>）</p>
<h1 id="3-3-编译器前端-后端"><a href="#3-3-编译器前端-后端" class="headerlink" title="3.3 编译器前端 后端"></a>3.3 编译器前端 后端</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><ul>
<li>传统编译器的设计</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/501a04b3cb734d5eb91d66649e0816b2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>编译器前端(Frontend)<br>编译器前端的任务是解析源代码。它会进行：词法分析、语法分析、语义分析，检查源代码是否存在错误，然后构建抽象语法树，LLVM的前端会生成中间代码IR。</p>
</li>
<li><p>优化器(Optimizer)<br> 优化器负责进行各种优化。改善运行时间，例如消除冗余计算等。</p>
</li>
<li><p>后端(Backend)<br> 也可以叫代码生成器(CodeGenerator)，将代码映射到目标指令集。生成机器语言，并且进行机器相关的代码优化。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d5b83165eb5457182adc43e5fb9e188~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<p>随着高级语言越来越多，终端类型种类的增加，所使用的的CPU架构等也不尽相同。<br>所以为了适配多种环境，不得不设计不同的编译器，而这些编译器前端和后端往往是捆绑在一起的。</p>
<p>LLVM的设计之初，即将编译器前端(Frontend)和后端(Backend)进行了分离。\</p>
<p>将前端和后端针对不同的架构，按照独立的项目进行研发，而它们均采用通用的代码形式IR。\</p>
<p>当编译器决定支持多种语言或多种硬件架构时，LLVM最重要的地方就体现出来了，使用通用的代码表示形式(IR)，它是用来在编译器中表示代码的形式。<br>所以LLVM可以为任何编程语言独立编写前端，并且可以为任意硬件架构独立编写后端。\</p>
<p>ios 编译架构</p>
<p>Objective C&#x2F;C&#x2F;C++使用的编译器前端是Clang，Swift是Swift，后端都是LLVM。\</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da3dc4b2aed546ac902a729087274252~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="4-链接器"><a href="#4-链接器" class="headerlink" title="4.链接器"></a>4.链接器</h1><p>连接器 介绍 背景</p>
<h2 id="4-1-静态链接"><a href="#4-1-静态链接" class="headerlink" title="4.1 静态链接"></a>4.1 静态链接</h2><p>当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件呢？过程是怎么样的，这就是链接的核心内容：静态链接</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b84afad36d42488113a9ec5de7c8b3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>如模块 a和模块 通过gcc编译器将a.c和b.c编译成目标文件a.o和b.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c b.c</span><br></pre></td></tr></table></figure>

<p>经过编译，从代码中可以看b.c到定义了2个全局符号，变量shared 和 函数swap ,a.c 定义了全局符号main，模块a.c 引用了b.的 shared 和 swap，下面把a.c和b.c 链接到一起，最终为一个可执行文件</p>
<h3 id="1-空间与地址分配"><a href="#1-空间与地址分配" class="headerlink" title="1.空间与地址分配"></a>1.空间与地址分配</h3><p>可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。</p>
<p>按序叠加</p>
<p>一个最简单的方案就是将输入的文件按序叠加，将目标文件依次合并</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dff1e44703c849198a2fd222e9a65a5d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p>
<p>相似段合并<br>一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的  <strong><code>.text</code>节</strong>合并到输出文件的 <strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50d3f5bdc4f042408deb55055bcf5e47~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p>
<ol>
<li>在输出的可执行文件中的空间</li>
<li>在装载后的虚拟地址中的空间</li>
</ol>
<p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p>
<p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong>  的方法。即整个链接过程分为两步：</p>
<ul>
<li><strong>第一步 地址与空间分配</strong><br>扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</li>
<li><strong>第二步 符号解析与重定位</strong><br>使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fc10b0c22f849e997b5346d3b720dd7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了<a target="_blank" rel="noopener" href="http://chuquan.me/2018/05/21/elf-introduce/">ELF文件结构</a>一文中没有介绍的 <strong>程序头表（Program Header Table）</strong>  结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ <code>text</code>段）、数据段（ <code>data</code>段 ）。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa2606ed86144aa901fb634fa21f4d1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以发现，链接前目标文件中所有节的 <strong>VMA（Virtual Memory Address）</strong>  都是0，因为虚拟空间还没有分配。链接后，可执行文件<code>ab</code>中各个节被分配到了相应的虚拟地址，如<code>.text</code>节被分配到了地址<code>0x0000000000400450</code>。</p>
<p>那么，为什么链接器要将可执行文件<code>ab</code>的<code>.text</code>节分配到<code>0x0000000000400450</code>？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux x86-64系统中，代码段总是从<code>0x0000000000400000</code>开始的，另外<code>.text</code>节之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code>等占用了一定的空间，所以就被分配到了<code>0x0000000000400450</code>。</p>
<h3 id="符号地址确定"><a href="#符号地址确定" class="headerlink" title="符号地址确定"></a>符号地址确定</h3><p>符号解析</p>
<p>在<strong>两步链接</strong>中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。</p>
<p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p>
<p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p>
<p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p>
<p><strong>COMMON块（### 多重定义的全局符号解析）</strong></p>
<p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？</p>
<p>Linux编译系统采用如下的方法解决多重定义的全局符号解析：</p>
<p><strong>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</strong></p>
<p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li><strong>规则1：不允许有多个同名的强符号。</strong></li>
<li><strong>规则2：如果有一个强符号和多个弱符号同名，则选择强符号。</strong></li>
<li><strong>规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。</strong></li>
</ul>
<p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p>
<ul>
<li><strong>情况1：两个或两个以上的强符号类型不一致。</strong></li>
<li><strong>情况2：有一个强符号，其他都是弱符号，出现类型不一致。</strong></li>
<li><strong>情况3：两个或两个以上弱符号类型不一致。</strong></li>
</ul>
<p>其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 <strong>COMMON块（Common Block<br>）</strong>  的机制来处理。其过程如下：</p>
<p><strong>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。</strong></p>
<p>重定位表<br>事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p>
<p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong>  专门用来保存这些与重定位相关的信息。</p>
<p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p>
<p>我们可以使用objdump工具来查看目标文件中的重定位表：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b53dc46d914c72981178fe0bdd6b64~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>我们可以看到每个要被重定位的地方是一个 <strong>重定位入口（Relocation Entry）</strong> 。利用数据结构成员包含的信息，即可完成重定位。</p>
<p>** 指令修正方式</p>
<h1 id="4-2-动态链接"><a href="#4-2-动态链接" class="headerlink" title="4.2 动态链接"></a>4.2 动态链接</h1><p>为什么要动态链接？</p>
<p>静态链接使得不同的程序开发者和部门能够相对独立地开发和测试自己的程序模块，从<br>某种意义上来讲大大促进了程序开发的效率，原先限制程序的规模也随之扩大。但是慢慢地<br>静态链接的诸多缺点也逐步暴露出来，比如浪费内存和磁盘空间、模块更新困难等问题，使<br>得人们不得不号找一种更好的方式来组织程序的模块</p>
<p><strong>内存和磁盘空间</strong></p>
<p>静态链接这种方法的确很简单，原理上很容易理解，实践上很难实現，在操作系统和硬<br>件不发达的早期，绝大部分系统采用这种方案。随着计算机软件的发展，这种方法的缺点很<br>快就暴露出来了，那就是静态连接的方式对于计算机内存和磁盘的空间浪费非常严重。特别<br>是多进程操作系统情况下，静态链接极大地浪费了内存空间，想象一下每个程序内部除了都<br>保留着 printf（）函数、scanf（）函数、strlen（）等这样的公用库函数，还有数量相当可观的其他库<br>函数及它们所需要的辅助数据结构。在现在的 Linux 系统中，<br>一个普通程序会使用到的C<br>语言静态库至少在 1MB 以上，那么，如果我们的机器中运行着100 个这样的程序，就要浪<br>费近100 MB 的内存：如果磁盘中有2000 个这样的程序，就要浪费近 2 GB 的磁盘空间，<br>很多 Linux 的机器中，&#x2F;usr&#x2F;bin下就有数干个可执行文件。</p>
<p>比如图 了-1 所示的Programl 和 Program2 分别包含Programl.0 和Program2.0两个模块，</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22c04db183db46129047b39b0c7f7217~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>并且它们还共用 Lib.o 这两模块。在静态连接的情况下，因为 Programl 和 Program2 都用到<br>了 Lib.o这个模块，所以它们同时在链接输出的可执行文件 Program1 和 Program2 有两个副<br>本。当我们同时运行 Programl 和 Program2 时， Lib.。在磁盘中和内存中都有两份副本。当<br>系统中存在大最的类似于Lib.。 的被多个程序共享的目标文件时，其中很大一部分空间就被<br>浪费了。在静态链接中，C语言静态库是很典型的浪费空间的例子，还有其他数以千计的库<br>如果都需要静态链接，那么空间浪费无法想象</p>
<p><strong>程席开发和发布</strong><br>空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也<br>会带来很多麻烦。比如程序 Program1 所使用的 Lib.o是由一个第三方厂商提供的，当该厂<br>商更新了 Lib.o。的时候（比如修正了i.。里面包含的-<br>一个Bug），那么Programl 的厂商就需<br>要拿到最新版的 Lib.o，然后将其与 Program1.o链接后，将新的 Program1 整个发布给用户<br>这样做的缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户。<br>比如一个程序有20个模块，每个模块 1MB，那么每次更新任何一个模块，用户就得重新获<br>取这个 20 MB 的程序。如果程序都使用静态链接，那么通过网络来更新程序将会非常不便，<br>因为一旦程序任何位置的一个小改动，都会导致整个程序重新下载</p>
<p>动态链接<br>要解决空间浪费和更新困难这两个问题最简单的办法就是把程序的模块相互分割开来，<br>形成独立的文件，而不再将它们静态地链接在一起。简单地讲，就是不对那些组成程序的目<br>标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行<br>时再进行，这就是动态链接(Dynamic Linking）的基本思想。<br>还是以 Programl 和Program2 为例，假设我们保留 Programl.0、Program2.0 和 Lib.o<br>个目标文件。当我们要运行 Program1 这个程序时，系统首先加载 Program1.0，当系统发现<br>Programl.0 中用到了 Lib.o，即 Program1.0依赖于 Lib.o，那么系统接着加载 Lib.o，如果<br>Program1.0或 Lib.o还依赖于其他目标文件，系统会按照这种方法将它们全部加载至内存。<br>所有需要的目标文件加载完牛之后，如果依赖关系满足，即所有依赖的目标文件都存在于磁<br>盘，系统开始进行链接工作。这个链接王作的原理与静态链接非常相似，包括符号解析、地<br>址重定位等，我们在前面己经很详细地介绍过了。完成这些步骤之后，系统开始把控制权交<br>给 Programl.∞ 的程序入口处，程序开始运行。这时如果我们需要运行 Program2，那么系统<br>只需要加载 Program2.0，布不需要重新加载 Lib.0，因为内存中己经存在了一份 Lib.o 的副本<br>（见图7-2），系统要做的只是将 Program2.0和Lib.o链接起来。</p>
<p>优点</p>
<p>很明显，上面的这种做法解决了共享的目杯文件多个副本浪费磁盘和内存空间的问题，<br>可以看到，磁盘和内存中只存在一份 Lib.0，而不是两份。另外在内存中共享一个目标文件</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b73d7f5394f452b82bd5dae1f99b2f2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>模块的好处不仅仅是节省内存，它还可以减少物理页面的换入换出，也可以增加 CPU 缓存<br>的命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上。<br>上面的动态链接方案也可以使程序的升级变得更加容易，当我们要升级程序库或程序共<br>享的某个模块时，理论上只要简单地将旧的目标文件覆盖掉，而无须将所有的程序再重新链<br>接一遍。当程序下一次运行的时候，新版本的目标文件会被自动装载到内存并且链接起来，<br>程序就完成了升级的目标。<br>当一个程序产品的规模很大的时候，往往会分割成多个子系统及多个模块，每个模块都<br>由独立的小组开发，甚至会使用不同的编程语言。动态链接的方式使得开发过程中各个模块<br>更加独立，男合度更小，便于不同的开发者和开发组织之间独立进行开发和测试。</p>
<p>程序可扩展性和莱容性</p>
<p>动态链接还有一个特点就是程序在运行时可以动态地选择加载各种程序模块，这个优点<br>就是后来被人们用来制作程序的插件 (plug-in)。<br>比如某个公司开发完成了菜个产品，它按照一定的规则制定好程序的接口，其他公司或<br>开发者可以按照这种接口来编写符合要求的动态链接文件。该产品程序可以动态地载入各种<br>由第三方开发的模块，在程序运行时动态地链接，实现程序功能的扩展。<br>动态链接还可以加强程序的兼容性。一个程序在不同的平台运行时可以动态地链接到由</p>
<p>操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间增加了一个中间<br>层，从市消除了程序对不同平台之间依赖的差异性。比如操作系统 A 和操作系统 B对于<br>printfO的实现机制不同，如果我们的程序是静态链接的，那么程序需要分别链接成能够在A<br>运行和在 B运行的两个版本并且分开发布；但是如果是动态链接，只要操作系统 A 和操作<br>系统B都能提供一个动态链接库包含printf0，并且这个printfo使用相同的接口，那么程序<br>只需要有一个版本，就可以在两个操作系统上运行，动态地选择相应的printfo的实现版本。<br>当然这只是理论上的可能性，实际上还存在不少问题，我们会在后面继续探讨关于动态链接<br>模块之间兼容性的问题.<br>从上面的描述来看，动态链接是不是一种 “万能音药”，包治百病呢？很遗憾，动态链<br>接也有诸多的问题及令人烦恼和费解的地方。很常见的一个问题是，当程序所依赖的某个模<br>块更新后，由于新的模块与旧的模块之间接口不兼容，导致了原有的程序无法运行。这个问<br>题在早期的 Windows 版本中尤为亚重，因为它们缺少一种有效的共享库版本管理机制，使<br>得用户经常出现新程序安装完之后，其他某个程序无法正常工作的现象，这个问题也经常被<br>称为“DLL Hell”.</p>
<p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p>
<p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 <strong>动态共享对象（DSO，Dynamic Shared Objects）</strong> ，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为 <strong>动态链接库（Dynamic Linking Library）</strong> ，一般以<code>.dll</code>为后缀。</p>
<p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 <code>/lib</code>目录下，文件名为 <code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p>
<p>动态链接缺点和解决方法</p>
<p>程序与 iibc.so 之间真正的链接工作是由动态链接器完成的，而不是由我们前面看到过<br>的静态链接器 1d 完成的。也就是说，动态链接是把链接这个过程从本来的程序装载前被推<br>迟到了装载的时候。可能有人会问，这样的做法的确很灵活，但是程序每次被装载时都要进<br>行重新进行链接，是不是很慢？的确，动态链接会导致程序在性能的一些损失，但是对动态<br>链接的链接过程可 以进行优化，比如我们后面要介绍的延迟鄉定 (Lazy Binding） 等方法，<br>可以使得动态链接的性能损失尽可能地滅小。据估算，动态链接与静态链接相比，性能损失<br>大约在 5%以下。当然经过实践的证明，这点性能损失用来换取程序在空间上的节省和程序<br>构建和升级时的灵活性，是相当值得的。</p>
<p>举例</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97cd9f5226c74da79818fbedf7f06000~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2babb13fe0c46e8863d55e3e908055c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae2e58954504f18b262f28f6620e2b9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>Lib.c 被编译成 Lib.so共享对象文件，Programlc 被编译成 Programl.0之后，链接成为<br>可执行程序 Programl。图7-3 中有一个步骤与静态链接不一样，那就是 Programl.。被连接<br>成可执行文件的这一步。在静态链接中，这一步链接过程会把 Programl.o 和Lib.o 链接到<br>起，并且产生输出可执行文件 Programl。但是在这里，Lib.。 没有被链接进来，链接的输入<br>目标文件只有 Program1.。〔当然还有C语言运行库，我们这里暂时忽略）。但是从前面的命<br>令行中我们看到，Lib.so 也参与了链接过程。这是怎么回事呢？<br>关于模块：&lt;Module）×<br>在静态链接时，整个程序最终只有一个可执行文件，它是一个不可以分割的整体；但<br>是在动态链接下，一个程序被分成了若千个文件，有程序的主要部分，即可执行文件<br>1Program1〕和程序所依赖的共享对象（Lib.so)，很多时候我们也把这些部分称为模<br>块，即动态链接下的可执行文件和共享对象都可以看作是程序的一个模块。<br>让我们再回到动态链接的机制上米，当程序模块 Programl.c 被编译成为 Programl.0 时，<br>编详器还不不知道foobar0西数的地址，这个内容我们己在静态链接中解释过了。当链接器<br>将Program 1.0链接成可执行文件时，这时候链接器必须确定 Program1.0 中所引用的 foobar0<br>函数的性质。如果foobar0是一个定义与其他静态目标模块中的函数，那么链接器将会按照<br>静态链接的规则，将Program1.0 中的foobar 地址引用重定位：如果 foobar0是<br>一个定义在某<br>个动态共享对象中的函数，那么链接器就会将这个符号的引用标记为一个动态链接的符号，<br>不对它进行地址重定位，把这个过程留到装载时再进行。<br>那么这里就有个问题，链接器如何知道foobar 的引用是<br>一个静态符号还是一个动态符<br>号？这实际上就是我们要用到 Lib.so的原因。Lib.so中保存了完整的符号信息(因为运行时<br>进行动态链接还须使用符号信息），把Lib.so 也作为链接的输入文件之一，链接器在解析符<br>号时就可以知道：foobar 是一个定义在Lib.so 的动态符号。这样键接器就可以对 foobar 的引<br>用做特殊的处理，使它成为一个对动态符号的引用。</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><h3 id="地址空间分配"><a href="#地址空间分配" class="headerlink" title="地址空间分配"></a>地址空间分配</h3><p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p>
<p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p>
<ul>
<li><strong>静态共享库（Static Shared Library）</strong> （地址固定）</li>
<li><strong>动态共享库（Dynamic Shared Libary）</strong> （地址不固定）</li>
</ul>
<h3 id="装载重定位"><a href="#装载重定位" class="headerlink" title="装载重定位"></a>装载重定位</h3><p>我们前面在静态链接时提到过重定位，那时的重定位叫做链接时重定位 ( Link Time<br>Relocation），而现在这种情况经常被称为装载时重定位 (Load Time Relocation )，在<br>Windows 中，这种装载时重定位又被叫做基址重置 (Rebasing），我们在后面将会有专门章<br>节分析基址重置。<br>这种情况与我们碰到的问题很相似，都是程序模块在编详时目标地址不确定而需要在装<br>裁时将模块蛋定位，但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的<br>问题。可以想象，动态链接模块被装载映射至康拟空间后，指今部分是在名个讲程之间北享<br>的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，<br>因为指令被重定位后对于每个进程来讲是不同的。当然，动态连接库中的可修改数据部分对<br>手不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。</p>
<p>具体是怎么做到的</p>
<h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p>
</blockquote>
<p><strong>地址无关代码（PIC，Position-independent Code）</strong>  技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型：</p>
<ul>
<li><strong>类型1：模块内部的函数调用。</strong></li>
<li><strong>类型2：模块内部的数据访问，如模块中定义的全局变量、静态变量。</strong></li>
<li><strong>类型3：模块外部的函数调用。</strong></li>
<li><strong>类型4：模块外部的数据访问，如其他模块中定义的全局变量。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">extern int b;</span><br><span class="line">extern void ext();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    a = 1;      // 类型2：模块内部数据访问</span><br><span class="line">    b = 2;      // 类型4：模块外部数据访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    bar();      // 类型1：模块内部函数调用</span><br><span class="line">    ext();      // 类型4：模块外部函数调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类型1-模块内部函数调用"><a href="#类型1-模块内部函数调用" class="headerlink" title="类型1 模块内部函数调用"></a>类型1 模块内部函数调用</h5><p>由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。</p>
<p>类型2 模块内部数据访问</p>
<p>一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97dd173f71d47e7b397e2e34288e8f6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>“类型3 模块间数据访问”)类型3 模块间数据访问</p>
<p>模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF的实现方法是：在数据段中建立一个<strong>指向这些变量的指针数组</strong>，也称为<strong>全局偏移表（Global Offset Table，GOT）</strong> ，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。过程示意图如下所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/817fa9363ab9436d988434e0f917739c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h5 id="类型4-模块间函数调用"><a href="#类型4-模块间函数调用" class="headerlink" title="类型4 模块间函数调用"></a>类型4 模块间函数调用</h5><p>对于模块间函数调用，同样可以采用类型3的方法来解决。与上面的类型有所不同的是，GOT中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9a3ef4266d481b9d0f2311f9d28c6d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>延迟绑定（PLT）</strong><br>动态链接的确有很多优势，比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。<br>据统计 ELF 程序在静态链接下要比动态库稍微快点，大约为 1%~5%，当然这取决于程序<br>本身的特性及运行环境等。我们知道动态链接比静态链接慢的主要原因是动态链接下对于全<br>局和静态的数搭访问都要进行复东的 GOT 定位，然后问接寻址；对于模块间的调用也要先<br>定位 GOT，然后再进行间接跳转，如此一来，程序的运行速度必定会减慢。另外一个减慢<br>运行速度的原因是动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要<br>进行一次链接工作，正如我们上面提到的，动态链接器会寻找并装载所需要的共享对象，然<br>后进行符号查找地址重定位等工作，这些工作势必减慢程序的启动速度。这是影响动态链接<br>性能的两个主要问题，我们将在这一节介绍优化动态链接性能的-<br>一些方法。<br>延迟绑定实现<br>在动态链接下，程序模块之间包含了大最的西数引用（全局变量往往比较少，因为大量<br>的全局变量会导致模块之间糯合度变大），所以在程序开始执行前，动态链接会耗费不少时<br>问用于解决模块之间的函数引用的符号查找以及重定位，这也是我们上面提到的减慢动态链<br>接性能的第二个原因。不过可以想象，在-<br>-个程序运行过程中，可能很名两数在程序执行完<br>时都不会被用到，比如一些错误处理两数或者是<br>一些用户很少用到的功能模块等，如果一开<br>始就把所有函数都链接好实际上是<br>一种浪费。所以 ELF 采用了一种叫做延迟绑定(Lazy<br>Binding）的做法，基本的思想就是当西数第一次被用到时才进行鄉定（符号香找、重定位<br>等)，如果没有用到则不进行鄉定。所以程序开始执行时，模块间的函数调用都没有进行绑<br>定,而是需要用到时才由动态链接器水负责都定。这样的做法可以大大加快程序的启动速度，<br>特别有利于一此有大量函数引用和大量模块的程序。</p>
<p>动态链接的例子可以看苹果的动态连接器 </p>
<h1 id="5-苹果的动态链接器"><a href="#5-苹果的动态链接器" class="headerlink" title="5.苹果的动态链接器"></a>5.苹果的动态链接器</h1><p>dyld</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_8392210/3750204">https://blog.51cto.com/u_8392210/3750204</a></p>
<p><a target="_blank" rel="noopener" href="https://www.dllhook.com/post/238.html">https://www.dllhook.com/post/238.html</a></p>
<h1 id="6-应用"><a href="#6-应用" class="headerlink" title="6.应用"></a>6.应用</h1><p>启动优化<br>静态分析</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/22/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/22/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-22 10:23:50" itemprop="dateCreated datePublished" datetime="2023-04-22T10:23:50+08:00">2023-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/19/%E4%B8%80%E6%AC%A1AppDelegate%E8%A7%A3%E8%80%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kyan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Next">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Next">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/19/%E4%B8%80%E6%AC%A1AppDelegate%E8%A7%A3%E8%80%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">一次AppDelegate解耦学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-19 16:13:28" itemprop="dateCreated datePublished" datetime="2023-04-19T16:13:28+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-04-22 10:23:50" itemprop="dateModified" datetime="2023-04-22T10:23:50+08:00">2023-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-背景-amp-问题"><a href="#1-背景-amp-问题" class="headerlink" title="1.背景&amp;问题"></a>1.背景&amp;问题</h1><p>在传统的 iOS 应用开发中，往往会将所有的应用逻辑都写在一个文件中，即 App Delegate 文件中。这种方式虽然简单直观，但是当应用程序越来越复杂时，这个文件会变得非常庞大和难以维护，同时也容易引入不必要的耦合和依赖关系。</p>
<h2 id="存在问题："><a href="#存在问题：" class="headerlink" title="存在问题："></a>存在问题：</h2><h2 id="1-难以扩展"><a href="#1-难以扩展" class="headerlink" title="1.  难以扩展"></a>1.  难以扩展</h2><p>   当两个或多个模块之间高度耦合或具有强依赖关系时，很难添加新的模块或功能，因为修改一个模块可能会影响到其他模块，需要对整个系统进行重新设计、测试和部署。</p>
<h2 id="2-难以维护"><a href="#2-难以维护" class="headerlink" title="2.  难以维护"></a>2.  难以维护</h2><p>   高度耦合或具有强依赖关系的代码通常难以理解和维护。这意味着开发人员需要花费更多的时间来诊断和修复错误，从而降低了生产力。</p>
<h2 id="3-缺乏灵活性"><a href="#3-缺乏灵活性" class="headerlink" title="3.  缺乏灵活性"></a>3.  缺乏灵活性</h2><p>   当代码耦合和依赖严重时，系统变得僵化和静态，很难适应变化和不同的需求。这也使得在不破坏现有代码的情况下进行改进变得更加困难。</p>
<h2 id="4-代码可读性差"><a href="#4-代码可读性差" class="headerlink" title="4.  代码可读性差"></a>4.  代码可读性差</h2><p>   重度耦合和依赖会导致代码结构混乱，使得代码难以阅读和理解。这增加了调试问题的难度，并使得代码更加难以维护。</p>
<h2 id="5-可测试性差"><a href="#5-可测试性差" class="headerlink" title="5.  可测试性差"></a>5.  可测试性差</h2><p>   当代码耦合和依赖严重时，很难编写有效的单元测试，因为测试可能需要依赖于太多的其他代码。这意味着测试套件可能不够充分，从而增加了系统出错的风险。</p>
<p>因此，随着 iOS 应用程序规模的不断扩大和功能的不断增加，模块化设计变得越来越重要。模块化能够将一个大型的应用程序分解成独立的、可重用的模块，每个模块负责自己的职责和功能，并通过明确定义的接口与其他模块进行通信和协作。</p>
<h1 id="2-目标-amp-收益"><a href="#2-目标-amp-收益" class="headerlink" title="2.目标&amp;收益"></a>2.目标&amp;收益</h1><p>对于 App Delegate 来说，模块化可以帮助解决以下一些问题：</p>
<h2 id="1-代码膨胀和可维护性"><a href="#1-代码膨胀和可维护性" class="headerlink" title="1.  代码膨胀和可维护性"></a>1.  代码膨胀和可维护性</h2><p>   将 App Delegate 中的职责和事件处理分解为多个独立的模块，可以避免代码膨胀和提高代码的可维护性。</p>
<h2 id="2-耦合度降低"><a href="#2-耦合度降低" class="headerlink" title="2.  耦合度降低"></a>2.  耦合度降低</h2><p>   模块化可以降低模块之间的耦合度，从而使得各个模块更加独立和灵活。</p>
<h2 id="3-可测试性"><a href="#3-可测试性" class="headerlink" title="3.  可测试性"></a>3.  可测试性</h2><p>   模块化可以提高代码的可测试性，让开发人员更容易进行单元测试和集成测试。</p>
<h2 id="4-可扩展性"><a href="#4-可扩展性" class="headerlink" title="4.  可扩展性"></a>4.  可扩展性</h2><p>   模块化可以使得应用程序更容易进行功能扩展和组件替换，同时也方便开发人员进行代码重构和维护。</p>
<h2 id="5-模块化设计"><a href="#5-模块化设计" class="headerlink" title="5.  模块化设计"></a>5.  模块化设计</h2><p>   App壳工程通常采用模块化设计，可以方便地添加、删除或替换某些功能模块，实现定制化开发和灵活调整。</p>
<h2 id="6-未来实现平台化提供基础"><a href="#6-未来实现平台化提供基础" class="headerlink" title="6.  未来实现平台化提供基础"></a>6.  未来实现平台化提供基础</h2><h2 id="7-定制性强"><a href="#7-定制性强" class="headerlink" title="7.  定制性强"></a>7.  定制性强</h2><p>   开发者仍然可以根据自己的需求进行修改和定制，以满足特定的业务场景或用户需求。</p>
<p>因此，App Delegate 模块化可以帮助开发人员更好地管理和维护 iOS 应用程序，增强应用程序的可维护性、可测试性和可扩展性。</p>
<h1 id="3-常见解决方案"><a href="#3-常见解决方案" class="headerlink" title="3.常见解决方案"></a>3.常见解决方案</h1><p>在 iOS 应用程序开发中，解耦 App Delegate 的常用方案包括以下几个方面：</p>
<h2 id="1-模块化设计"><a href="#1-模块化设计" class="headerlink" title="1.  模块化设计"></a>1.  模块化设计</h2><p>   将 App Delegate 中的职责和事件处理分解为多个独立的模块，每个模块负责自己的职责和功能，并通过明确定义的接口与其他模块进行通信和协作。例如，可以将网络请求、推送消息等功能模块独立出来，使用面向协议编程的方式进行调用。</p>
<h2 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.  代理模式"></a>2.  代理模式</h2><p>   将 App Delegate 中的职责和事件处理委托给其他对象，实现事件响应和数据传递的解耦。例如，在应用程序启动时，可以创建一个独立的对象作为代理，来处理应用程序的生命周期事件。</p>
<h2 id="3-注册机制"><a href="#3-注册机制" class="headerlink" title="3.  注册机制"></a>3.  注册机制</h2><p>   通过注册机制实现事件响应和数据传递的解耦。例如，可以在应用程序初始化时，使用 NSNotificationCenter 注册通知，然后在各个模块中监听和处理通知，从而实现解耦。</p>
<h2 id="4-面向服务的架构"><a href="#4-面向服务的架构" class="headerlink" title="4.  面向服务的架构"></a>4.  面向服务的架构</h2><p>   采用面向服务的架构，将应用程序的各个功能模块封装成独立的服务，通过 Service API 进行通信和调用。这种方式可以实现应用程序的可扩展性和可维护性，并同时解耦 App Delegate。</p>
<p>需要注意的是，在解耦 App Delegate 的过程中，需要确保各个模块之间的接口约定清晰、可靠和封装良好，避免出现依赖关系混乱、重复代码等问题。同时，还需要注意防止循环引用和内存泄漏等问题。</p>
<h1 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ol>
<li>模块化设计可以降低耦合度，提高代码的复用性和可维护性，使得各个模块更加独立和灵活。</li>
<li>代理模式可以将 App Delegate 中的职责和事件处理委托给其他对象，实现事件响应和数据传递的解耦，减少代码的冗余和依赖关系。</li>
<li>注册机制可以通过通知的方式实现解耦，各个模块之间只需要订阅、发布自己感兴趣的事件即可，避免了直接使用 App Delegate 的问题。</li>
<li>面向服务的架构可以将应用程序的各个功能模块封装成独立的服务，通过 Service API 进行通信和调用，实现了应用程序的可扩展性和可维护性。</li>
</ol>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ol>
<li>模块化设计可能导致代码分散、难以维护和测试，需要对模块之间的依赖关系进行仔细管理和测试。</li>
<li>代理模式和注册机制可能会引入过多的事件通知和回调，降低代码的执行效率和性能。</li>
<li>注册机制需要非常小心地管理通知的订阅和取消，否则容易出现内存泄漏、循环引用等问题。</li>
<li>面向服务的架构可能会带来额外的开销和复杂性，需要进行更多的设计和实现工作。</li>
</ol>
<h1 id="5-当前项目存在的问题"><a href="#5-当前项目存在的问题" class="headerlink" title="5.当前项目存在的问题"></a>5.当前项目存在的问题</h1><p>appdelegate 模块流程过多，分工不明确</p>
<h1 id="6-如何解决"><a href="#6-如何解决" class="headerlink" title="6.如何解决"></a>6.如何解决</h1><h2 id="业界第三方实现思路"><a href="#业界第三方实现思路" class="headerlink" title="业界第三方实现思路"></a>业界第三方实现思路</h2><p>一.BeeHive (框架过于庞大，用到了自动注册，其他类似)</p>
<p>1.可以通过plist获取模块项，自动注册，或者创建注册</p>
<p>2.通过manager 分发app生命周期</p>
<p>地址:<a target="_blank" rel="noopener" href="https://github.com/lincode/FRDModuleManager">https://github.com/lincode/FRDModuleManager</a>（类似）</p>
<p>二.FRDModuleManager </p>
<p>1.注册通过plist获取模块项</p>
<p>2.通过manager 分发app生命周期</p>
<p>两者共同点:</p>
<p>可以使得留在 AppDelegate 的钩子方法被统一管理。实现了协议 UIApplicationDelegate 的 AppDelegate 是我知晓应用生命周期的重要途径。如果，某个模块需要在应用启动时初始化，那么我们就需要在 AppDelegate 的 application:didFinishLaunchingWithOptions: 调用一个该模块的初始化方法。模块多了，调用的初始化方法也会增多。最后，AppDelegate 会越来越臃肿。FRDModuleManager 提供了一个统一的接口，让各模块知晓应用的生命周期。在 AppDelegate 中留下钩子，在特定的生命周期调用模块的对应方法。这样将使得 AppDelegate 更简单。对于应用生命周期的使用也更清晰。</p>
<h1 id="7-优化思路"><a href="#7-优化思路" class="headerlink" title="7.优化思路:"></a>7.优化思路:</h1><p>1.Manager手动注册各个模块，方便控制</p>
<p>2.划分各个模块，通过分类扩展各个子模块的差异功能</p>
<p>3.通过协议接口实现方法调用</p>
<p>模块化 （单一职责原则）+ 分类 + 协议 </p>
<p>具体流程:</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6a8d426b74348aeae84e6d66316b02f~tplv-k3u1fbpfcp-watermark.image" alt="appdelegate.png"></p>
<p>1.通过模块管理类注册所有启动模块，需要设置先后顺序依赖，可使用数组添加，保证顺序设置。</p>
<p>2.档app 启动后 进入声明周期代理方法，此时 在各个生命周期方法内，统一使用moduleManager 调用， 如果有自定义流程如 首次启动的引导页等，都可以在modulemnager 增加</p>
<p>3.模块管理者收到了生命周期方法调用 ，此时，在内部方法内，依次调用提前注册的类，需要判断是否实现了协议方法，这样能灵活调用不同需求的模块。</p>
<p>4.模块管理者 可以提供两种方法设置模块调用 ，同步或者异步，各个模块根据需求按需实现协议即可。</p>
<p>5.模块本身通过分类分离自己的功能，如crash sdk模块 有多种 bugly 其他，那个模块A就可以创建 module+buglly，module+其他 划分子功能。</p>
<p>关键类图:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f4f3b532a34d9a99f550bb8566e52c~tplv-k3u1fbpfcp-watermark.image" alt="启动模块类图.png"></p>
<p>后续使用扩展</p>
<p>1.如果协议方法不满足增加协议方法，</p>
<p>2.Manager增加生命周期转发方法，内部实现协议接口调用</p>
<p>3.新增模块直接在注册方法追加模块即可</p>
<p>关键代码:</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c4cdb2913764dcbb28a79269eb6f11c~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/991f340a3a334901a7d73015d2ec9236~tplv-k3u1fbpfcp-watermark.image" alt="Pasted Graphic 1.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dd035a4b437468a8e517cdd7652df71~tplv-k3u1fbpfcp-watermark.image" alt="KModulestarturstepTypeisteoType.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff0c514cb2848c18f6f573ade73d473~tplv-k3u1fbpfcp-watermark.image" alt="#import •ModuleA.h®.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d52d63b11a4241809f042b3ef5276976~tplv-k3u1fbpfcp-watermark.image" alt="Ps KAppDelegate Module.png"></p>
<h1 id="8-最终结果"><a href="#8-最终结果" class="headerlink" title="8.最终结果"></a>8.最终结果</h1><p>1.各个模块职责单一，独立性强。</p>
<p>2.后续新增模块方便扩展，不影响appdelegate</p>
<p>3.如果要实现多app 直接根据模块管理类 增加或者减少即可</p>
<p>过程总结</p>
<p>1.业界方案很多，找到适合自己项目的方法</p>
<p>2.跟据实际情况选择合适时机去追求模块化代码</p>
<p>3.考虑当前的实际场景，来设计适合自己的模块化方式</p>
<p>参考：<br>1.<a target="_blank" rel="noopener" href="https://github.com/lincode/FRDModuleManager">https://github.com/lincode/FRDModuleManager</a><br>2.<a target="_blank" rel="noopener" href="https://github.com/alibaba/BeeHive">https://github.com/alibaba/BeeHive</a></p>
<p>最终结果</p>
<p>1.各个模块职责单一，独立性强。</p>
<p>2.后续新增模块方便扩展，不影响appdelegate</p>
<p>3.如果要实现多app 直接根据模块管理类 增加或者减少即可</p>
<p>过程总结</p>
<p>1.业界方案很多，找到适合自己项目的方法</p>
<p>2.跟据实际情况选择合适时机去追求模块化代码</p>
<p>3.考虑当前的实际场景，来设计适合自己的模块化方式</p>
<blockquote>
<p>移动应用的业务模块化架构设计，其真正的目标是提升开发质量和效率。单从实现角度来看并没有什么黑魔法或技术难点，更多的是结合团队实际开发协作方式和业务场景的具体考量——“适合自己的才是最好的”。某移动团队通过过往3年的实践，发现一味的追求性能，绝对的追求模块间编译隔离，过早的追求模块代码管理隔离等方式都偏离了模块化设计的真正目的，是得不偿失的。更合适的方式是在可控的改造代价下，一定程度考虑未来的优化方式，更多的考虑当前的实际场景，来设计适合自己的模块化方式。希望大家都能找到适合自己应用的业务模块化之路。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kyan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
